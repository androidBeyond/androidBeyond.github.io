---
layout:     post
title:      Android10 OTA升级流程分析
subtitle:   目前Android系统终端的升级主要是通过无线进行的（FOTA，Firmware Over-The-Air）
date:       2020-09-17
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - Android
    - OTA升级
---

<h2><a id="_2"></a>一、概述</h2> 
<p>目前Android系统终端的升级主要是通过无线进行的&#xff08;FOTA&#xff0c;Firmware Over-The-Air&#xff09;&#xff0c;主要流程是通过无线方式将升级包下载到终端&#xff0c;而后调用系统的升级接口进行升级。本文主要分析升级包下载后&#xff0c;调用系统升级接口之后的流程。</p> 
<h3><a id="11___6"></a>1.1 升级包结构</h3> 
<p>升级包是用make otapackage命令生成的&#xff0c;对于差分包&#xff0c;需要生成两个ota整包&#xff0c;再用系统的编译工具利用这两个整包生成一个差分包。下面是某终端Android9.0版本的ota升级包结构。</p> 
<pre><code>├─firmware-update
└─META-INF
    └─com
        ├─android
            ├─metadata
            ├─otacert
        └─google
            └─android
               ├─update-binary
               ├─updater-script
 ├─boot.img
 ├─system.new.dat.br
 ├─system.patch.dat
 ├─system.transfer.list
 ├─vendor.new.dat.br
 ├─vendor.patch.dat
 ├─vendor.transfer.list 
</code></pre> 
<p>firmware-update&#xff1a;目录下主要是一些固件的升级&#xff0c;如mbn、dtbo、vbmeta等</p> 
<p>boot.img&#xff1a;更新boot分区所需要的文件&#xff0c;包括kernel&#43;ramdisk</p> 
<p>system.new.dat.br&#xff1a;Android8.1镜像后新的压缩格式&#xff0c;为数据部分&#xff0c;里面是system.img数据。</p> 
<p>system.transfer.list&#xff1a;数据转换的描述列表。</p> 
<p>system.patch.dat&#xff1a;升级时用到&#xff0c;ota包中大小为0。</p> 
<p>vendor和system类似。</p> 
<p>update-binary&#xff1a;二进制文件&#xff0c;相当于一个脚本解释器&#xff0c;能够识别updater-script中描述的操作&#xff0c;文件的命名由bootable/recovery/install.cpp 中的UPDATE_BINARY_NAME值而定。</p> 
<p>updater-script&#xff1a;升级包的升级脚本&#xff0c;文件的命名由bootable/recovery/updater/updater.cpp中的SCRIPT_NAME值而定。</p> 
<p>metadata&#xff1a;描述设备信息及环境变量的元数据&#xff0c;主要包括一些编译选项、签名公钥&#xff0c;时间戳以及设备型号等。</p> 
<p>otacert&#xff1a;ota签名。</p> 
<h3><a id="12__50"></a>1.2 系统启动模式</h3> 
<p>Android系统启动主要有两种&#xff1a;</p> 
<p>1.组合键</p> 
<p>用户通过按下组合键&#xff0c;不同的终端可以定义组合键&#xff0c;进入不同的工作模式&#xff0c;在bootable/bootloader/lk/app/aboot/aboot.c文件中判断&#xff0c;具体有两种&#xff1a;</p> 
<p>bootloader模式&#xff0c;可进一步进入fastboot&#xff08;快速刷机模式&#xff09;。</p> 
<p>Recovery模式&#xff0c;进入这种模式系统会出现一个简单的ui界面&#xff0c;用来提示用户的进一步操作。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RT9PaFD4-1577704943830)(/Android OTA升级流程分析/recovery.jpg)]</p> 
<p>2.正常启动</p> 
<p>没有按下任何组合键&#xff0c;正常开机&#xff0c;bootloader会读取启动控制信息块BCB(bootloader control block)&#xff0c;它是一个结构体&#xff0c;存放着启动命令Command。根据不同的命令&#xff0c;系统可以进入三种不同的启动模式。下面是Bootloader Message的定义&#xff0c;通过注释可以了解具体结构体中成员变量的含义。</p> 
<p>[-&gt;bootloader_message.h]</p> 
<pre><code>/* Bootloader Message (2-KiB)
 *
 * This structure describes the content of a block in flash
 * that is used for recovery and the bootloader to talk to
 * each other.
 *
 * The command field is updated by linux when it wants to
 * reboot into recovery or to update radio or bootloader firmware.
 * It is also updated by the bootloader when firmware update
 * is complete (to boot into recovery for any final cleanup)
 *
 * The status field was used by the bootloader after the completion
 * of an &#34;update-radio&#34; or &#34;update-hboot&#34; command, which has been
 * deprecated since Froyo.
 *
 * The recovery field is only written by linux and used
 * for the system to send a message to recovery or the
 * other way around.
 *
 * The stage field is written by packages which restart themselves
 * multiple times, so that the UI can reflect which invocation of the
 * package it is.  If the value is of the format &#34;#/#&#34; (eg, &#34;1/3&#34;),
 * the UI will add a simple indicator of that status.
 *
 * We used to have slot_suffix field for A/B boot control metadata in
 * this struct, which gets unintentionally cleared by recovery or
 * uncrypt. Move it into struct bootloader_message_ab to avoid the
 * issue.
 */
struct bootloader_message {
    char command[32];
    char status[32];
    char recovery[768];

    // The &#39;recovery&#39; field used to be 1024 bytes.  It has only ever
    // been used to store the recovery command line, so 768 bytes
    // should be plenty.  We carve off the last 256 bytes to store the
    // stage string (for multistage packages) and possible future
    // expansion.
    char stage[32];

    // The &#39;reserved&#39; field used to be 224 bytes when it was initially
    // carved off from the 1024-byte recovery field. Bump it up to
    // 1184-byte so that the entire bootloader_message struct rounds up
    // to 2048-byte.
    char reserved[1184];
};
</code></pre> 
<h2><a id="OTA_120"></a>二、OTA升级重启前</h2> 
<p>前面介绍完OTA升级包和系统启动模式&#xff0c;现在看下真正的ota升级的步骤。无论ota包是通过无线下载还是导入到SD卡&#xff0c;最后都会调用到RecoverySystem.installPackage方法&#xff0c;下面分析下这个详细的流程。</p> 
<h3><a id="21_RSinstallPackage_124"></a>2.1 RS.installPackage</h3> 
<p>[-&gt;RecoverySystem.java]</p> 
<pre><code>public static void installPackage(Context context, File packageFile, boolean processed)
            throws IOException {
        synchronized (sRequestLock) {
            LOG_FILE.delete();
            // Must delete the file in case it was created by system server.
            //删除之前的uncrypt file
            UNCRYPT_PACKAGE_FILE.delete();

            String filename &#61; packageFile.getCanonicalPath();
            Log.w(TAG, &#34;!!! REBOOTING TO INSTALL &#34; &#43; filename &#43; &#34; !!!&#34;);

            // If the package name ends with &#34;_s.zip&#34;, it&#39;s a security update.
            boolean securityUpdate &#61; filename.endsWith(&#34;_s.zip&#34;);

            // If the package is on the /data partition, the package needs to
            // be processed (i.e. uncrypt&#39;d). The caller specifies if that has
            // been done in &#39;processed&#39; parameter.
            //如果升级包的路径是/data/开始
            if (filename.startsWith(&#34;/data/&#34;)) {
                if (processed) {
                    if (!BLOCK_MAP_FILE.exists()) {
                        Log.e(TAG, &#34;Package claimed to have been processed but failed to find &#34;
                                &#43; &#34;the block map file.&#34;);
                        throw new IOException(&#34;Failed to find block map file&#34;);
                    }
                } else {
                    FileWriter uncryptFile &#61; new FileWriter(UNCRYPT_PACKAGE_FILE);
                    try {
                        //将路径写入uncryptFile
                        uncryptFile.write(filename &#43; &#34;/n&#34;);
                    } finally {
                        uncryptFile.close();
                    }
                    // UNCRYPT_PACKAGE_FILE needs to be readable and writable
                    // by system server.
                    if (!UNCRYPT_PACKAGE_FILE.setReadable(true, false)
                            || !UNCRYPT_PACKAGE_FILE.setWritable(true, false)) {
                        Log.e(TAG, &#34;Error setting permission for &#34; &#43; UNCRYPT_PACKAGE_FILE);
                    }

                    BLOCK_MAP_FILE.delete();
                }

                // If the package is on the /data partition, use the block map
                // file as the package name instead.
                filename &#61; &#34;&#64;/cache/recovery/block.map&#34;;
            }

            final String filenameArg &#61; &#34;--update_package&#61;&#34; &#43; filename &#43; &#34;/n&#34;;
            final String localeArg &#61; &#34;--locale&#61;&#34; &#43; Locale.getDefault().toLanguageTag() &#43; &#34;/n&#34;;
            final String securityArg &#61; &#34;--security/n&#34;;

            String command &#61; filenameArg &#43; localeArg;
            if (securityUpdate) {
                command &#43;&#61; securityArg;
            }

            RecoverySystem rs &#61; (RecoverySystem) context.getSystemService(
                    Context.RECOVERY_SERVICE);
            //向bootloader control block写入命名      
            if (!rs.setupBcb(command)) {
                throw new IOException(&#34;Setup BCB failed&#34;);
            }

            // Having set up the BCB (bootloader control block), go ahead and reboot
            PowerManager pm &#61; (PowerManager) context.getSystemService(Context.POWER_SERVICE);
            String reason &#61; PowerManager.REBOOT_RECOVERY_UPDATE;

            // On TV, reboot quiescently if the screen is off
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
                WindowManager wm &#61; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                if (wm.getDefaultDisplay().getState() !&#61; Display.STATE_ON) {
                    reason &#43;&#61; &#34;,quiescent&#34;;
                }
            }
            //重启
            pm.reboot(reason);
            throw new IOException(&#34;Reboot failed (no permissions?)&#34;);
        }
    }
</code></pre> 
<p>private static final File RECOVERY_DIR &#61; new File(&#34;/cache/recovery&#34;);</p> 
<p>public static final File UNCRYPT_PACKAGE_FILE &#61; new File(RECOVERY_DIR, “uncrypt_file”);</p> 
<p>这里主要是对ota升级包的处理&#xff0c;由于进入recovery模式后&#xff0c;data分区将不能加载&#xff0c;因此需要将其通过block方式&#xff0c;把ota升级包生成稀疏的描述文件&#xff0c;保存在/cache/recovery/block.map中。升级的命令写入到BCB,重启之后bootloader会读取BCB中的command从而进入升级模式。</p> 
<h3><a id="22_RSsetupBcb_217"></a>2.2 RS.setupBcb</h3> 
<p>[-&gt;RecoverySystem.java]</p> 
<pre><code>  /**
     * Talks to RecoverySystemService via Binder to set up the BCB.
     */
    private boolean setupBcb(String command) {
        try {
            //通过binder调用setupBcb
            return mService.setupBcb(command);
        } catch (RemoteException unused) {
        }
        return false;
    }

</code></pre> 
<h3><a id="23_RSSsetupBcb_236"></a>2.3 RSS.setupBcb</h3> 
<p>[-&gt;RecoverySystemService.java]</p> 
<pre><code>       &#64;Override // Binder call
        public boolean setupBcb(String command) {
            if (DEBUG) Slog.d(TAG, &#34;setupBcb: [&#34; &#43; command &#43; &#34;]&#34;);
            synchronized (sRequestLock) {
                return setupOrClearBcb(true, command);
            }
        }
</code></pre> 
<h3><a id="24_RSSsetupOrClearBcb_250"></a>2.4 RSS.setupOrClearBcb</h3> 
<p>[-&gt;RecoverySystemService.java]</p> 
<pre><code>  private boolean setupOrClearBcb(boolean isSetup, String command) {
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);

            final boolean available &#61; checkAndWaitForUncryptService();
            if (!available) {
                Slog.e(TAG, &#34;uncrypt service is unavailable.&#34;);
                return false;
            }
            //设置ctl.start属性&#xff0c;启动setup-bcb服务
            if (isSetup) {
                SystemProperties.set(&#34;ctl.start&#34;, &#34;setup-bcb&#34;);
            } else {
                SystemProperties.set(&#34;ctl.start&#34;, &#34;clear-bcb&#34;);
            }

            // Connect to the uncrypt service socket.
            // 连接uncrypt服务
            LocalSocket socket &#61; connectService();
            if (socket &#61;&#61; null) {
                Slog.e(TAG, &#34;Failed to connect to uncrypt socket&#34;);
                return false;
            }

            DataInputStream dis &#61; null;
            DataOutputStream dos &#61; null;
            try {
                dis &#61; new DataInputStream(socket.getInputStream());
                dos &#61; new DataOutputStream(socket.getOutputStream());

                // Send the BCB commands if it&#39;s to setup BCB.
                // 发送BCB commands
                if (isSetup) {
                    byte[] cmdUtf8 &#61; command.getBytes(&#34;UTF-8&#34;);
                    dos.writeInt(cmdUtf8.length);
                    dos.write(cmdUtf8, 0, cmdUtf8.length);
                    dos.flush();
                }

                // Read the status from the socket.
                int status &#61; dis.readInt();

                // Ack receipt of the status code. uncrypt waits for the ack so
                // the socket won&#39;t be destroyed before we receive the code.
                dos.writeInt(0);

                if (status &#61;&#61; 100) {
                    Slog.i(TAG, &#34;uncrypt &#34; &#43; (isSetup ? &#34;setup&#34; : &#34;clear&#34;) &#43;
                            &#34; bcb successfully finished.&#34;);
                } else {
                    // Error in /system/bin/uncrypt.
                    Slog.e(TAG, &#34;uncrypt failed with status: &#34; &#43; status);
                    return false;
                }
            } catch (IOException e) {
                Slog.e(TAG, &#34;IOException when communicating with uncrypt:&#34;, e);
                return false;
            } finally {
                IoUtils.closeQuietly(dis);
                IoUtils.closeQuietly(dos);
                IoUtils.closeQuietly(socket);
            }

            return true;
        }
</code></pre> 
<p>SystemProperties.set(“ctl.start”, “setup-bcb”)&#xff0c;通过这种方式来启动服务&#xff08;SystemProperties设置属性的原理详细见文章<a href="https://skytoby.github.io/2019/Android%20SystemProperties%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/">Android SystemProperties系统属性分析</a>&#xff09;&#xff0c;而后连接服务&#xff0c;向其中发送BCB command。</p> 
<h3><a id="25__PMreboot_323"></a>2.5 PM.reboot</h3> 
<p>[-&gt;PowerManager.java]</p> 
<pre><code> public void reboot(String reason) {
        try {
            mService.reboot(false, reason, true);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
</code></pre> 
<h3><a id="26__PMSreboot_337"></a>2.6 PMS.reboot</h3> 
<p>[-&gt;PowerManagerService.java]</p> 
<pre><code>        /**
         * Reboots the device.
         *
         * &#64;param confirm If true, shows a reboot confirmation dialog.
         * &#64;param reason The reason for the reboot, or null if none.
         * &#64;param wait If true, this call waits for the reboot to complete and does not return.
         */
        &#64;Override // Binder call
        public void reboot(boolean confirm, String reason, boolean wait) {
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
            if (PowerManager.REBOOT_RECOVERY.equals(reason)
                    || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);
            }

            final long ident &#61; Binder.clearCallingIdentity();
            try {
                shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
</code></pre> 
<p>这里传入的参数confirm&#xff1a;false &#xff0c; reason&#xff1a;REBOOT_RECOVERY_UPDATE &#61; “recovery-update”&#xff0c;wait&#xff1a;true</p> 
<h3><a id="27__PMSshutdownOrRebootInternal_368"></a>2.7 PMS.shutdownOrRebootInternal</h3> 
<p>[-&gt;PowerManagerService.java]</p> 
<pre><code>  private void shutdownOrRebootInternal(final &#64;HaltMode int haltMode, final boolean confirm,
            final String reason, boolean wait) {
        if (mHandler &#61;&#61; null || !mSystemReady) {
            if (RescueParty.isAttemptingFactoryReset()) {
                // If we&#39;re stuck in a really low-level reboot loop, and a
                // rescue party is trying to prompt the user for a factory data
                // reset, we must GET TO DA CHOPPA!
                PowerManagerService.lowLevelReboot(reason);
            } else {
                throw new IllegalStateException(&#34;Too early to call shutdown() or reboot()&#34;);
            }
        }
        //上面传过来的是HALT_MODE_REBOOT
        Runnable runnable &#61; new Runnable() {
            &#64;Override
            public void run() {
                synchronized (this) {
                    if (haltMode &#61;&#61; HALT_MODE_REBOOT_SAFE_MODE) {
                        ShutdownThread.rebootSafeMode(getUiContext(), confirm);
                    } else if (haltMode &#61;&#61; HALT_MODE_REBOOT) {
                        ShutdownThread.reboot(getUiContext(), reason, confirm);
                    } else {
                        ShutdownThread.shutdown(getUiContext(), reason, confirm);
                    }
                }
            }
        };

        // ShutdownThread must run on a looper capable of displaying the UI.
        Message msg &#61; Message.obtain(UiThread.getHandler(), runnable);
        msg.setAsynchronous(true);
        UiThread.getHandler().sendMessage(msg);

        // PowerManager.reboot() is documented not to return so just wait for the inevitable.
        if (wait) {
            synchronized (runnable) {
                while (true) {
                    try {
                        runnable.wait();
                    } catch (InterruptedException e) {
                    }
                }
            }
        }
    }
</code></pre> 
<h3><a id="28_STreboot_420"></a>2.8 ST.reboot</h3> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code>public static void reboot(final Context context, String reason, boolean confirm) {
        mReboot &#61; true;
        mRebootSafeMode &#61; false;
        mRebootHasProgressBar &#61; false;
        mReason &#61; reason;
        shutdownInner(context, confirm);
    }
</code></pre> 
<h3><a id="29_STshutdownInner_434"></a>2.9 ST.shutdownInner</h3> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code> private static void shutdownInner(final Context context, boolean confirm) {
        // ShutdownThread is called from many places, so best to verify here that the context passed
        // in is themed.
        context.assertRuntimeOverlayThemable();

        // ensure that only one thread is trying to power down.
        // any additional calls are just returned
        synchronized (sIsStartedGuard) {
            if (sIsStarted) {
                Log.d(TAG, &#34;Request to shutdown already running, returning.&#34;);
                return;
            }
        }

        final int longPressBehavior &#61; context.getResources().getInteger(
                        com.android.internal.R.integer.config_longPressOnPowerBehavior);
        final int resourceId &#61; mRebootSafeMode
                ? com.android.internal.R.string.reboot_safemode_confirm
                : (longPressBehavior &#61;&#61; 2
                        ? com.android.internal.R.string.shutdown_confirm_question
                        : com.android.internal.R.string.shutdown_confirm);

        Log.d(TAG, &#34;Notifying thread to start shutdown longPressBehavior&#61;&#34; &#43; longPressBehavior);

        if (confirm) {
            final CloseDialogReceiver closer &#61; new CloseDialogReceiver(context);
            if (sConfirmDialog !&#61; null) {
                sConfirmDialog.dismiss();
            }
            sConfirmDialog &#61; new AlertDialog.Builder(context)
                    .setTitle(mRebootSafeMode
                            ? com.android.internal.R.string.reboot_safemode_title
                            : com.android.internal.R.string.power_off)
                    .setMessage(resourceId)
                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int which) {
                            beginShutdownSequence(context);
                        }
                    })
                    .setNegativeButton(com.android.internal.R.string.no, null)
                    .create();
            closer.dialog &#61; sConfirmDialog;
            sConfirmDialog.setOnDismissListener(closer);
            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
            sConfirmDialog.show();
        } else {
            //走这里
            beginShutdownSequence(context);
        }
    }

</code></pre> 
<h3><a id="210_STbeginShutdownSequence_492"></a>2.10 ST.beginShutdownSequence</h3> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code> private static void beginShutdownSequence(Context context) {
        synchronized (sIsStartedGuard) {
            if (sIsStarted) {
                Log.d(TAG, &#34;Shutdown sequence already running, returning.&#34;);
                return;
            }
            sIsStarted &#61; true;
        }

        sInstance.mProgressDialog &#61; showShutdownDialog(context);
        sInstance.mContext &#61; context;
        sInstance.mPowerManager &#61; (PowerManager)context.getSystemService(Context.POWER_SERVICE);

        // make sure we never fall asleep again
        sInstance.mCpuWakeLock &#61; null;
        try {
            sInstance.mCpuWakeLock &#61; sInstance.mPowerManager.newWakeLock(
                    PowerManager.PARTIAL_WAKE_LOCK, TAG &#43; &#34;-cpu&#34;);
            sInstance.mCpuWakeLock.setReferenceCounted(false);
            sInstance.mCpuWakeLock.acquire();
        } catch (SecurityException e) {
            Log.w(TAG, &#34;No permission to acquire wake lock&#34;, e);
            sInstance.mCpuWakeLock &#61; null;
        }

        // also make sure the screen stays on for better user experience
        sInstance.mScreenWakeLock &#61; null;
        if (sInstance.mPowerManager.isScreenOn()) {
            try {
                sInstance.mScreenWakeLock &#61; sInstance.mPowerManager.newWakeLock(
                        PowerManager.FULL_WAKE_LOCK, TAG &#43; &#34;-screen&#34;);
                sInstance.mScreenWakeLock.setReferenceCounted(false);
                sInstance.mScreenWakeLock.acquire();
            } catch (SecurityException e) {
                Log.w(TAG, &#34;No permission to acquire wake lock&#34;, e);
                sInstance.mScreenWakeLock &#61; null;
            }
        }

        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(SecurityLog.TAG_OS_SHUTDOWN);
        }

        // start the thread that initiates shutdown
        sInstance.mHandler &#61; new Handler() {
        };
        //启动线程
        sInstance.start();
    }
</code></pre> 
<h4><a id="2101_STshowShutdownDialog_548"></a>2.10.1 ST.showShutdownDialog</h4> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code>private static ProgressDialog showShutdownDialog(Context context) {
        // Throw up a system dialog to indicate the device is rebooting / shutting down.
        ProgressDialog pd &#61; new ProgressDialog(context);

        // Path 1: Reboot to recovery for update
        //   Condition: mReason startswith REBOOT_RECOVERY_UPDATE
        //
        //  Path 1a: uncrypt needed
        //   Condition: if /cache/recovery/uncrypt_file exists but
        //              /cache/recovery/block.map doesn&#39;t.
        //   UI: determinate progress bar (mRebootHasProgressBar &#61;&#61; True)
        //
        // * Path 1a is expected to be removed once the GmsCore shipped on
        //   device always calls uncrypt prior to reboot.
        //
        //  Path 1b: uncrypt already done
        //   UI: spinning circle only (no progress bar)
        //
        // Path 2: Reboot to recovery for factory reset
        //   Condition: mReason &#61;&#61; REBOOT_RECOVERY
        //   UI: spinning circle only (no progress bar)
        //
        // Path 3: Regular reboot / shutdown
        //   Condition: Otherwise
        //   UI: spinning circle only (no progress bar)

        // mReason could be &#34;recovery-update&#34; or &#34;recovery-update,quiescent&#34;.
        //传入的是REBOOT_RECOVERY_UPDATE&#xff0c;走这里
        if (mReason !&#61; null &amp;&amp; mReason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) {
            // We need the progress bar if uncrypt will be invoked during the
            // reboot, which might be time-consuming.
            mRebootHasProgressBar &#61; RecoverySystem.UNCRYPT_PACKAGE_FILE.exists()
                    &amp;&amp; !(RecoverySystem.BLOCK_MAP_FILE.exists());
            pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
            //正常升级模式下&#xff0c;mRebootHasProgressBar &#61; true
            if (mRebootHasProgressBar) {
                pd.setMax(100);
                pd.setProgress(0);
                pd.setIndeterminate(false);
                pd.setProgressNumberFormat(null);
                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                pd.setMessage(context.getText(
                            com.android.internal.R.string.reboot_to_update_prepare));
            } else {
                if (showSysuiReboot()) {
                    return null;
                }
                pd.setIndeterminate(true);
                pd.setMessage(context.getText(
                            com.android.internal.R.string.reboot_to_update_reboot));
            }
        } else if (mReason !&#61; null &amp;&amp; mReason.equals(PowerManager.REBOOT_RECOVERY)) {
            if (RescueParty.isAttemptingFactoryReset()) {
                // We&#39;re not actually doing a factory reset yet; we&#39;re rebooting
                // to ask the user if they&#39;d like to reset, so give them a less
                // scary dialog message.
                pd.setTitle(context.getText(com.android.internal.R.string.power_off));
                pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
                pd.setIndeterminate(true);
            } else {
                // Factory reset path. Set the dialog message accordingly.
                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
                pd.setMessage(context.getText(
                            com.android.internal.R.string.reboot_to_reset_message));
                pd.setIndeterminate(true);
            }
        } else {
            if (showSysuiReboot()) {
                return null;
            }
            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
            pd.setIndeterminate(true);
        }
        pd.setCancelable(false);
        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);

        pd.show();
        return pd;
    }
</code></pre> 
<h3><a id="211_STrun_635"></a>2.11 ST.run</h3> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code>  /**
     * Makes sure we handle the shutdown gracefully.
     * Shuts off power regardless of radio state if the allotted time has passed.
     */
    public void run() {
        TimingsTraceLog shutdownTimingLog &#61; newTimingsLog();
        shutdownTimingLog.traceBegin(&#34;SystemServerShutdown&#34;);
        metricShutdownStart();
        metricStarted(METRIC_SYSTEM_SERVER);

        BroadcastReceiver br &#61; new BroadcastReceiver() {
            &#64;Override public void onReceive(Context context, Intent intent) {
                // We don&#39;t allow apps to cancel this, so ignore the result.
                actionDone();
            }
        };

        /*
         * Write a system property in case the system_server reboots before we
         * get to the actual hardware restart. If that happens, we&#39;ll retry at
         * the beginning of the SystemServer startup.
         */
        {
            String reason &#61; (mReboot ? &#34;1&#34; : &#34;0&#34;) &#43; (mReason !&#61; null ? mReason : &#34;&#34;);
            SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
        }

        /*
         * If we are rebooting into safe mode, write a system property
         * indicating so.
         */
        if (mRebootSafeMode) {
            SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, &#34;1&#34;);
        }

        metricStarted(METRIC_SEND_BROADCAST);
        shutdownTimingLog.traceBegin(&#34;SendShutdownBroadcast&#34;);
        Log.i(TAG, &#34;Sending shutdown broadcast...&#34;);

        // First send the high-level shut down broadcast.
        mActionDone &#61; false;
        Intent intent &#61; new Intent(Intent.ACTION_SHUTDOWN);
        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        mContext.sendOrderedBroadcastAsUser(intent,
                UserHandle.ALL, null, br, mHandler, 0, null, null);

        final long endTime &#61; SystemClock.elapsedRealtime() &#43; MAX_BROADCAST_TIME;
        synchronized (mActionDoneSync) {
            while (!mActionDone) {
                long delay &#61; endTime - SystemClock.elapsedRealtime();
                if (delay &lt;&#61; 0) {
                    Log.w(TAG, &#34;Shutdown broadcast timed out&#34;);
                    break;
                } else if (mRebootHasProgressBar) {
                    int status &#61; (int)((MAX_BROADCAST_TIME - delay) * 1.0 *
                            BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);
                    sInstance.setRebootProgress(status, null);
                }
                try {
                    mActionDoneSync.wait(Math.min(delay, ACTION_DONE_POLL_WAIT_MS));
                } catch (InterruptedException e) {
                }
            }
        }
        if (mRebootHasProgressBar) {
            sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);
        }
        shutdownTimingLog.traceEnd(); // SendShutdownBroadcast
        metricEnded(METRIC_SEND_BROADCAST);

        Log.i(TAG, &#34;Shutting down activity manager...&#34;);
        shutdownTimingLog.traceBegin(&#34;ShutdownActivityManager&#34;);
        metricStarted(METRIC_AM);

        final IActivityManager am &#61;
                IActivityManager.Stub.asInterface(ServiceManager.checkService(&#34;activity&#34;));
        if (am !&#61; null) {
            try {
                am.shutdown(MAX_BROADCAST_TIME);
            } catch (RemoteException e) {
            }
        }
        if (mRebootHasProgressBar) {
            sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);
        }
        shutdownTimingLog.traceEnd();// ShutdownActivityManager
        metricEnded(METRIC_AM);

        Log.i(TAG, &#34;Shutting down package manager...&#34;);
        shutdownTimingLog.traceBegin(&#34;ShutdownPackageManager&#34;);
        metricStarted(METRIC_PM);

        final PackageManagerService pm &#61; (PackageManagerService)
            ServiceManager.getService(&#34;package&#34;);
        if (pm !&#61; null) {
            pm.shutdown();
        }
        if (mRebootHasProgressBar) {
            sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);
        }
        shutdownTimingLog.traceEnd(); // ShutdownPackageManager
        metricEnded(METRIC_PM);

        // Shutdown radios.
        shutdownTimingLog.traceBegin(&#34;ShutdownRadios&#34;);
        metricStarted(METRIC_RADIOS);
        shutdownRadios(MAX_RADIO_WAIT_TIME);
        if (mRebootHasProgressBar) {
            sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);
        }
        shutdownTimingLog.traceEnd(); // ShutdownRadios
        metricEnded(METRIC_RADIOS);
        
        //为true&#xff0c;将执行uncrypt操作
        if (mRebootHasProgressBar) {
            sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);

            // If it&#39;s to reboot to install an update and uncrypt hasn&#39;t been
            // done yet, trigger it now.
            uncrypt();
        }

        shutdownTimingLog.traceEnd(); // SystemServerShutdown
        metricEnded(METRIC_SYSTEM_SERVER);
        saveMetrics(mReboot, mReason);
        // Remaining work will be done by init, including vold shutdown
        rebootOrShutdown(mContext, mReboot, mReason);
    }
</code></pre> 
<h3><a id="212_STuncrypt_770"></a>2.12 ST.uncrypt</h3> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code>private void uncrypt() {
        Log.i(TAG, &#34;Calling uncrypt and monitoring the progress...&#34;);

        final RecoverySystem.ProgressListener progressListener &#61;
                new RecoverySystem.ProgressListener() {
            &#64;Override
            public void onProgress(int status) {
                if (status &gt;&#61; 0 &amp;&amp; status &lt; 100) {
                    // Scale down to [MOUNT_SERVICE_STOP_PERCENT, 100).
                    status &#61; (int)(status * (100.0 - MOUNT_SERVICE_STOP_PERCENT) / 100);
                    status &#43;&#61; MOUNT_SERVICE_STOP_PERCENT;
                    CharSequence msg &#61; mContext.getText(
                            com.android.internal.R.string.reboot_to_update_package);
                    sInstance.setRebootProgress(status, msg);
                } else if (status &#61;&#61; 100) {
                    CharSequence msg &#61; mContext.getText(
                            com.android.internal.R.string.reboot_to_update_reboot);
                    sInstance.setRebootProgress(status, msg);
                } else {
                    // Ignored
                }
            }
        };

        final boolean[] done &#61; new boolean[1];
        done[0] &#61; false;
        Thread t &#61; new Thread() {
            &#64;Override
            public void run() {
                RecoverySystem rs &#61; (RecoverySystem) mContext.getSystemService(
                        Context.RECOVERY_SERVICE);
                String filename &#61; null;
                try {
                    filename &#61; FileUtils.readTextFile(RecoverySystem.UNCRYPT_PACKAGE_FILE, 0, null);
                    rs.processPackage(mContext, new File(filename), progressListener);
                } catch (IOException e) {
                    Log.e(TAG, &#34;Error uncrypting file&#34;, e);
                }
                done[0] &#61; true;
            }
        };
        t.start();

        try {
            t.join(MAX_UNCRYPT_WAIT_TIME);
        } catch (InterruptedException unused) {
        }
        if (!done[0]) {
            Log.w(TAG, &#34;Timed out waiting for uncrypt.&#34;);
            final int uncryptTimeoutError &#61; 100;
            String timeoutMessage &#61; String.format(&#34;uncrypt_time: %d/n&#34; &#43; &#34;uncrypt_error: %d/n&#34;,
                    MAX_UNCRYPT_WAIT_TIME / 1000, uncryptTimeoutError);
            try {
                FileUtils.stringToFile(RecoverySystem.UNCRYPT_STATUS_FILE, timeoutMessage);
            } catch (IOException e) {
                Log.e(TAG, &#34;Failed to write timeout message to uncrypt status&#34;, e);
            }
        }
    }
</code></pre> 
<h3><a id="213_RSprocessPackage_836"></a>2.13 RS.processPackage</h3> 
<p>[-&gt;RecoverySystem.java]</p> 
<pre><code> public static void processPackage(Context context,
                                      File packageFile,
                                      final ProgressListener listener,
                                      final Handler handler)
            throws IOException {
        String filename &#61; packageFile.getCanonicalPath();
        if (!filename.startsWith(&#34;/data/&#34;)) {
            return;
        }

        RecoverySystem rs &#61; (RecoverySystem) context.getSystemService(Context.RECOVERY_SERVICE);
        IRecoverySystemProgressListener progressListener &#61; null;
        if (listener !&#61; null) {
            final Handler progressHandler;
            if (handler !&#61; null) {
                progressHandler &#61; handler;
            } else {
                progressHandler &#61; new Handler(context.getMainLooper());
            }
            progressListener &#61; new IRecoverySystemProgressListener.Stub() {
                int lastProgress &#61; 0;
                long lastPublishTime &#61; System.currentTimeMillis();

                &#64;Override
                public void onProgress(final int progress) {
                    final long now &#61; System.currentTimeMillis();
                    progressHandler.post(new Runnable() {
                        &#64;Override
                        public void run() {
                            if (progress &gt; lastProgress &amp;&amp;
                                    now - lastPublishTime &gt; PUBLISH_PROGRESS_INTERVAL_MS) {
                                lastProgress &#61; progress;
                                lastPublishTime &#61; now;
                                listener.onProgress(progress);
                            }
                        }
                    });
                }
            };
        }
        //通过progressListener传递进度到界面
        if (!rs.uncrypt(filename, progressListener)) {
            throw new IOException(&#34;process package failed&#34;);
        }
    }
</code></pre> 
<h3><a id="214_RSuncrypt_888"></a>2.14 RS.uncrypt</h3> 
<p>[-&gt;RecoverySystem.java]</p> 
<pre><code> /**
     * Talks to RecoverySystemService via Binder to trigger uncrypt.
     */
    private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener) {
        try {
            return mService.uncrypt(packageFile, listener);
        } catch (RemoteException unused) {
        }
        return false;
    }
</code></pre> 
<h3><a id="215_RSSuncrypt_905"></a>2.15 RSS.uncrypt</h3> 
<p>[-&gt;RecoverySystemService.java]</p> 
<pre><code>public boolean uncrypt(String filename, IRecoverySystemProgressListener listener) {
            if (DEBUG) Slog.d(TAG, &#34;uncrypt: &#34; &#43; filename);

            synchronized (sRequestLock) {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);

                final boolean available &#61; checkAndWaitForUncryptService();
                if (!available) {
                    Slog.e(TAG, &#34;uncrypt service is unavailable.&#34;);
                    return false;
                }

                // Write the filename into UNCRYPT_PACKAGE_FILE to be read by
                // uncrypt.
                RecoverySystem.UNCRYPT_PACKAGE_FILE.delete();

                try (FileWriter uncryptFile &#61; new FileWriter(RecoverySystem.UNCRYPT_PACKAGE_FILE)) {
                    uncryptFile.write(filename &#43; &#34;/n&#34;);
                } catch (IOException e) {
                    Slog.e(TAG, &#34;IOException when writing /&#34;&#34; &#43;
                            RecoverySystem.UNCRYPT_PACKAGE_FILE &#43; &#34;/&#34;:&#34;, e);
                    return false;
                }

                // Trigger uncrypt via init.
                //通过设置ctl.start属性&#xff0c;开启uncrypt服务
                SystemProperties.set(&#34;ctl.start&#34;, &#34;uncrypt&#34;);

                // Connect to the uncrypt service socket.
                //连接服务
                LocalSocket socket &#61; connectService();
                if (socket &#61;&#61; null) {
                    Slog.e(TAG, &#34;Failed to connect to uncrypt socket&#34;);
                    return false;
                }

                // Read the status from the socket.
                DataInputStream dis &#61; null;
                DataOutputStream dos &#61; null;
                try {
                    dis &#61; new DataInputStream(socket.getInputStream());
                    dos &#61; new DataOutputStream(socket.getOutputStream());
                    int lastStatus &#61; Integer.MIN_VALUE;
                    while (true) {
                        // 读取进度
                        int status &#61; dis.readInt();
                        // Avoid flooding the log with the same message.
                        if (status &#61;&#61; lastStatus &amp;&amp; lastStatus !&#61; Integer.MIN_VALUE) {
                            continue;
                        }
                        lastStatus &#61; status;

                        if (status &gt;&#61; 0 &amp;&amp; status &lt;&#61; 100) {
                            // Update status
                            Slog.i(TAG, &#34;uncrypt read status: &#34; &#43; status);
                            if (listener !&#61; null) {
                                try {
                                    listener.onProgress(status);
                                } catch (RemoteException ignored) {
                                    Slog.w(TAG, &#34;RemoteException when posting progress&#34;);
                                }
                            }
                            if (status &#61;&#61; 100) {
                                Slog.i(TAG, &#34;uncrypt successfully finished.&#34;);
                                // Ack receipt of the final status code. uncrypt
                                // waits for the ack so the socket won&#39;t be
                                // destroyed before we receive the code.
                                dos.writeInt(0);
                                break;
                            }
                        } else {
                            // Error in /system/bin/uncrypt.
                            Slog.e(TAG, &#34;uncrypt failed with status: &#34; &#43; status);
                            // Ack receipt of the final status code. uncrypt waits
                            // for the ack so the socket won&#39;t be destroyed before
                            // we receive the code.
                            dos.writeInt(0);
                            return false;
                        }
                    }
                } catch (IOException e) {
                    Slog.e(TAG, &#34;IOException when reading status: &#34;, e);
                    return false;
                } finally {
                    IoUtils.closeQuietly(dis);
                    IoUtils.closeQuietly(dos);
                    IoUtils.closeQuietly(socket);
                }

                return true;
            }
        }
</code></pre> 
<p>SystemProperties.set(“ctl.start”, “uncrypt”);这个操作主要是通过init&#xff08;启动的Properties服务&#xff09;进行,而后启动uncrypt服务&#xff0c;通过socket方式systemserver和uncrypt进行通信。</p> 
<p>[-&gt;uncrypt.rc]</p> 
<pre><code>service uncrypt /system/bin/uncrypt
    class main
    socket uncrypt stream 600 system system
    disabled
    oneshot

service setup-bcb /system/bin/uncrypt --setup-bcb
    class main
    socket uncrypt stream 600 system system
    disabled
    oneshot

service clear-bcb /system/bin/uncrypt --clear-bcb
    class main
    socket uncrypt stream 600 system system
    disabled
    oneshot

</code></pre> 
<h3><a id="216_uncryptmain_1029"></a>2.16 uncrypt.main</h3> 
<p>[-&gt;uncrypt.cpp]</p> 
<pre><code>//
// If the filesystem is using an encrypted block device, it will also
// read the file and rewrite it to the same blocks of the underlying
// (unencrypted) block device, so the file contents can be read
// without the need for the decryption key.
//
// The output of this program is a &#34;block map&#34; which looks like this:
//
//     /dev/block/platform/msm_sdcc.1/by-name/userdata     # block device
//     49652 4096                        # file size in bytes, block size
//     3                                 # count of block ranges
//     1000 1008                         # block range 0
//     2100 2102                         # ... block range 1
//     30 33                             # ... block range 2
//
// Each block range represents a half-open interval; the line &#34;30 33&#34;
// reprents the blocks [30, 31, 32].
//
// Recovery can take this block map file and retrieve the underlying
// file data to use as an update package.

/**
 * In addition to the uncrypt work, uncrypt also takes care of setting and
 * clearing the bootloader control block (BCB) at /misc partition.
 *
 * uncrypt is triggered as init services on demand. It uses socket to
 * communicate with its caller (i.e. system_server). The socket is managed by
 * init (i.e. created prior to the service starts, and destroyed when uncrypt
 * exits).
 *
 * Below is the uncrypt protocol.
 *
 *    a. caller                 b. init                    c. uncrypt
 * ---------------            ------------               --------------
 *  a1. ctl.start:
 *    setup-bcb /
 *    clear-bcb /
 *    uncrypt
 *
 *                         b2. create socket at
 *                           /dev/socket/uncrypt
 *
 *                                                   c3. listen and accept
 *
 *  a4. send a 4-byte int
 *    (message length)
 *                                                   c5. receive message length
 *  a6. send message
 *                                                   c7. receive message
 *                                                   c8. &lt;do the work; may send
 *                                                      the progress&gt;
 *  a9. &lt;may handle progress&gt;
 *                                                   c10. &lt;upon finishing&gt;
 *                                                     send &#34;100&#34; or &#34;-1&#34;
 *
 *  a11. receive status code
 *  a12. send a 4-byte int to
 *    ack the receive of the
 *    final status code
 *                                                   c13. receive and exit
 *
 *                          b14. destroy the socket
 *
 * Note that a12 and c13 are necessary to ensure a11 happens before the socket
 * gets destroyed in b14.
 */

int main(int argc, char** argv) {
    enum { UNCRYPT, SETUP_BCB, CLEAR_BCB, UNCRYPT_DEBUG } action;
    const char* input_path &#61; nullptr;
    const char* map_file &#61; CACHE_BLOCK_MAP.c_str();
    //解析参数
    if (argc &#61;&#61; 2 &amp;&amp; strcmp(argv[1], &#34;--clear-bcb&#34;) &#61;&#61; 0) {
        action &#61; CLEAR_BCB;
    } else if (argc &#61;&#61; 2 &amp;&amp; strcmp(argv[1], &#34;--setup-bcb&#34;) &#61;&#61; 0) {
        action &#61; SETUP_BCB;
    } else if (argc &#61;&#61; 1) {
        action &#61; UNCRYPT;
    } else if (argc &#61;&#61; 3) {
        input_path &#61; argv[1];
        map_file &#61; argv[2];
        action &#61; UNCRYPT_DEBUG;
    } else {
        usage(argv[0]);
        return 2;
    }

    if ((fstab &#61; read_fstab()) &#61;&#61; nullptr) {
        log_uncrypt_error_code(kUncryptFstabReadError);
        return 1;
    }

    if (action &#61;&#61; UNCRYPT_DEBUG) {
        LOG(INFO) &lt;&lt; &#34;uncrypt called in debug mode, skip socket communication&#34;;
        bool success &#61; uncrypt_wrapper(input_path, map_file, -1);
        if (success) {
            LOG(INFO) &lt;&lt; &#34;uncrypt succeeded&#34;;
        } else{
            LOG(INFO) &lt;&lt; &#34;uncrypt failed&#34;;
        }
        return success ? 0 : 1;
    }

    // c3. The socket is created by init when starting the service. uncrypt
    // will use the socket to communicate with its caller.
    android::base::unique_fd service_socket(android_get_control_socket(UNCRYPT_SOCKET.c_str()));
    if (service_socket &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to open socket /&#34;&#34; &lt;&lt; UNCRYPT_SOCKET &lt;&lt; &#34;/&#34;&#34;;
        log_uncrypt_error_code(kUncryptSocketOpenError);
        return 1;
    }
    fcntl(service_socket, F_SETFD, FD_CLOEXEC);

    if (listen(service_socket, 1) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to listen on socket &#34; &lt;&lt; service_socket.get();
        log_uncrypt_error_code(kUncryptSocketListenError);
        return 1;
    }

    android::base::unique_fd socket_fd(accept4(service_socket, nullptr, nullptr, SOCK_CLOEXEC));
    if (socket_fd &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to accept on socket &#34; &lt;&lt; service_socket.get();
        log_uncrypt_error_code(kUncryptSocketAcceptError);
        return 1;
    }

    bool success &#61; false;
    switch (action) {
        //UNCRYPT操作
        case UNCRYPT:
            success &#61; uncrypt_wrapper(input_path, map_file, socket_fd);
            break;
        case SETUP_BCB:
            success &#61; setup_bcb(socket_fd);
            break;
        case CLEAR_BCB:
            success &#61; clear_bcb(socket_fd);
            break;
        default:  // Should never happen.
            LOG(ERROR) &lt;&lt; &#34;Invalid uncrypt action code: &#34; &lt;&lt; action;
            return 1;
    }

    // c13. Read a 4-byte code from the client before uncrypt exits. This is to
    // ensure the client to receive the last status code before the socket gets
    // destroyed.
    int code;
    if (android::base::ReadFully(socket_fd, &amp;code, 4)) {
        LOG(INFO) &lt;&lt; &#34;  received &#34; &lt;&lt; code &lt;&lt; &#34;, exiting now&#34;;
    } else {
        PLOG(ERROR) &lt;&lt; &#34;failed to read the code&#34;;
    }
    return success ? 0 : 1;
}

</code></pre> 
<p>通过文件头的注释&#xff0c;可以知道具体的通信方式。</p> 
<h3><a id="217_uncryptuncrypt_wrapper_1193"></a>2.17 uncrypt.uncrypt_wrapper</h3> 
<p>[-&gt;uncrypt.cpp]</p> 
<pre><code>static bool uncrypt_wrapper(const char* input_path, const char* map_file, const int socket) {
    // Initialize the uncrypt error to kUncryptErrorPlaceholder.
    log_uncrypt_error_code(kUncryptErrorPlaceholder);

    std::string package;
    if (input_path &#61;&#61; nullptr) {
        if (!find_uncrypt_package(UNCRYPT_PATH_FILE, &amp;package)) {
            write_status_to_socket(-1, socket);
            // Overwrite the error message.
            log_uncrypt_error_code(kUncryptPackageMissingError);
            return false;
        }
        input_path &#61; package.c_str();
    }
    CHECK(map_file !&#61; nullptr);

    auto start &#61; std::chrono::system_clock::now();
    //执行uncrypt操作
    int status &#61; uncrypt(input_path, map_file, socket);
    std::chrono::duration&lt;double&gt; duration &#61; std::chrono::system_clock::now() - start;
    int count &#61; static_cast&lt;int&gt;(duration.count());

    std::string uncrypt_message &#61; android::base::StringPrintf(&#34;uncrypt_time: %d/n&#34;, count);
    if (status !&#61; 0) {
        // Log the time cost and error code if uncrypt fails.
        uncrypt_message &#43;&#61; android::base::StringPrintf(&#34;uncrypt_error: %d/n&#34;, status);
        if (!android::base::WriteStringToFile(uncrypt_message, UNCRYPT_STATUS)) {
            PLOG(WARNING) &lt;&lt; &#34;failed to write to &#34; &lt;&lt; UNCRYPT_STATUS;
        }

        write_status_to_socket(-1, socket);
        return false;
    }

    if (!android::base::WriteStringToFile(uncrypt_message, UNCRYPT_STATUS)) {
        PLOG(WARNING) &lt;&lt; &#34;failed to write to &#34; &lt;&lt; UNCRYPT_STATUS;
    }
    //通过socket方式通知进度
    write_status_to_socket(100, socket);

    return true;
}
</code></pre> 
<h3><a id="218__uncryptuncrypt_1242"></a>2.18 uncrypt.uncrypt</h3> 
<p>[-&gt;uncrypt.cpp]</p> 
<pre><code>static int uncrypt(const char* input_path, const char* map_file, const int socket) {
    LOG(INFO) &lt;&lt; &#34;update package is /&#34;&#34; &lt;&lt; input_path &lt;&lt; &#34;/&#34;&#34;;

    // Turn the name of the file we&#39;re supposed to convert into an absolute path, so we can find
    // what filesystem it&#39;s on.
    char path[PATH_MAX&#43;1];
    if (realpath(input_path, path) &#61;&#61; nullptr) {
        PLOG(ERROR) &lt;&lt; &#34;failed to convert /&#34;&#34; &lt;&lt; input_path &lt;&lt; &#34;/&#34; to absolute path&#34;;
        return kUncryptRealpathFindError;
    }

    bool encryptable;
    bool encrypted;
    bool f2fs_fs;
    const char* blk_dev &#61; find_block_device(path, &amp;encryptable, &amp;encrypted, &amp;f2fs_fs);
    if (blk_dev &#61;&#61; nullptr) {
        LOG(ERROR) &lt;&lt; &#34;failed to find block device for &#34; &lt;&lt; path;
        return kUncryptBlockDeviceFindError;
    }

    // If the filesystem it&#39;s on isn&#39;t encrypted, we only produce the
    // block map, we don&#39;t rewrite the file contents (it would be
    // pointless to do so).
    LOG(INFO) &lt;&lt; &#34;encryptable: &#34; &lt;&lt; (encryptable ? &#34;yes&#34; : &#34;no&#34;);
    LOG(INFO) &lt;&lt; &#34;  encrypted: &#34; &lt;&lt; (encrypted ? &#34;yes&#34; : &#34;no&#34;);

    // Recovery supports installing packages from 3 paths: /cache,
    // /data, and /sdcard.  (On a particular device, other locations
    // may work, but those are three we actually expect.)
    //
    // On /data we want to convert the file to a block map so that we
    // can read the package without mounting the partition.  On /cache
    // and /sdcard we leave the file alone.
    if (strncmp(path, &#34;/data/&#34;, 6) &#61;&#61; 0) {
        LOG(INFO) &lt;&lt; &#34;writing block map &#34; &lt;&lt; map_file;
        //生成blockmap
        return produce_block_map(path, map_file, blk_dev, encrypted, f2fs_fs, socket);
    }

    return 0;
}
</code></pre> 
<h3><a id="219__uncryptproduce_block_map_1290"></a>2.19 uncrypt.produce_block_map</h3> 
<p>[-&gt;uncrypt.cpp]</p> 
<pre><code>  static int produce_block_map(const char* path, const char* map_file, const char* blk_dev,
                             bool encrypted, bool f2fs_fs, int socket) {
    std::string err;
    if (!android::base::RemoveFileIfExists(map_file, &amp;err)) {
        LOG(ERROR) &lt;&lt; &#34;failed to remove the existing map file &#34; &lt;&lt; map_file &lt;&lt; &#34;: &#34; &lt;&lt; err;
        return kUncryptFileRemoveError;
    }
    std::string tmp_map_file &#61; std::string(map_file) &#43; &#34;.tmp&#34;;
    android::base::unique_fd mapfd(open(tmp_map_file.c_str(),
                                        O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR));
    if (mapfd &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to open &#34; &lt;&lt; tmp_map_file;
        return kUncryptFileOpenError;
    }

    // Make sure we can write to the socket.
    if (!write_status_to_socket(0, socket)) {
        LOG(ERROR) &lt;&lt; &#34;failed to write to socket &#34; &lt;&lt; socket;
        return kUncryptSocketWriteError;
    }

    struct stat sb;
    if (stat(path, &amp;sb) !&#61; 0) {
        LOG(ERROR) &lt;&lt; &#34;failed to stat &#34; &lt;&lt; path;
        return kUncryptFileStatError;
    }

    LOG(INFO) &lt;&lt; &#34; block size: &#34; &lt;&lt; sb.st_blksize &lt;&lt; &#34; bytes&#34;;

    int blocks &#61; ((sb.st_size-1) / sb.st_blksize) &#43; 1;
    LOG(INFO) &lt;&lt; &#34;  file size: &#34; &lt;&lt; sb.st_size &lt;&lt; &#34; bytes, &#34; &lt;&lt; blocks &lt;&lt; &#34; blocks&#34;;

    std::vector&lt;int&gt; ranges;

    std::string s &#61; android::base::StringPrintf(&#34;%s/n%&#34; PRId64 &#34; %&#34; PRId64 &#34;/n&#34;,
                       blk_dev, static_cast&lt;int64_t&gt;(sb.st_size),
                       static_cast&lt;int64_t&gt;(sb.st_blksize));
    if (!android::base::WriteStringToFd(s, mapfd)) {
        PLOG(ERROR) &lt;&lt; &#34;failed to write &#34; &lt;&lt; tmp_map_file;
        return kUncryptWriteError;
    }

    std::vector&lt;std::vector&lt;unsigned char&gt;&gt; buffers;
    /*
     * buffers大小为5&#xff0c;static constexpr int WINDOW_SIZE &#61; 5;
     */
    if (encrypted) {
        buffers.resize(WINDOW_SIZE, std::vector&lt;unsigned char&gt;(sb.st_blksize));
    }
    int head_block &#61; 0;
    int head &#61; 0, tail &#61; 0;

    android::base::unique_fd fd(open(path, O_RDONLY));
    if (fd &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to open &#34; &lt;&lt; path &lt;&lt; &#34; for reading&#34;;
        return kUncryptFileOpenError;
    }

    android::base::unique_fd wfd;
    if (encrypted) {
        wfd.reset(open(blk_dev, O_WRONLY));
        if (wfd &#61;&#61; -1) {
            PLOG(ERROR) &lt;&lt; &#34;failed to open &#34; &lt;&lt; blk_dev &lt;&lt; &#34; for writing&#34;;
            return kUncryptBlockOpenError;
        }
    }

#ifndef F2FS_IOC_SET_DONTMOVE
#ifndef F2FS_IOCTL_MAGIC
#define F2FS_IOCTL_MAGIC		0xf5
#endif
#define F2FS_IOC_SET_DONTMOVE		_IO(F2FS_IOCTL_MAGIC, 13)
#endif
    if (f2fs_fs &amp;&amp; ioctl(fd, F2FS_IOC_SET_DONTMOVE) &lt; 0) {
        PLOG(ERROR) &lt;&lt; &#34;Failed to set non-movable file for f2fs: &#34; &lt;&lt; path &lt;&lt; &#34; on &#34; &lt;&lt; blk_dev;
        return kUncryptIoctlError;
    }

    off64_t pos &#61; 0;
    int last_progress &#61; 0;
    while (pos &lt; sb.st_size) {
        // Update the status file, progress must be between [0, 99].
        int progress &#61; static_cast&lt;int&gt;(100 * (double(pos) / double(sb.st_size)));
        if (progress &gt; last_progress) {
            last_progress &#61; progress;
            write_status_to_socket(progress, socket);
        }

        if ((tail&#43;1) % WINDOW_SIZE &#61;&#61; head) {
            // write out head buffer
            int block &#61; head_block;
            if (ioctl(fd, FIBMAP, &amp;block) !&#61; 0) {
                PLOG(ERROR) &lt;&lt; &#34;failed to find block &#34; &lt;&lt; head_block;
                return kUncryptIoctlError;
            }

            if (block &#61;&#61; 0) {
                LOG(ERROR) &lt;&lt; &#34;failed to find block &#34; &lt;&lt; head_block &lt;&lt; &#34;, retrying&#34;;
                int error &#61; retry_fibmap(fd, path, &amp;block, head_block);
                if (error !&#61; kUncryptNoError) {
                    return error;
                }
            }

            add_block_to_ranges(ranges, block);
             //data分区是否加密
            if (encrypted) {
                if (write_at_offset(buffers[head].data(), sb.st_blksize, wfd,
                                    static_cast&lt;off64_t&gt;(sb.st_blksize) * block) !&#61; 0) {
                    return kUncryptWriteError;
                }
            }
            head &#61; (head &#43; 1) % WINDOW_SIZE;
            &#43;&#43;head_block;
        }

        // read next block to tail
        // data分区加密
        if (encrypted) {
            size_t to_read &#61; static_cast&lt;size_t&gt;(
                    std::min(static_cast&lt;off64_t&gt;(sb.st_blksize), sb.st_size - pos));
            if (!android::base::ReadFully(fd, buffers[tail].data(), to_read)) {
                PLOG(ERROR) &lt;&lt; &#34;failed to read &#34; &lt;&lt; path;
                return kUncryptReadError;
            }
            pos &#43;&#61; to_read;
        } else {
            // If we&#39;re not encrypting; we don&#39;t need to actually read
            // anything, just skip pos forward as if we&#39;d read a
            // block.
            pos &#43;&#61; sb.st_blksize;
        }
        tail &#61; (tail&#43;1) % WINDOW_SIZE;
    }

    while (head !&#61; tail) {
        // write out head buffer
        int block &#61; head_block;
        if (ioctl(fd, FIBMAP, &amp;block) !&#61; 0) {
            PLOG(ERROR) &lt;&lt; &#34;failed to find block &#34; &lt;&lt; head_block;
            return kUncryptIoctlError;
        }

        if (block &#61;&#61; 0) {
            LOG(ERROR) &lt;&lt; &#34;failed to find block &#34; &lt;&lt; head_block &lt;&lt; &#34;, retrying&#34;;
            int error &#61; retry_fibmap(fd, path, &amp;block, head_block);
            if (error !&#61; kUncryptNoError) {
                return error;
            }
        }

        add_block_to_ranges(ranges, block);
        //data分区是否加密
        if (encrypted) {
            if (write_at_offset(buffers[head].data(), sb.st_blksize, wfd,
                                static_cast&lt;off64_t&gt;(sb.st_blksize) * block) !&#61; 0) {
                return kUncryptWriteError;
            }
        }
        head &#61; (head &#43; 1) % WINDOW_SIZE;
        &#43;&#43;head_block;
    }

    if (!android::base::WriteStringToFd(
            android::base::StringPrintf(&#34;%zu/n&#34;, ranges.size() / 2), mapfd)) {
        PLOG(ERROR) &lt;&lt; &#34;failed to write &#34; &lt;&lt; tmp_map_file;
        return kUncryptWriteError;
    }
    for (size_t i &#61; 0; i &lt; ranges.size(); i &#43;&#61; 2) {
        if (!android::base::WriteStringToFd(
                android::base::StringPrintf(&#34;%d %d/n&#34;, ranges[i], ranges[i&#43;1]), mapfd)) {
            PLOG(ERROR) &lt;&lt; &#34;failed to write &#34; &lt;&lt; tmp_map_file;
            return kUncryptWriteError;
        }
    }

    if (fsync(mapfd) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to fsync /&#34;&#34; &lt;&lt; tmp_map_file &lt;&lt; &#34;/&#34;&#34;;
        return kUncryptFileSyncError;
    }
    if (close(mapfd.release()) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to close &#34; &lt;&lt; tmp_map_file;
        return kUncryptFileCloseError;
    }

    if (encrypted) {
        if (fsync(wfd) &#61;&#61; -1) {
            PLOG(ERROR) &lt;&lt; &#34;failed to fsync /&#34;&#34; &lt;&lt; blk_dev &lt;&lt; &#34;/&#34;&#34;;
            return kUncryptFileSyncError;
        }
        if (close(wfd.release()) &#61;&#61; -1) {
            PLOG(ERROR) &lt;&lt; &#34;failed to close &#34; &lt;&lt; blk_dev;
            return kUncryptFileCloseError;
        }
    }

    if (rename(tmp_map_file.c_str(), map_file) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to rename &#34; &lt;&lt; tmp_map_file &lt;&lt; &#34; to &#34; &lt;&lt; map_file;
        return kUncryptFileRenameError;
    }
    // Sync dir to make rename() result written to disk.
    std::string file_name &#61; map_file;
    std::string dir_name &#61; dirname(&amp;file_name[0]);
    android::base::unique_fd dfd(open(dir_name.c_str(), O_RDONLY | O_DIRECTORY));
    if (dfd &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to open dir &#34; &lt;&lt; dir_name;
        return kUncryptFileOpenError;
    }
    if (fsync(dfd) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to fsync &#34; &lt;&lt; dir_name;
        return kUncryptFileSyncError;
    }
    if (close(dfd.release()) &#61;&#61; -1) {
        PLOG(ERROR) &lt;&lt; &#34;failed to close &#34; &lt;&lt; dir_name;
        return kUncryptFileCloseError;
    }
    return 0;
}
</code></pre> 
<p>这里将ota升级包生成block.map&#xff0c;如果升级包在的分区data是加密&#xff0c;那么每次获得每个block实际索引时&#xff0c;读取解密后的block数据到buffer&#xff0c;每当有5个block数据时&#xff0c;然后把buffer数据写入到实际的对应索引block中。</p> 
<p>执行完成uncrypt操作&#xff0c;接着2.11节&#xff0c;执行重启的操作。</p> 
<p>如果要测试uncrypt的功能&#xff0c;可以在adb shell环境下测试&#xff0c;将ota包推到data目录下&#xff0c;直接执行uncrypt命名。</p> 
<pre><code># uncrypt /data/ota.zip /cache/recovery/block.map
# cat /cache/recovery/block.map
/dev/block/bootdevice/by-name/userdata    //block device
1189005639 4096                           //文件大小&#xff0c;block块大小
2                                         //block块的个数
440320 524288                             //第一个block块的范围区间
561152 767469                             //第二个block块的范围区间
</code></pre> 
<h3><a id="220_STrebootOrShutdown_1531"></a>2.20 ST.rebootOrShutdown</h3> 
<p>接着2.11中run方法继续。</p> 
<p>[-&gt;ShutdownThread.java]</p> 
<pre><code> public static void rebootOrShutdown(final Context context, boolean reboot, String reason) {
        // 传过来reboot为true
        if (reboot) {
            Log.i(TAG, &#34;Rebooting, reason: &#34; &#43; reason);
            PowerManagerService.lowLevelReboot(reason);
            Log.e(TAG, &#34;Reboot failed, will attempt shutdown instead&#34;);
            reason &#61; null;
        } else if (SHUTDOWN_VIBRATE_MS &gt; 0 &amp;&amp; context !&#61; null) {
            // vibrate before shutting down
            Vibrator vibrator &#61; new SystemVibrator(context);
            try {
                vibrator.vibrate(SHUTDOWN_VIBRATE_MS, VIBRATION_ATTRIBUTES);
            } catch (Exception e) {
                // Failure to vibrate shouldn&#39;t interrupt shutdown.  Just log it.
                Log.w(TAG, &#34;Failed to vibrate during shutdown.&#34;, e);
            }

            // vibrator is asynchronous so we need to wait to avoid shutting down too soon.
            try {
                Thread.sleep(SHUTDOWN_VIBRATE_MS);
            } catch (InterruptedException unused) {
            }
        }
        // Shutdown power
        Log.i(TAG, &#34;Performing low-level shutdown...&#34;);
        PowerManagerService.lowLevelShutdown(reason);
    }

</code></pre> 
<h4><a id="2201_PWSlowLevelReboot_1568"></a>2.20.1 PWS.lowLevelReboot</h4> 
<p>[-&gt;PowerManagerService.java]</p> 
<pre><code> /**
     * Low-level function to reboot the device. On success, this
     * function doesn&#39;t return. If more than 20 seconds passes from
     * the time a reboot is requested, this method returns.
     *
     * &#64;param reason code to pass to the kernel (e.g. &#34;recovery&#34;), or null.
     */
    public static void lowLevelReboot(String reason) {
        if (reason &#61;&#61; null) {
            reason &#61; &#34;&#34;;
        }

        // If the reason is &#34;quiescent&#34;, it means that the boot process should proceed
        // without turning on the screen/lights.
        // The &#34;quiescent&#34; property is sticky, meaning that any number
        // of subsequent reboots should honor the property until it is reset.
        if (reason.equals(PowerManager.REBOOT_QUIESCENT)) {
            sQuiescent &#61; true;
            reason &#61; &#34;&#34;;
        } else if (reason.endsWith(&#34;,&#34; &#43; PowerManager.REBOOT_QUIESCENT)) {
            sQuiescent &#61; true;
            reason &#61; reason.substring(0,
                    reason.length() - PowerManager.REBOOT_QUIESCENT.length() - 1);
        }

        if (reason.equals(PowerManager.REBOOT_RECOVERY)
                || reason.equals(PowerManager.REBOOT_RECOVERY_UPDATE)) {
            reason &#61; &#34;recovery&#34;;
        }

        if (sQuiescent) {
            // Pass the optional &#34;quiescent&#34; argument to the bootloader to let it know
            // that it should not turn the screen/lights on.
            reason &#61; reason &#43; &#34;,quiescent&#34;;
        }
        //重启操作
        SystemProperties.set(&#34;sys.powerctl&#34;, &#34;reboot,&#34; &#43; reason);
        try {
            Thread.sleep(20 * 1000L);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        Slog.wtf(TAG, &#34;Unexpected return from lowLevelReboot!&#34;);
    }
</code></pre> 
<h4><a id="2202_PWSlowLevelReboot_1619"></a>2.20.2 PWS.lowLevelReboot</h4> 
<pre><code>  public static void lowLevelShutdown(String reason) {
        if (reason &#61;&#61; null) {
            reason &#61; &#34;&#34;;
        }
        //关机
        SystemProperties.set(&#34;sys.powerctl&#34;, &#34;shutdown,&#34; &#43; reason);
    }
</code></pre> 
<h3><a id="221__1631"></a>2.21 小结</h3> 
<p>OTA升级重启前&#xff0c;主要的操作是对升级包进行处理的过程&#xff0c;对升级包提前处理的原因是因为在进入recovery模式进行升级时无法加载升级包所在的分区。在重启前的主要操作如下&#xff1a;</p> 
<p>1.通过SystemProperties设置属性(setup-bcb)&#xff0c;向BCB中设置升级的Command&#xff1b;</p> 
<p>2.通过SystemProperties设置属性(uncrypt)&#xff0c;开启uncrypt服务&#xff0c;将升级包生成一系列的block块&#xff0c;recovery可以读取block.map文件并获取这个文件的数据作为升级包&#xff1b;</p> 
<p>3.uncrypt完成后&#xff0c;重启。</p> 
<h2><a id="OTA_1641"></a>三、OTA升级重启后</h2> 
<p>终端重启后&#xff0c;加载bootloader过程中&#xff0c;由于之前写入的recovery的command&#xff0c;则将进入recovery模式.</p> 
<h3><a id="31_abootaboot_init_1645"></a>3.1 aboot.aboot_init</h3> 
<p>[-&gt;aboot.c]</p> 
<pre><code>void aboot_init(const struct app_descriptor *app)
{
	unsigned reboot_mode &#61; 0;
	int boot_err_type &#61; 0;
	int boot_slot &#61; INVALID;

	/* Initialise wdog to catch early lk crashes */
#if WDOG_SUPPORT
	msm_wdog_init();
#endif

	/* Setup page size information for nv storage */
	if (target_is_emmc_boot())
	{
		page_size &#61; mmc_page_size();
		page_mask &#61; page_size - 1;
		mmc_blocksize &#61; mmc_get_device_blocksize();
		mmc_blocksize_mask &#61; mmc_blocksize - 1;
	}
	else
	{
		page_size &#61; flash_page_size();
		page_mask &#61; page_size - 1;
	}
	ASSERT((MEMBASE &#43; MEMSIZE) &gt; MEMBASE);

	read_device_info(&amp;device);
	read_allow_oem_unlock(&amp;device);

	/* Detect multi-slot support */
	if (partition_multislot_is_supported())
	{
		boot_slot &#61; partition_find_active_slot();
		if (boot_slot &#61;&#61; INVALID)
		{
			boot_into_fastboot &#61; true;
			dprintf(INFO, &#34;Active Slot: (INVALID)/n&#34;);
		}
		else
		{
			/* Setting the state of system to boot active slot */
			partition_mark_active_slot(boot_slot);
			dprintf(INFO, &#34;Active Slot: (%s)/n&#34;, SUFFIX_SLOT(boot_slot));
		}
	}

	/* Display splash screen if enabled */
#if DISPLAY_SPLASH_SCREEN
#if NO_ALARM_DISPLAY
	if (!check_alarm_boot()) {
#endif
		dprintf(SPEW, &#34;Display Init: Start/n&#34;);
#if DISPLAY_HDMI_PRIMARY
	if (!strlen(device.display_panel))
		strlcpy(device.display_panel, DISPLAY_PANEL_HDMI,
			sizeof(device.display_panel));
#endif
#if ENABLE_WBC
		/* Wait if the display shutdown is in progress */
		while(pm_app_display_shutdown_in_prgs());
		if (!pm_appsbl_display_init_done())
			target_display_init(device.display_panel);
		else
			display_image_on_screen();
#else
		target_display_init(device.display_panel);
#endif
		dprintf(SPEW, &#34;Display Init: Done/n&#34;);
#if NO_ALARM_DISPLAY
	}
#endif
#endif

	target_serialno((unsigned char *) sn_buf);
	dprintf(SPEW,&#34;serial number: %s/n&#34;,sn_buf);

	memset(display_panel_buf, &#39;/0&#39;, MAX_PANEL_BUF_SIZE);

	/*
	 * Check power off reason if user force reset,
	 * if yes phone will do normal boot.
	 */
	if (is_user_force_reset())
		goto normal_boot;

	/* Check if we should do something other than booting up */
	if (keys_get_state(KEY_VOLUMEUP) &amp;&amp; keys_get_state(KEY_VOLUMEDOWN))
	{
		dprintf(ALWAYS,&#34;dload mode key sequence detected/n&#34;);
		reboot_device(EMERGENCY_DLOAD);
		dprintf(CRITICAL,&#34;Failed to reboot into dload mode/n&#34;);

		boot_into_fastboot &#61; true;
	}
	if (!boot_into_fastboot)
	{
		if (keys_get_state(KEY_HOME) || keys_get_state(KEY_VOLUMEUP))
			boot_into_recovery &#61; 1;
		if (!boot_into_recovery &amp;&amp;
			(keys_get_state(KEY_BACK) || keys_get_state(KEY_VOLUMEDOWN)))
			boot_into_fastboot &#61; true;
	}
	#if NO_KEYPAD_DRIVER
	if (fastboot_trigger())
		boot_into_fastboot &#61; true;
	#endif

#if USE_PON_REBOOT_REG
	reboot_mode &#61; check_hard_reboot_mode();
#else
	reboot_mode &#61; check_reboot_mode();
#endif
	if (reboot_mode &#61;&#61; RECOVERY_MODE)
	{
		boot_into_recovery &#61; 1;
	}
	else if(reboot_mode &#61;&#61; FASTBOOT_MODE)
	{
		boot_into_fastboot &#61; true;
	}
	else if(reboot_mode &#61;&#61; ALARM_BOOT)
	{
		boot_reason_alarm &#61; true;
	}
#if VERIFIED_BOOT || VERIFIED_BOOT_2
	else if (VB_M &lt;&#61; target_get_vb_version())
	{
		if (reboot_mode &#61;&#61; DM_VERITY_ENFORCING)
		{
			device.verity_mode &#61; 1;
			write_device_info(&amp;device);
		}
#if ENABLE_VB_ATTEST
		else if (reboot_mode &#61;&#61; DM_VERITY_EIO)
#else
		else if (reboot_mode &#61;&#61; DM_VERITY_LOGGING)
#endif
		{
			device.verity_mode &#61; 0;
			write_device_info(&amp;device);
		}
		else if (reboot_mode &#61;&#61; DM_VERITY_KEYSCLEAR)
		{
			if(send_delete_keys_to_tz())
				ASSERT(0);
		}
	}
#endif

normal_boot:
	if (!boot_into_fastboot)
	{
		if (target_is_emmc_boot())
		{
			if(emmc_recovery_init())
				dprintf(ALWAYS,&#34;error in emmc_recovery_init/n&#34;);
			if(target_use_signed_kernel())
			{
				if((device.is_unlocked) || (device.is_tampered))
				{
				#ifdef TZ_TAMPER_FUSE
					set_tamper_fuse_cmd(HLOS_IMG_TAMPER_FUSE);
				#endif
				#if USE_PCOM_SECBOOT
					set_tamper_flag(device.is_tampered);
				#endif
				}
			}

retry_boot:
			/* Trying to boot active partition */
			if (partition_multislot_is_supported())
			{
				boot_slot &#61; partition_find_boot_slot();
				partition_mark_active_slot(boot_slot);
				if (boot_slot &#61;&#61; INVALID)
					goto fastboot;
			}

			boot_err_type &#61; boot_linux_from_mmc();
			switch (boot_err_type)
			{
				case ERR_INVALID_PAGE_SIZE:
				case ERR_DT_PARSE:
				case ERR_ABOOT_ADDR_OVERLAP:
				case ERR_INVALID_BOOT_MAGIC:
					if(partition_multislot_is_supported())
					{
						/*
						 * Deactivate current slot, as it failed to
						 * boot, and retry next slot.
						 */
						partition_deactivate_slot(boot_slot);
						goto retry_boot;
					}
					else
						break;
				default:
					break;
				/* going to fastboot menu */
			}
		}
		else
		{
		    //见3.2节
			recovery_init();
	#if USE_PCOM_SECBOOT
		if((device.is_unlocked) || (device.is_tampered))
			set_tamper_flag(device.is_tampered);
	#endif
			boot_linux_from_flash();
		}
		dprintf(CRITICAL, &#34;ERROR: Could not do normal boot. Reverting &#34;
			&#34;to fastboot mode./n&#34;);
	}

fastboot:
	/* We are here means regular boot did not happen. Start fastboot. */

	/* register aboot specific fastboot commands */
	aboot_fastboot_register_commands();

	/* dump partition table for debug info */
	partition_dump();

	/* initialize and start fastboot */
#if !VERIFIED_BOOT_2
	fastboot_init(target_get_scratch_address(), target_get_max_flash_size());
#else
	/* Add salt buffer offset at start of image address to copy VB salt */
	fastboot_init(ADD_SALT_BUFF_OFFSET(target_get_scratch_address()),
		SUB_SALT_BUFF_OFFSET(target_get_max_flash_size()));
#endif
#if FBCON_DISPLAY_MSG
	display_fastboot_menu();
#endif
}

</code></pre> 
<p>aboot执行后读取bootloader中command命令&#xff0c;执行recovery_init.</p> 
<h3><a id="32_recoveryrecovery_init_1892"></a>3.2 recovery.recovery_init</h3> 
<p>[-&gt;recovery.c]</p> 
<pre><code>/* Bootloader / Recovery Flow
 *
 * On every boot, the bootloader will read the recovery_message
 * from flash and check the command field.  The bootloader should
 * deal with the command field not having a 0 terminator correctly
 * (so as to not crash if the block is invalid or corrupt).
 *
 * The bootloader will have to publish the partition that contains
 * the recovery_message to the linux kernel so it can update it.
 *
 * if command &#61;&#61; &#34;boot-recovery&#34; -&gt; boot recovery.img
 * else if command &#61;&#61; &#34;update-radio&#34; -&gt; update radio image (below)
 * else -&gt; boot boot.img (normal boot)
 *
 * Radio Update Flow
 * 1. the bootloader will attempt to load and validate the header
 * 2. if the header is invalid, status&#61;&#34;invalid-update&#34;, goto #8
 * 3. display the busy image on-screen
 * 4. if the update image is invalid, status&#61;&#34;invalid-radio-image&#34;, goto #8
 * 5. attempt to update the firmware (depending on the command)
 * 6. if successful, status&#61;&#34;okay&#34;, goto #8
 * 7. if failed, and the old image can still boot, status&#61;&#34;failed-update&#34;
 * 8. write the recovery_message, leaving the recovery field
 *    unchanged, updating status, and setting command to
 *    &#34;boot-recovery&#34;
 * 9. reboot
 *
 * The bootloader will not modify or erase the cache partition.
 * It is recovery&#39;s responsibility to clean up the mess afterwards.
 */

int recovery_init (void)
{
	struct recovery_message msg;
	char partition_name[32];
	unsigned valid_command &#61; 0;
	int update_status &#61; 0;

	// get recovery message
	if (get_recovery_message(&amp;msg))
		return -1;
	msg.command[sizeof(msg.command)-1] &#61; &#39;/0&#39;; //Ensure termination
	if (msg.command[0] !&#61; 0 &amp;&amp; msg.command[0] !&#61; 255) {
		dprintf(INFO,&#34;Recovery command: %d %s/n&#34;,
			sizeof(msg.command), msg.command);
	}

	if (!strcmp(&#34;boot-recovery&#34;,msg.command))
	{
		if(!strcmp(&#34;RADIO&#34;,msg.status))
		{
			/* We&#39;re now here due to radio update, so check for update status */
			int ret &#61; get_boot_info_apps(UPDATE_STATUS, (unsigned int *) &amp;update_status);

			if(!ret &amp;&amp; (update_status &amp; 0x01))
			{
				dprintf(INFO,&#34;radio update success/n&#34;);
				strlcpy(msg.status, &#34;OKAY&#34;, sizeof(msg.status));
			}
			else
			{
				dprintf(INFO,&#34;radio update failed/n&#34;);
				strlcpy(msg.status, &#34;failed-update&#34;, sizeof(msg.status));
			}
			strlcpy(msg.command, &#34;&#34;, sizeof(msg.command));	// clearing recovery command
			set_recovery_message(&amp;msg);	// send recovery message
			boot_into_recovery &#61; 1;		// Boot in recovery mode
			return 0;
		}
		boot_into_recovery &#61; 1;		// Boot in recovery mode
		return 0;
	}

	if (!strcmp(&#34;update-radio&#34;,msg.command)) {
		dprintf(INFO,&#34;start radio update/n&#34;);
		valid_command &#61; 1;
		strlcpy(partition_name, &#34;FOTA&#34;, sizeof(partition_name));
	}

	//Todo: Add support for bootloader update too.

	if(!valid_command) {
		//We need not to do anything
		return 0; // Boot in normal mode
	}

	if (set_ssd_radio_update(partition_name)) {
		/* If writing to FOTA partition fails */
		strlcpy(msg.command, &#34;&#34;, sizeof(msg.command));
		strlcpy(msg.status, &#34;failed-update&#34;, sizeof(msg.status));
		goto SEND_RECOVERY_MSG;
	}
	else {
		/* Setting this to check the radio update status */
		strlcpy(msg.command, &#34;boot-recovery&#34;, sizeof(msg.command));
		strlcpy(msg.status, &#34;RADIO&#34;, sizeof(msg.status));
		goto SEND_RECOVERY_MSG;
	}
	strlcpy(msg.status, &#34;OKAY&#34;, sizeof(msg.status));

SEND_RECOVERY_MSG:
	set_recovery_message(&amp;msg);	// send recovery message
	boot_into_recovery &#61; 1;		// Boot in recovery mode
	reboot_device(0);
	return 0;
}
</code></pre> 
<p>参照代码前注释boot recovery.img之后&#xff0c;将会执行recovery.cpp中的main方法。</p> 
<h3><a id="33_recoverymain_2007"></a>3.3 recovery.main</h3> 
<p>[-&gt;recovery.cpp]</p> 
<pre><code>/*
 * The recovery tool communicates with the main system through /cache files.
 *   /cache/recovery/command - INPUT - command line for tool, one arg per line
 *   /cache/recovery/log - OUTPUT - combined log file from recovery run(s)
 *
 * The arguments which may be supplied in the recovery.command file:
 *   --update_package&#61;path - verify install an OTA package file
 *   --wipe_data - erase user data (and cache), then reboot
 *   --prompt_and_wipe_data - prompt the user that data is corrupt,
 *       with their consent erase user data (and cache), then reboot
 *   --wipe_cache - wipe cache (but not user data), then reboot
 *   --set_encrypted_filesystem&#61;on|off - enables / diasables encrypted fs
 *   --just_exit - do nothing; exit and reboot
 *
 * After completing, we remove /cache/recovery/command and reboot.
 * Arguments may also be supplied in the bootloader control block (BCB).
 * These important scenarios must be safely restartable at any point:
 *
 * FACTORY RESET
 * 1. user selects &#34;factory reset&#34;
 * 2. main system writes &#34;--wipe_data&#34; to /cache/recovery/command
 * 3. main system reboots into recovery
 * 4. get_args() writes BCB with &#34;boot-recovery&#34; and &#34;--wipe_data&#34;
 *    -- after this, rebooting will restart the erase --
 * 5. erase_volume() reformats /data
 * 6. erase_volume() reformats /cache
 * 7. finish_recovery() erases BCB
 *    -- after this, rebooting will restart the main system --
 * 8. main() calls reboot() to boot main system
 *
 * OTA INSTALL
 * 1. main system downloads OTA package to /cache/some-filename.zip
 * 2. main system writes &#34;--update_package&#61;/cache/some-filename.zip&#34;
 * 3. main system reboots into recovery
 * 4. get_args() writes BCB with &#34;boot-recovery&#34; and &#34;--update_package&#61;...&#34;
 *    -- after this, rebooting will attempt to reinstall the update --
 * 5. install_package() attempts to install the update
 *    NOTE: the package install must itself be restartable from any point
 * 6. finish_recovery() erases BCB
 *    -- after this, rebooting will (try to) restart the main system --
 * 7. ** if install failed **
 *    7a. prompt_and_wait() shows an error icon and waits for the user
 *    7b. the user reboots (pulling the battery, etc) into the main system
 */
 
 int main(int argc, char **argv) {
  // We don&#39;t have logcat yet under recovery; so we&#39;ll print error on screen and
  // log to stdout (which is redirected to recovery.log) as we used to do.
  android::base::InitLogging(argv, &amp;UiLogger);

  // Take last pmsg contents and rewrite it to the current pmsg session.
  static const char filter[] &#61; &#34;recovery/&#34;;
  // Do we need to rotate?
  bool doRotate &#61; false;

  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logbasename, &amp;doRotate);
  // Take action to refresh pmsg contents
  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logrotate, &amp;doRotate);

  // If this binary is started with the single argument &#34;--adbd&#34;,
  // instead of being the normal recovery binary, it turns into kind
  // of a stripped-down version of adbd that only supports the
  // &#39;sideload&#39; command.  Note this must be a real argument, not
  // anything in the command file or bootloader control block; the
  // only way recovery should be run with this argument is when it
  // starts a copy of itself from the apply_from_adb() function.
  if (argc &#61;&#61; 2 &amp;&amp; strcmp(argv[1], &#34;--adbd&#34;) &#61;&#61; 0) {
    minadbd_main();
    return 0;
  }

  time_t start &#61; time(nullptr);

  // redirect_stdio should be called only in non-sideload mode. Otherwise
  // we may have two logger instances with different timestamps.
  redirect_stdio(TEMPORARY_LOG_FILE);

  printf(&#34;Starting recovery (pid %d) on %s&#34;, getpid(), ctime(&amp;start));

  load_volume_table();
  has_cache &#61; volume_for_mount_point(CACHE_ROOT) !&#61; nullptr;

  std::vector&lt;std::string&gt; args &#61; get_args(argc, argv);
  std::vector&lt;char*&gt; args_to_parse(args.size());
  std::transform(args.cbegin(), args.cend(), args_to_parse.begin(),
                 [](const std::string&amp; arg) { return const_cast&lt;char*&gt;(arg.c_str()); });

  const char* update_package &#61; nullptr;
  bool should_wipe_data &#61; false;
  bool should_prompt_and_wipe_data &#61; false;
  bool should_wipe_cache &#61; false;
  bool should_wipe_ab &#61; false;
  size_t wipe_package_size &#61; 0;
  bool show_text &#61; false;
  bool sideload &#61; false;
  bool sideload_auto_reboot &#61; false;
  bool just_exit &#61; false;
  bool shutdown_after &#61; false;
  int retry_count &#61; 0;
  bool security_update &#61; false;
  int status &#61; INSTALL_SUCCESS;
  bool mount_required &#61; true;

  if (has_cache &amp;&amp; ensure_path_mounted(CACHE_ROOT) &#61;&#61; 0) {
  //Create /cache/recovery specifically if it is not created
  //As in cases where device is booted into recovery directly after
  //flashing recovery folder is not created in init
    mkdir_recursively(CACHE_LOG_DIR, 0777, false, sehandle);
  }

  int arg;
  int option_index;
  //解析参数
  while ((arg &#61; getopt_long(args_to_parse.size(), args_to_parse.data(), &#34;&#34;, OPTIONS,
                            &amp;option_index)) !&#61; -1) {
    switch (arg) {
      case &#39;n&#39;:
        android::base::ParseInt(optarg, &amp;retry_count, 0);
        break;
      case &#39;u&#39;:
        update_package &#61; optarg;
        break;
      case &#39;w&#39;:
        should_wipe_data &#61; true;
        break;
      case &#39;c&#39;:
        should_wipe_cache &#61; true;
        break;
      case &#39;t&#39;:
        show_text &#61; true;
        break;
      case &#39;s&#39;:
        sideload &#61; true;
        break;
      case &#39;a&#39;:
        sideload &#61; true;
        sideload_auto_reboot &#61; true;
        break;
      case &#39;x&#39;:
        just_exit &#61; true;
        break;
      case &#39;l&#39;:
        locale &#61; optarg;
        break;
      case &#39;p&#39;:
        shutdown_after &#61; true;
        break;
      case &#39;r&#39;:
        reason &#61; optarg;
        break;
      case &#39;e&#39;:
        security_update &#61; true;
        break;
      case 0: {
        std::string option &#61; OPTIONS[option_index].name;
        if (option &#61;&#61; &#34;wipe_ab&#34;) {
          should_wipe_ab &#61; true;
        } else if (option &#61;&#61; &#34;wipe_package_size&#34;) {
          android::base::ParseUint(optarg, &amp;wipe_package_size);
        } else if (option &#61;&#61; &#34;prompt_and_wipe_data&#34;) {
          should_prompt_and_wipe_data &#61; true;
        }
        break;
      }
      case &#39;?&#39;:
        LOG(ERROR) &lt;&lt; &#34;Invalid command argument&#34;;
        continue;
    }
  }

  if (locale.empty()) {
    if (has_cache) {
      locale &#61; load_locale_from_cache();
    }

    if (locale.empty()) {
      locale &#61; DEFAULT_LOCALE;
    }
  }

  printf(&#34;locale is [%s]/n&#34;, locale.c_str());
  printf(&#34;stage is [%s]/n&#34;, stage.c_str());
  printf(&#34;reason is [%s]/n&#34;, reason);

  Device* device &#61; make_device();
  if (android::base::GetBoolProperty(&#34;ro.boot.quiescent&#34;, false)) {
    printf(&#34;Quiescent recovery mode./n&#34;);
    ui &#61; new StubRecoveryUI();
  } else {
    ui &#61; device-&gt;GetUI();

    if (!ui-&gt;Init(locale)) {
      printf(&#34;Failed to initialize UI, use stub UI instead./n&#34;);
      ui &#61; new StubRecoveryUI();
    }
  }

  // Set background string to &#34;installing security update&#34; for security update,
  // otherwise set it to &#34;installing system update&#34;.
  ui-&gt;SetSystemUpdateText(security_update);

  int st_cur, st_max;
  if (!stage.empty() &amp;&amp; sscanf(stage.c_str(), &#34;%d/%d&#34;, &amp;st_cur, &amp;st_max) &#61;&#61; 2) {
    ui-&gt;SetStage(st_cur, st_max);
  }

  ui-&gt;SetBackground(RecoveryUI::NONE);
  if (show_text) ui-&gt;ShowText(true);

  sehandle &#61; selinux_android_file_context_handle();
  selinux_android_set_sehandle(sehandle);
  if (!sehandle) {
    ui-&gt;Print(&#34;Warning: No file_contexts/n&#34;);
  }

  device-&gt;StartRecovery();

  printf(&#34;Command:&#34;);
  for (const auto&amp; arg : args) {
    printf(&#34; /&#34;%s/&#34;&#34;, arg.c_str());
  }
  printf(&#34;/n/n&#34;);

   if (update_package) {
        if (!strncmp(&#34;/sdcard&#34;, update_package, 7)) {
            //If this is a UFS device lets mount the sdcard ourselves.Depending
            //on if the device is UFS or EMMC based the path to the sdcard
            //device changes so we cannot rely on the block dev path from
            //recovery.fstab file
            if (is_ufs_dev()) {
                if(do_sdcard_mount_for_ufs() !&#61; 0) {
                    status &#61; INSTALL_ERROR;
                    goto error;
                }
                mount_required &#61; false;
            } else {
                ui-&gt;Print(&#34;Update via sdcard on EMMC dev. Using path from fstab/n&#34;);
            }
        }
    }

  property_list(print_property, nullptr);
  printf(&#34;/n&#34;);

  ui-&gt;Print(&#34;Supported API: %d/n&#34;, kRecoveryApiVersion);

  if (update_package !&#61; nullptr) {
    // It&#39;s not entirely true that we will modify the flash. But we want
    // to log the update attempt since update_package is non-NULL.
    modified_flash &#61; true;

    if (!is_battery_ok()) {
      ui-&gt;Print(&#34;battery capacity is not enough for installing package, needed is %d%%/n&#34;,
                BATTERY_OK_PERCENTAGE);
      // Log the error code to last_install when installation skips due to
      // low battery.
      log_failure_code(kLowBattery, update_package);
      status &#61; INSTALL_SKIPPED;
    } else if (bootreason_in_blacklist()) {
      // Skip update-on-reboot when bootreason is kernel_panic or similar
      ui-&gt;Print(&#34;bootreason is in the blacklist; skip OTA installation/n&#34;);
      log_failure_code(kBootreasonInBlacklist, update_package);
      status &#61; INSTALL_SKIPPED;
    } else {
      // It&#39;s a fresh update. Initialize the retry_count in the BCB to 1; therefore we can later
      // identify the interrupted update due to unexpected reboots.
      if (retry_count &#61;&#61; 0) {
        set_retry_bootloader_message(retry_count &#43; 1, args);
      }

      //见3.4节&#xff0c;安装升级包
      status &#61; install_package(update_package, &amp;should_wipe_cache, TEMPORARY_INSTALL_FILE, mount_required,
                                retry_count);
      if (status &#61;&#61; INSTALL_SUCCESS &amp;&amp; should_wipe_cache) {
        wipe_cache(false, device);
      }
      if (status !&#61; INSTALL_SUCCESS) {
        ui-&gt;Print(&#34;Installation aborted./n&#34;);
        // When I/O error happens, reboot and retry installation RETRY_LIMIT
        // times before we abandon this OTA update.
        if (status &#61;&#61; INSTALL_RETRY &amp;&amp; retry_count &lt; RETRY_LIMIT) {
          copy_logs();
          retry_count &#43;&#61; 1;
          set_retry_bootloader_message(retry_count, args);
          // Print retry count on screen.
          ui-&gt;Print(&#34;Retry attempt %d/n&#34;, retry_count);

          // Reboot and retry the update
          if (!reboot(&#34;reboot,recovery&#34;)) {
            ui-&gt;Print(&#34;Reboot failed/n&#34;);
          } else {
            while (true) {
              pause();
            }
          }
        }
        // If this is an eng or userdebug build, then automatically
        // turn the text display on if the script fails so the error
        // message is visible.
        if (is_ro_debuggable()) {
          ui-&gt;ShowText(true);
        }
      }
    }
  } else if (should_wipe_data) {
    if (!wipe_data(device)) {
      status &#61; INSTALL_ERROR;
    }
  } else if (should_prompt_and_wipe_data) {
    ui-&gt;ShowText(true);
    ui-&gt;SetBackground(RecoveryUI::ERROR);
    if (!prompt_and_wipe_data(device)) {
      status &#61; INSTALL_ERROR;
    }
    ui-&gt;ShowText(false);
  } else if (should_wipe_cache) {
    if (!wipe_cache(false, device)) {
      status &#61; INSTALL_ERROR;
    }
  } else if (should_wipe_ab) {
    if (!wipe_ab_device(wipe_package_size)) {
      status &#61; INSTALL_ERROR;
    }
  } else if (sideload) {
    // &#39;adb reboot sideload&#39; acts the same as user presses key combinations
    // to enter the sideload mode. When &#39;sideload-auto-reboot&#39; is used, text
    // display will NOT be turned on by default. And it will reboot after
    // sideload finishes even if there are errors. Unless one turns on the
    // text display during the installation. This is to enable automated
    // testing.
    if (!sideload_auto_reboot) {
      ui-&gt;ShowText(true);
    }
    status &#61; apply_from_adb(&amp;should_wipe_cache, TEMPORARY_INSTALL_FILE);
    if (status &#61;&#61; INSTALL_SUCCESS &amp;&amp; should_wipe_cache) {
      if (!wipe_cache(false, device)) {
        status &#61; INSTALL_ERROR;
      }
    }
    ui-&gt;Print(&#34;/nInstall from ADB complete (status: %d)./n&#34;, status);
    if (sideload_auto_reboot) {
      ui-&gt;Print(&#34;Rebooting automatically./n&#34;);
    }
  } else if (!just_exit) {
    // If this is an eng or userdebug build, automatically turn on the text display if no command
    // is specified. Note that this should be called before setting the background to avoid
    // flickering the background image.
    if (is_ro_debuggable()) {
      ui-&gt;ShowText(true);
    }
    status &#61; INSTALL_NONE;  // No command specified
    ui-&gt;SetBackground(RecoveryUI::NO_COMMAND);
  }

error:
  if (status &#61;&#61; INSTALL_ERROR || status &#61;&#61; INSTALL_CORRUPT) {
    ui-&gt;SetBackground(RecoveryUI::ERROR);
    if (!ui-&gt;IsTextVisible()) {
      sleep(5);
    }
  }

  Device::BuiltinAction after &#61; shutdown_after ? Device::SHUTDOWN : Device::REBOOT;
  // 1. If the recovery menu is visible, prompt and wait for commands.
  // 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into
  //    recovery to sideload a package.)
  // 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device
  //    without waiting.
  // 4. In all other cases, reboot the device. Therefore, normal users will observe the device
  //    reboot after it shows the &#34;error&#34; screen for 5s.
  if ((status &#61;&#61; INSTALL_NONE &amp;&amp; !sideload_auto_reboot) || ui-&gt;IsTextVisible()) {
    Device::BuiltinAction temp &#61; prompt_and_wait(device, status);
    if (temp !&#61; Device::NO_ACTION) {
      after &#61; temp;
    }
  }

  // Save logs and clean up before rebooting or shutting down.
  // 见3.8节
  finish_recovery();

  switch (after) {
    case Device::SHUTDOWN:
      ui-&gt;Print(&#34;Shutting down.../n&#34;);
      android::base::SetProperty(ANDROID_RB_PROPERTY, &#34;shutdown,&#34;);
      break;

    case Device::REBOOT_BOOTLOADER:
      ui-&gt;Print(&#34;Rebooting to bootloader.../n&#34;);
      android::base::SetProperty(ANDROID_RB_PROPERTY, &#34;reboot,bootloader&#34;);
      break;

    default:
      ui-&gt;Print(&#34;Rebooting.../n&#34;);
      reboot(&#34;reboot,&#34;);
      break;
  }
  while (true) {
    pause();
  }
  // Should be unreachable.
  return EXIT_SUCCESS;
}

</code></pre> 
<p>获取参数后&#xff0c;根据相应的参数执行相应的操作&#xff0c;这里是执行OTA INSTALL的流程&#xff0c;install_package完成之执行finish_recovery操作&#xff0c;之后正式完成升级的操作。</p> 
<h3><a id="34_installinstall_package_2420"></a>3.4 install.install_package</h3> 
<p>[-&gt;install.cpp]</p> 
<pre><code>int install_package(const std::string&amp; path, bool* wipe_cache, const std::string&amp; install_file,
                    bool needs_mount, int retry_count) {
  CHECK(!path.empty());
  CHECK(!install_file.empty());
  CHECK(wipe_cache !&#61; nullptr);

  modified_flash &#61; true;
  auto start &#61; std::chrono::system_clock::now();

  int start_temperature &#61; GetMaxValueFromThermalZone();
  int max_temperature &#61; start_temperature;

  int result &#61; 0;
  std::vector&lt;std::string&gt; log_buffer;
  if (needs_mount &#61;&#61; true)
          result &#61; setup_install_mounts();
  if (result !&#61; 0 ) {
    LOG(ERROR) &lt;&lt; &#34;failed to set up expected mounts for install; aborting&#34;;
    result &#61; INSTALL_ERROR;
  } else {
    //见3.5节
    result &#61; really_install_package(path, wipe_cache, needs_mount, &amp;log_buffer, retry_count,
                                    &amp;max_temperature);
  }

  // Measure the time spent to apply OTA update in seconds.
  std::chrono::duration&lt;double&gt; duration &#61; std::chrono::system_clock::now() - start;
  int time_total &#61; static_cast&lt;int&gt;(duration.count());

  bool has_cache &#61; volume_for_mount_point(&#34;/cache&#34;) !&#61; nullptr;
  // Skip logging the uncrypt_status on devices without /cache.
  if (has_cache) {
    static constexpr const char* UNCRYPT_STATUS &#61; &#34;/cache/recovery/uncrypt_status&#34;;
    if (ensure_path_mounted(UNCRYPT_STATUS) !&#61; 0) {
      LOG(WARNING) &lt;&lt; &#34;Can&#39;t mount &#34; &lt;&lt; UNCRYPT_STATUS;
    } else {
      std::string uncrypt_status;
      if (!android::base::ReadFileToString(UNCRYPT_STATUS, &amp;uncrypt_status)) {
        PLOG(WARNING) &lt;&lt; &#34;failed to read uncrypt status&#34;;
      } else if (!android::base::StartsWith(uncrypt_status, &#34;uncrypt_&#34;)) {
        LOG(WARNING) &lt;&lt; &#34;corrupted uncrypt_status: &#34; &lt;&lt; uncrypt_status;
      } else {
        log_buffer.push_back(android::base::Trim(uncrypt_status));
      }
    }
  }

  // The first two lines need to be the package name and install result.
  std::vector&lt;std::string&gt; log_header &#61; {
    path,
    result &#61;&#61; INSTALL_SUCCESS ? &#34;1&#34; : &#34;0&#34;,
    &#34;time_total: &#34; &#43; std::to_string(time_total),
    &#34;retry: &#34; &#43; std::to_string(retry_count),
  };

  int end_temperature &#61; GetMaxValueFromThermalZone();
  max_temperature &#61; std::max(end_temperature, max_temperature);
  if (start_temperature &gt; 0) {
    log_buffer.push_back(&#34;temperature_start: &#34; &#43; std::to_string(start_temperature));
  }
  if (end_temperature &gt; 0) {
    log_buffer.push_back(&#34;temperature_end: &#34; &#43; std::to_string(end_temperature));
  }
  if (max_temperature &gt; 0) {
    log_buffer.push_back(&#34;temperature_max: &#34; &#43; std::to_string(max_temperature));
  }

  std::string log_content &#61;
      android::base::Join(log_header, &#34;/n&#34;) &#43; &#34;/n&#34; &#43; android::base::Join(log_buffer, &#34;/n&#34;) &#43; &#34;/n&#34;;
  if (!android::base::WriteStringToFile(log_content, install_file)) {
    PLOG(ERROR) &lt;&lt; &#34;failed to write &#34; &lt;&lt; install_file;
  }

  // Write a copy into last_log.
  LOG(INFO) &lt;&lt; log_content;

  return result;
}
</code></pre> 
<h3><a id="35_installreally_install_package_2505"></a>3.5 install.really_install_package</h3> 
<p>[-&gt;install.cpp]</p> 
<pre><code>static int really_install_package(const std::string&amp; path, bool* wipe_cache, bool needs_mount,
                                  std::vector&lt;std::string&gt;* log_buffer, int retry_count,
                                  int* max_temperature) {
  //ui显示                                
  ui-&gt;SetBackground(RecoveryUI::INSTALLING_UPDATE);
  ui-&gt;Print(&#34;Finding update package.../n&#34;);
  // Give verification half the progress bar...
  ui-&gt;SetProgressType(RecoveryUI::DETERMINATE);
  ui-&gt;ShowProgress(VERIFICATION_PROGRESS_FRACTION, VERIFICATION_PROGRESS_TIME);
  LOG(INFO) &lt;&lt; &#34;Update location: &#34; &lt;&lt; path;

  // Map the update package into memory.
  ui-&gt;Print(&#34;Opening update package.../n&#34;);

  if (needs_mount) {
    if (path[0] &#61;&#61; &#39;&#64;&#39;) {
      ensure_path_mounted(path.substr(1).c_str());
    } else {
      ensure_path_mounted(path.c_str());
    }
  }

  MemMapping map;
  if (!map.MapFile(path)) {
    LOG(ERROR) &lt;&lt; &#34;failed to map file&#34;;
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kMapFileFailure));
    return INSTALL_CORRUPT;
  }

  // Verify package.
  // 校验升级包
  if (!verify_package(map.addr, map.length)) {
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kZipVerificationFailure));
    return INSTALL_CORRUPT;
  }

  // Try to open the package.
  ZipArchiveHandle zip;
  int err &#61; OpenArchiveFromMemory(map.addr, map.length, path.c_str(), &amp;zip);
  if (err !&#61; 0) {
    LOG(ERROR) &lt;&lt; &#34;Can&#39;t open &#34; &lt;&lt; path &lt;&lt; &#34; : &#34; &lt;&lt; ErrorCodeString(err);
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kZipOpenFailure));

    CloseArchive(zip);
    return INSTALL_CORRUPT;
  }

  // Additionally verify the compatibility of the package.
  if (!verify_package_compatibility(zip)) {
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kPackageCompatibilityFailure));
    CloseArchive(zip);
    return INSTALL_CORRUPT;
  }

  // Verify and install the contents of the package.
  ui-&gt;Print(&#34;Installing update.../n&#34;);
  if (retry_count &gt; 0) {
    ui-&gt;Print(&#34;Retry attempt: %d/n&#34;, retry_count);
  }
  ui-&gt;SetEnableReboot(false);
  //见3.6节
  int result &#61; try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature);
  ui-&gt;SetEnableReboot(true);
  ui-&gt;Print(&#34;/n&#34;);

  CloseArchive(zip);
  return result;
}

</code></pre> 
<h3><a id="36_installtry_update_binary_2581"></a>3.6 install.try_update_binary</h3> 
<p>[-&gt;install.cpp]</p> 
<pre><code>static int try_update_binary(const std::string&amp; package, ZipArchiveHandle zip, bool* wipe_cache,
                             std::vector&lt;std::string&gt;* log_buffer, int retry_count,
                             int* max_temperature) {
  read_source_target_build(zip, log_buffer);

  int pipefd[2];
  pipe(pipefd);

  std::vector&lt;std::string&gt; args;
#ifdef AB_OTA_UPDATER
  //执行update_binary_command操作&#xff0c;见3.7节
  int ret &#61; update_binary_command(package, zip, &#34;/sbin/update_engine_sideload&#34;, retry_count,
                                  pipefd[1], &amp;args);
#else
  int ret &#61; update_binary_command(package, zip, &#34;/tmp/update-binary&#34;, retry_count, pipefd[1],
                                  &amp;args);
#endif
  if (ret) {
    close(pipefd[0]);
    close(pipefd[1]);
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kUpdateBinaryCommandFailure));
    return ret;
  }

  // When executing the update binary contained in the package, the
  // arguments passed are:
  //
  //   - the version number for this interface
  //
  //   - an FD to which the program can write in order to update the
  //     progress bar.  The program can write single-line commands:
  //
  //        progress &lt;frac&gt; &lt;secs&gt;
  //            fill up the next &lt;frac&gt; part of of the progress bar
  //            over &lt;secs&gt; seconds.  If &lt;secs&gt; is zero, use
  //            set_progress commands to manually control the
  //            progress of this segment of the bar.
  //
  //        set_progress &lt;frac&gt;
  //            &lt;frac&gt; should be between 0.0 and 1.0; sets the
  //            progress bar within the segment defined by the most
  //            recent progress command.
  //
  //        ui_print &lt;string&gt;
  //            display &lt;string&gt; on the screen.
  //
  //        wipe_cache
  //            a wipe of cache will be performed following a successful
  //            installation.
  //
  //        clear_display
  //            turn off the text display.
  //
  //        enable_reboot
  //            packages can explicitly request that they want the user
  //            to be able to reboot during installation (useful for
  //            debugging packages that don&#39;t exit).
  //
  //        retry_update
  //            updater encounters some issue during the update. It requests
  //            a reboot to retry the same package automatically.
  //
  //        log &lt;string&gt;
  //            updater requests logging the string (e.g. cause of the
  //            failure).
  //
  //   - the name of the package zip file.
  //
  //   - an optional argument &#34;retry&#34; if this update is a retry of a failed
  //   update attempt.
  //

  // Convert the vector to a NULL-terminated char* array suitable for execv.
  const char* chr_args[args.size() &#43; 1];
  chr_args[args.size()] &#61; nullptr;
  for (size_t i &#61; 0; i &lt; args.size(); i&#43;&#43;) {
    chr_args[i] &#61; args[i].c_str();
  }

  pid_t pid &#61; fork();

  if (pid &#61;&#61; -1) {
    close(pipefd[0]);
    close(pipefd[1]);
    PLOG(ERROR) &lt;&lt; &#34;Failed to fork update binary&#34;;
    log_buffer-&gt;push_back(android::base::StringPrintf(&#34;error: %d&#34;, kForkUpdateBinaryFailure));
    return INSTALL_ERROR;
  }

  if (pid &#61;&#61; 0) {
    umask(022);
    close(pipefd[0]);
    execv(chr_args[0], const_cast&lt;char**&gt;(chr_args));
    // Bug: 34769056
    // We shouldn&#39;t use LOG/PLOG in the forked process, since they may cause
    // the child process to hang. This deadlock results from an improperly
    // copied mutex in the ui functions.
    fprintf(stdout, &#34;E:Can&#39;t run %s (%s)/n&#34;, chr_args[0], strerror(errno));
    _exit(EXIT_FAILURE);
  }
  close(pipefd[1]);

  std::atomic&lt;bool&gt; logger_finished(false);
  std::thread temperature_logger(log_max_temperature, max_temperature, std::ref(logger_finished));

  *wipe_cache &#61; false;
  bool retry_update &#61; false;

  char buffer[1024];
  FILE* from_child &#61; fdopen(pipefd[0], &#34;r&#34;);
  while (fgets(buffer, sizeof(buffer), from_child) !&#61; nullptr) {
    std::string line(buffer);
    size_t space &#61; line.find_first_of(&#34; /n&#34;);
    std::string command(line.substr(0, space));
    if (command.empty()) continue;

    // Get rid of the leading and trailing space and/or newline.
    std::string args &#61; space &#61;&#61; std::string::npos ? &#34;&#34; : android::base::Trim(line.substr(space));

    if (command &#61;&#61; &#34;progress&#34;) {
      std::vector&lt;std::string&gt; tokens &#61; android::base::Split(args, &#34; &#34;);
      double fraction;
      int seconds;
      if (tokens.size() &#61;&#61; 2 &amp;&amp; android::base::ParseDouble(tokens[0].c_str(), &amp;fraction) &amp;&amp;
          android::base::ParseInt(tokens[1], &amp;seconds)) {
        ui-&gt;ShowProgress(fraction * (1 - VERIFICATION_PROGRESS_FRACTION), seconds);
      } else {
        LOG(ERROR) &lt;&lt; &#34;invalid /&#34;progress/&#34; parameters: &#34; &lt;&lt; line;
      }
    } else if (command &#61;&#61; &#34;set_progress&#34;) {
      std::vector&lt;std::string&gt; tokens &#61; android::base::Split(args, &#34; &#34;);
      double fraction;
      if (tokens.size() &#61;&#61; 1 &amp;&amp; android::base::ParseDouble(tokens[0].c_str(), &amp;fraction)) {
        ui-&gt;SetProgress(fraction);
      } else {
        LOG(ERROR) &lt;&lt; &#34;invalid /&#34;set_progress/&#34; parameters: &#34; &lt;&lt; line;
      }
    } else if (command &#61;&#61; &#34;ui_print&#34;) {
      ui-&gt;PrintOnScreenOnly(&#34;%s/n&#34;, args.c_str());
      fflush(stdout);
    } else if (command &#61;&#61; &#34;wipe_cache&#34;) {
      *wipe_cache &#61; true;
    } else if (command &#61;&#61; &#34;clear_display&#34;) {
      ui-&gt;SetBackground(RecoveryUI::NONE);
    } else if (command &#61;&#61; &#34;enable_reboot&#34;) {
      // packages can explicitly request that they want the user
      // to be able to reboot during installation (useful for
      // debugging packages that don&#39;t exit).
      ui-&gt;SetEnableReboot(true);
    } else if (command &#61;&#61; &#34;retry_update&#34;) {
      retry_update &#61; true;
    } else if (command &#61;&#61; &#34;log&#34;) {
      if (!args.empty()) {
        // Save the logging request from updater and write to last_install later.
        log_buffer-&gt;push_back(args);
      } else {
        LOG(ERROR) &lt;&lt; &#34;invalid /&#34;log/&#34; parameters: &#34; &lt;&lt; line;
      }
    } else {
      LOG(ERROR) &lt;&lt; &#34;unknown command [&#34; &lt;&lt; command &lt;&lt; &#34;]&#34;;
    }
  }
  fclose(from_child);

  int status;
  waitpid(pid, &amp;status, 0);

  logger_finished.store(true);
  finish_log_temperature.notify_one();
  temperature_logger.join();

  if (retry_update) {
    return INSTALL_RETRY;
  }
  if (!WIFEXITED(status) || WEXITSTATUS(status) !&#61; 0) {
    LOG(ERROR) &lt;&lt; &#34;Error in &#34; &lt;&lt; package &lt;&lt; &#34; (Status &#34; &lt;&lt; WEXITSTATUS(status) &lt;&lt; &#34;)&#34;;
    return INSTALL_ERROR;
  }

  return INSTALL_SUCCESS;
}
</code></pre> 
<h3><a id="37_installupdate_binary_command_2769"></a>3.7 install.update_binary_command</h3> 
<p>[-&gt;install.cpp]</p> 
<pre><code>int update_binary_command(const std::string&amp; package, ZipArchiveHandle zip,
                          const std::string&amp; binary_path, int retry_count, int status_fd,
                          std::vector&lt;std::string&gt;* cmd) {
  CHECK(cmd !&#61; nullptr);

  // On traditional updates we extract the update binary from the package.
  static constexpr const char* UPDATE_BINARY_NAME &#61; &#34;META-INF/com/google/android/update-binary&#34;;
  ZipString binary_name(UPDATE_BINARY_NAME);
  ZipEntry binary_entry;
  if (FindEntry(zip, binary_name, &amp;binary_entry) !&#61; 0) {
    LOG(ERROR) &lt;&lt; &#34;Failed to find update binary &#34; &lt;&lt; UPDATE_BINARY_NAME;
    return INSTALL_CORRUPT;
  }

  unlink(binary_path.c_str());
  int fd &#61; open(binary_path.c_str(), O_CREAT | O_WRONLY | O_TRUNC | O_CLOEXEC, 0755);
  if (fd &#61;&#61; -1) {
    PLOG(ERROR) &lt;&lt; &#34;Failed to create &#34; &lt;&lt; binary_path;
    return INSTALL_ERROR;
  }

  int32_t error &#61; ExtractEntryToFile(zip, &amp;binary_entry, fd);
  close(fd);
  if (error !&#61; 0) {
    LOG(ERROR) &lt;&lt; &#34;Failed to extract &#34; &lt;&lt; UPDATE_BINARY_NAME &lt;&lt; &#34;: &#34; &lt;&lt; ErrorCodeString(error);
    return INSTALL_ERROR;
  }

  *cmd &#61; {
    binary_path,
    std::to_string(kRecoveryApiVersion),
    std::to_string(status_fd),
    package,
  };
  if (retry_count &gt; 0) {
    cmd-&gt;push_back(&#34;retry&#34;);
  }
  return 0;
}
</code></pre> 
<p>前面介绍到update-binary相当于一个脚本解释器&#xff0c;能够识别updater-script中描述的操作。来看下updater-script中的内容&#xff1a;</p> 
<pre><code>...
show_progress(0.650000, 0);
ui_print(&#34;Patching system image unconditionally...&#34;);
block_image_update(&#34;/dev/block/bootdevice/by-name/system&#34;, package_extract_file(&#34;system.transfer.list&#34;), &#34;system.new.dat.br&#34;, &#34;system.patch.dat&#34;) ||
  abort(&#34;E1001: Failed to update system image.&#34;);
show_progress(0.100000, 0);
ui_print(&#34;Patching vendor image unconditionally...&#34;);
block_image_update(&#34;/dev/block/bootdevice/by-name/vendor&#34;, package_extract_file(&#34;vendor.transfer.list&#34;), &#34;vendor.new.dat.br&#34;, &#34;vendor.patch.dat&#34;) ||
  abort(&#34;E2001: Failed to update vendor image.&#34;);
show_progress(0.050000, 5);
package_extract_file(&#34;boot.img&#34;, &#34;/dev/block/bootdevice/by-name/boot&#34;);
show_progress(0.200000, 10);
...
</code></pre> 
<p>调用的是block_image_update&#xff0c;传入的是升级包里面的system.transfer.list和system.new.dat.br来实现升级。</p> 
<p>block_image_update在bootable/recovery/updater/blockimg.cpp中&#xff0c;具体的实现PerformBlockImageUpdate函数中&#xff0c;这里不再详细展开。</p> 
<pre><code>void RegisterBlockImageFunctions() {
  RegisterFunction(&#34;block_image_verify&#34;, BlockImageVerifyFn);
  RegisterFunction(&#34;block_image_update&#34;, BlockImageUpdateFn);
  RegisterFunction(&#34;block_image_recover&#34;, BlockImageRecoverFn);
  RegisterFunction(&#34;check_first_block&#34;, CheckFirstBlockFn);
  RegisterFunction(&#34;range_sha1&#34;, RangeSha1Fn);
}
</code></pre> 
<p>来system.transfer.list中的内容&#xff1a;</p> 
<pre><code>4
583603
0
0
erase 6,1020,7774,524808,527824,580432,773491
new 6,0,207,222,508,8286,8817
new 2,8817,9841
new 2,9841,10865
...
zero 6,524360,524808,527824,528336,579920,579984
zero 6,579984,580432,773491,774003,786268,786332
zero 2,786332,786431
</code></pre> 
<p>其中</p> 
<p>4&#xff1a;为transfer的版本&#xff0c;目前支持1-4版本</p> 
<p>583603&#xff1a;为总共new的block数量</p> 
<p>0&#xff1a;stash slots没有使用&#xff0c;所以这里两个都是0</p> 
<p>erase&#xff1a;需要擦除的block块范围数</p> 
<p>new: 需要写入的block块范围数</p> 
<p>zero: 需要填充0的block块范围数</p> 
<h3><a id="38_recoveryfinish_recovery_2878"></a>3.8 recovery.finish_recovery</h3> 
<p>[-&gt;recovery.cpp]</p> 
<pre><code>static void finish_recovery() {
  // Save the locale to cache, so if recovery is next started up without a &#39;--locale&#39; argument
  // (e.g., directly from the bootloader) it will use the last-known locale.
  if (!locale.empty() &amp;&amp; has_cache) {
    LOG(INFO) &lt;&lt; &#34;Saving locale /&#34;&#34; &lt;&lt; locale &lt;&lt; &#34;/&#34;&#34;;
    if (ensure_path_mounted(LOCALE_FILE) !&#61; 0) {
      LOG(ERROR) &lt;&lt; &#34;Failed to mount &#34; &lt;&lt; LOCALE_FILE;
    } else if (!android::base::WriteStringToFile(locale, LOCALE_FILE)) {
      PLOG(ERROR) &lt;&lt; &#34;Failed to save locale to &#34; &lt;&lt; LOCALE_FILE;
    }
  }

  copy_logs();

  // Reset to normal system boot so recovery won&#39;t cycle indefinitely.
  std::string err;
  if (!clear_bootloader_message(&amp;err)) {
    LOG(ERROR) &lt;&lt; &#34;Failed to clear BCB message: &#34; &lt;&lt; err;
  }

  // Remove the command file, so recovery won&#39;t repeat indefinitely.
  if (has_cache) {
    if (ensure_path_mounted(COMMAND_FILE) !&#61; 0 || (unlink(COMMAND_FILE) &amp;&amp; errno !&#61; ENOENT)) {
      LOG(WARNING) &lt;&lt; &#34;Can&#39;t unlink &#34; &lt;&lt; COMMAND_FILE;
    }
    ensure_path_unmounted(CACHE_ROOT);
  }

  sync();  // For good measure.
}
</code></pre> 
<p>完成升级后&#xff0c;清除BCB操作。</p> 
<h3><a id="39__2917"></a>3.9 小结</h3> 
<p>ota升级重启后&#xff0c;主要的操作如下:</p> 
<p>1.加载bootloader&#xff0c;读取bootloader中的command命令</p> 
<p>2.读取到升级的命令后&#xff0c;boot recovery.img&#xff0c;recovery.cpp中的main函数执行。</p> 
<p>3.执行install_package操作&#xff0c;这里会解析ota包中的内容&#xff08;block.map的形式&#xff09;&#xff0c;执行相应的升级包中脚本操作&#xff0c;同时会同步进行一些ui的显示操作。</p> 
<p>4.install_package操作完成后&#xff0c;最后finish_recovery&#xff0c;完成升级的操作。</p> 
<h2><a id="_2929"></a>四、总结</h2> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Dk2eqWs-1577705272566)(https://skytoby.github.io/2019/Android%20OTA%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/OTA.jpg)]<br /> 本文分析Android终端ota升级的全过程。从介绍ota升级包的格式和系统启动模式开始作为基础&#xff0c;后面详细分析了从升级重启前到重启后的详细流程&#xff0c;其中升级重启前的流程如下&#xff1a;</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zInb41pn-1577704943833)(/Android OTA升级流程分析/OTA.jpg)]</p> 
<p>OTA升级重启前&#xff0c;主要的操作是对升级包进行处理的过程&#xff0c;对升级包提前处理的原因是因为在进入recovery模式进行升级时无法加载升级包所在的分区。在重启前的主要操作如下&#xff1a;</p> 
<p>1.通过SystemProperties设置属性(setup-bcb)&#xff0c;向BCB中设置升级的Command&#xff1b;</p> 
<p>2.通过SystemProperties设置属性(uncrypt)&#xff0c;开启uncrypt服务&#xff0c;将升级包生成一系列的block块&#xff0c;recovery可以读取block.map文件并获取这个文件的数据作为升级包&#xff1b;</p> 
<p>3.uncrypt完成后&#xff0c;重启。</p> 
<p>ota升级重启后&#xff0c;主要的操作如下:</p> 
<p>1.加载bootloader&#xff0c;读取bootloader中的command命令</p> 
<p>2.读取到升级的命令后&#xff0c;boot recovery.img&#xff0c;recovery.cpp中的main函数执行。</p> 
<p>3.执行install_package操作&#xff0c;这里会解析ota包中的内容&#xff08;block.map的形式&#xff09;&#xff0c;执行相应的升级包中脚本操作&#xff0c;同时会同步进行一些ui的显示操作。</p> 
<p>4.install_package操作完成后&#xff0c;最后finish_recovery&#xff0c;完成升级的操作。</p> 
<h2><a id="_2953"></a>附录</h2> 
<p>源码路径</p> 
<pre><code>frameworks/base/core/java/android/os/RecoverySystem.java
frameworks/base/services/core/java/com/android/server/RecoverySystemService.java
frameworks/base/core/java/android/os/PowerManager.java
frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java
frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java

bootable/recovery/uncrypt/uncrypt.cpp
bootable/recovery/uncrypt/uncrypt.rc
bootable/bootloader/lk/app/aboot/aboot.c
bootable/bootloader/lk/app/aboot/recovery.c
bootable/recovery/updater/install.cpp
bootable/recovery/install.cpp
bootable/recovery/bootloader_message/include/bootloader_message/bootloader_message.h
bootable/recovery/updater/blockimg.cpp

</code></pre>