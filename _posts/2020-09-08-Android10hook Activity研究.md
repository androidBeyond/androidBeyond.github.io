---
layout:     post
title:      Android10 hook Activity研究
subtitle:   在插件化中，hook Activity作为最基本的技术，用来在宿主app中新增Activity
date:       2020-09-08
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - 系统架构
    - Android
    - Android10
    - framework
---
<p>在插件化中，hook Activity作为最基本的技术，用来在宿主app中新增Activity，而通常情况下，Activity必须在Manifest中注册在才可以使用，下面将就Android10.0来分析hook Activity的详细过程。</p>
<p>要hook Activity之前，必须知道Activity的启动过程，才能够选择合适的点进行hook，在前面的文章中有分析<a href="https://skytoby.github.io/2019/startActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Activity详细的启动过程</a>，hook主要是两个点：一是在Activity给AMS之前替换代理的Activity，二是在handler中发送启动Activity时替换为插件的Activity。</p>
<p>分析完了Activity的hook点之后，还有一个重要的问题，如何加载插件的类和资源，只有加载了插件中的类和资源，后面的hook才有意义。</p>
<h3 id="一、类加载"><a href="#一、类加载" class="headerlink" title="一、类加载"></a>一、类加载</h3><p>在Android中，将代码编译后会生成apk文件，apk文件里面有一个或多个classes.dex文件，它是所有class文件进行合并，优化后生成。在apk运行时ART虚拟机或Dalvik虚拟机会加载dex文件，加载都是通过ClassLoader实现。</p>
<p>ClassLoader是一个抽象类，实现分为系统类加载器和自定义类加载器。</p>
<p>系统类加载器有三种：</p>
<p>BootClassLoader：用于加载Android Framework中class文件。</p>
<p>PathClassLoader：用于Android应用程序类加载器，可以加载指定的dex，以及jar、zip、apk中的dex。</p>
<p>DexClassLoader：用于加载指定的dex，以及jar、zip、apk中的dex。</p>
<h4 id="1-1-PathClassLoader"><a href="#1-1-PathClassLoader" class="headerlink" title="1.1 PathClassLoader"></a>1.1 PathClassLoader</h4><p>[-&gt;libcore\dalvik\src\main\java\dalvik\system\PathClassLoader.java]</p>
<pre><code>123456789101112131415161718192021222324252627282930313233343536373839404142public class PathClassLoader extends BaseDexClassLoader &#123;   /**    * Creates a &#123;@code PathClassLoader&#125; that operates on a given list of files    * and directories. This method is equivalent to calling    * &#123;@link #PathClassLoader(String, String, ClassLoader)&#125; with a    * &#123;@code null&#125; value for the second argument (see description there).    *    * @param dexPath the list of jar/apk files containing classes and    * resources, delimited by &#123;@code File.pathSeparator&#125;, which    * defaults to &#123;@code &quot;:&quot;&#125; on Android    * @param parent the parent class loader    */   public PathClassLoader(String dexPath, ClassLoader parent) &#123;       super(dexPath, null, null, parent);   &#125;   /**    * Creates a &#123;@code PathClassLoader&#125; that operates on two given    * lists of files and directories. The entries of the first list    * should be one of the following:    *    * &lt;ul&gt;    * &lt;li&gt;JAR/ZIP/APK files, possibly containing a &quot;classes.dex&quot; file as    * well as arbitrary resources.    * &lt;li&gt;Raw &quot;.dex&quot; files (not inside a zip file).    * &lt;/ul&gt;    *    * The entries of the second list should be directories containing    * native library files.    *    * @param dexPath the list of jar/apk files containing classes and    * resources, delimited by &#123;@code File.pathSeparator&#125;, which    * defaults to &#123;@code &quot;:&quot;&#125; on Android    * @param librarySearchPath the list of directories containing native    * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be    * &#123;@code null&#125;    * @param parent the parent class loader    */   public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;       super(dexPath, null, librarySearchPath, parent);   &#125;&#125;</code></pre> 
<p>BaseDexClassLoader</p>
<p>[-&gt;libcore\dalvik\src\main\java\dalvik\system\BaseDexClassLoader.java]</p>
<pre><code>123456789101112131415161718public class BaseDexClassLoader extends ClassLoader &#123;   /**    * Hook for customizing how dex files loads are reported.    *    * This enables the framework to monitor the use of dex files. The    * goal is to simplify the mechanism for optimizing foreign dex files and    * enable further optimizations of secondary dex files.    *    * The reporting happens only when new instances of BaseDexClassLoader    * are constructed and will be active only after this field is set with    * &#123;@link BaseDexClassLoader#setReporter&#125;.    */   /* @NonNull */ private static volatile Reporter reporter = null;   private final DexPathList pathList;   .....&#125;</code></pre> 
<h4 id="1-2-DexClassLoader"><a href="#1-2-DexClassLoader" class="headerlink" title="1.2 DexClassLoader"></a>1.2 DexClassLoader</h4><p>[-&gt;libcore\dalvik\src\main\java\dalvik\system\DexClassLoader.java]</p>
<pre><code>1234567891011121314151617181920212223public class DexClassLoader extends BaseDexClassLoader &#123;   /**    * Creates a &#123;@code DexClassLoader&#125; that finds interpreted and native    * code.  Interpreted classes are found in a set of DEX files contained    * in Jar or APK files.    *    * &lt;p&gt;The path lists are separated using the character specified by the    * &#123;@code path.separator&#125; system property, which defaults to &#123;@code :&#125;.    *    * @param dexPath the list of jar/apk files containing classes and    *     resources, delimited by &#123;@code File.pathSeparator&#125;, which    *     defaults to &#123;@code &quot;:&quot;&#125; on Android    * @param optimizedDirectory this parameter is deprecated and has no effect since API level 26.    * @param librarySearchPath the list of directories containing native    *     libraries, delimited by &#123;@code File.pathSeparator&#125;; may be    *     &#123;@code null&#125;    * @param parent the parent class loader    */   public DexClassLoader(String dexPath, String optimizedDirectory,           String librarySearchPath, ClassLoader parent) &#123;       super(dexPath, null, librarySearchPath, parent);   &#125;&#125;</code></pre> 
<p>PathClassLoader和DexClassLoader两者都是继承于BaseDexClassLoader，并且类中只有构成方法，实现全部在BaseDexClassLoader中。从源码中可以看出DexClassLoader多个一个optimizedDirectory参数，但是实际上没什么用处，这两者最后调用的super方法一模一样。</p>
<p><img src="/2020/Android10.0如何hook Activity/classloader.PNG" alt="classloader" style="zoom: 67%;"></p>
<h4 id="1-3-加载原理"><a href="#1-3-加载原理" class="headerlink" title="1.3 加载原理"></a>1.3 加载原理</h4><p>类加载器通过loadClass方法加载apk文件中的类。</p>
<h5 id="1-3-1-ClassLoader-loadClass"><a href="#1-3-1-ClassLoader-loadClass" class="headerlink" title="1.3.1 ClassLoader.loadClass"></a>1.3.1 ClassLoader.loadClass</h5><p>[-&gt;libcore\ojluni\src\main\java\java\lang\ClassLoader.java]</p>
<pre><code>12345678910111213141516171819202122232425262728293031323334353637383940414243protected Class&lt;?&gt; loadClass(String name, boolean resolve)       throws ClassNotFoundException   &#123;           // First, check if the class has already been loaded           // 检查这个类是否已经被加载           Class&lt;?&gt; c = findLoadedClass(name);           if (c == null) &#123;               try &#123;                   if (parent != null) &#123;                       //如果parent不为空，则调用parent的loadClass进行加载                       c = parent.loadClass(name, false);                   &#125; else &#123;                       //正常情况下不会走到这里                       c = findBootstrapClassOrNull(name);                   &#125;               &#125; catch (ClassNotFoundException e) &#123;                   // ClassNotFoundException thrown if class not found                   // from the non-null parent class loader               &#125;               if (c == null) &#123;                   // If still not found, then invoke findClass in order                   // to find the class.                   //如果还是找不到，就调用findClass去查找                   c = findClass(name);               &#125;           &#125;           return c;   &#125;      private Class&lt;?&gt; findBootstrapClassOrNull(String name)&#123;       return null;   &#125;       protected final Class&lt;?&gt; findLoadedClass(String name) &#123;       ClassLoader loader;       if (this == BootClassLoader.getInstance())           loader = null;       else           loader = this;           //通过native方法实现查找       return VMClassLoader.findLoadedClass(loader, name);   &#125;</code></pre> 
<p>上面类加载的过程就是双亲委派机制。先检查类是否已经被加载，如果已经加载，直接获取并返回。如果没有被加载，parent不为空，则调用parent的loadClass进行加载，依次递归，直到找到或者加载了就返回；如果还没有找到也加载不了，则自己去加载。</p>
<p><strong>BootClassLoader是最后一个加载器</strong>，BootClassLoader重写了findClass和loadClass方法，并且在loadClass方法中不再获取parent，从而结束递归。</p>
<p>在所有parent都不能加载的情况下，DexClassLoader加载过程如下，它的父类继承了BaseDexClassLoader，并重写了findClass方法。</p>
<h5 id="1-3-2-BaseDexClassLoader-findClass"><a href="#1-3-2-BaseDexClassLoader-findClass" class="headerlink" title="1.3.2 BaseDexClassLoader.findClass"></a>1.3.2 BaseDexClassLoader.findClass</h5><p>[-&gt;libcore\dalvik\src\main\java\dalvik\system\BaseDexClassLoader.java]</p>
<pre><code>1234567891011121314151617181920212223242526272829@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;      List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();       //在pathlist中查找指定的class      Class c = pathList.findClass(name, suppressedExceptions);      if (c == null) &#123;          ClassNotFoundException cnfe = new ClassNotFoundException(                  &quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);          for (Throwable t : suppressedExceptions) &#123;              cnfe.addSuppressed(t);          &#125;          throw cnfe;      &#125;      return c;  &#125;   private final DexPathList pathList;    /**   * @hide   */  public BaseDexClassLoader(String dexPath, File optimizedDirectory,          String librarySearchPath, ClassLoader parent, boolean isTrusted) &#123;      super(parent);      this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);      if (reporter != null) &#123;          reportClassLoaderChain();      &#125;  &#125;</code></pre> 
<h5 id="1-3-3-DexPathList-findClass"><a href="#1-3-3-DexPathList-findClass" class="headerlink" title="1.3.3 DexPathList.findClass"></a>1.3.3 DexPathList.findClass</h5><p>[-&gt;\libcore\dalvik\src\main\java\dalvik\system\DexPathList.java]</p>
<pre><code>123456789101112131415161718192021/**  * List of dex/resource (class path) elements.  * Should be called pathElements, but the Facebook app uses reflection  * to modify &apos;dexElements&apos; (http://b/7726934).  */private Element[] dexElements;public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;     for (Element element : dexElements) &#123;        //通过element获取class对象         Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);         if (clazz != null) &#123;             return clazz;         &#125;     &#125;     if (dexElementsSuppressedExceptions != null) &#123;         suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));     &#125;     return null; &#125;</code></pre> 
<p>dexElements初始化在构造函数中完成</p>
<pre><code>12345678DexPathList(ClassLoader definingContext, String dexPath,          String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;      ...      this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                                         suppressedExceptions, definingContext, isTrusted);       ...  &#125;</code></pre> 
<p>生成Element数组，每一个dex对应一个Element</p>
<pre><code>1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,          List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) &#123;    Element[] elements = new Element[files.size()];    int elementsPos = 0;    /*     * Open all files and load the (direct or contained) dex files up front.     */    for (File file : files) &#123;        if (file.isDirectory()) &#123;            // We support directories for looking up resources. Looking up resources in            // directories is useful for running libcore tests.            elements[elementsPos++] = new Element(file);        &#125; else if (file.isFile()) &#123;            String name = file.getName();            DexFile dex = null;            if (name.endsWith(DEX_SUFFIX)) &#123;                // Raw dex file (not inside a zip/jar).                try &#123;                    dex = loadDexFile(file, optimizedDirectory, loader, elements);                    if (dex != null) &#123;                        elements[elementsPos++] = new Element(dex, null);                    &#125;                &#125; catch (IOException suppressed) &#123;                    System.logE(&quot;Unable to load dex file: &quot; + file, suppressed);                    suppressedExceptions.add(suppressed);                &#125;            &#125; else &#123;                try &#123;                    dex = loadDexFile(file, optimizedDirectory, loader, elements);                &#125; catch (IOException suppressed) &#123;                    /*                     * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if                     * the zip file turns out to be resource-only (that is, no classes.dex file                     * in it).                     * Let dex == null and hang on to the exception to add to the tea-leaves for                     * when findClass returns null.                     */                    suppressedExceptions.add(suppressed);                &#125;                if (dex == null) &#123;                    elements[elementsPos++] = new Element(file);                &#125; else &#123;                    elements[elementsPos++] = new Element(dex, file);                &#125;            &#125;            if (dex != null &amp;&amp; isTrusted) &#123;              dex.setTrusted();            &#125;        &#125; else &#123;            System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);        &#125;    &#125;    if (elementsPos != elements.length) &#123;        elements = Arrays.copyOf(elements, elementsPos);    &#125;    return elements;  &#125;</code></pre> 
<p>Class对象从Element中获取，每一个Element对应一个dex文件。通过上面的分析，可以想到插件apk的加载方法，通过DexClassLoader加载器加载插件apk，再通过反射的方法获取到宿主的dexElements，最后将插件dexElements和宿主的dexElements合并并赋值给dexElements，其详细流程如下：</p>
<p>1.创建插件的DexClassLoader类加载器，通过反射获取插件中的dexElements</p>
<p>2.获取宿主的PathClassLoader类加载器，通过反射获取宿主的dexElements</p>
<p>3.合并插件和宿主的dexElements，生成新的Element[]</p>
<p>4.最后通过反射将新的Element[]赋值给宿主的dexElements</p>
<pre><code>12345678910111213141516171819202122232425262728293031323334//获取BaseDexClassLoader类的classClass&lt;?&gt; clazz = Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;);//获取BaseDexClassLoader类成员变量pathListField pathListField = clazz.getDeclaredField(&quot;pathList&quot;);pathListField.setAccessible(true);//获取宿主PathClassLoaderPathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();//获取宿主pathlist值Object hostPathList = pathListField.get(pathClassLoader);//获取宿主的dexElementsClass&lt;?&gt; hostPathListClass = hostPathList.getClass();Field hostDexElementsField = hostPathListClass.getDeclaredField(&quot;dexElements&quot;);hostDexElementsField.setAccessible(true);Object[] hostDexElements = (Object[]) hostDexElementsField.get(hostPathList);//获取插件pathlist值DexClassLoader dexClassLoader = new DexClassLoader(apkPath,context.getCacheDir().getAbsolutePath(),null,pathClassLoader);Object pluginPathList = pathListField.get(dexClassLoader);//获取插件的dexElementsClass&lt;?&gt; pluginPathListClass = pluginPathList.getClass();Field pluginDexElementsField = pluginPathListClass.getDeclaredField(&quot;dexElements&quot;);pluginDexElementsField.setAccessible(true);Object[] pluginDexElements = (Object[]) pluginDexElementsField.get(pluginPathList);//创建新的Element数组Object[] newDexElements = (Object[]) Array.newInstance(hostDexElements.getClass().getComponentType(),hostDexElements.length+pluginDexElements.length);System.arraycopy(hostDexElements,0,newDexElements,0,hostDexElements.length);System.arraycopy(pluginDexElements,0,newDexElements,hostDexElements.length,pluginDexElements.length);//将新的Element[]赋值给dexElementshostDexElementsField.set(hostPathList,newDexElements);</code></pre> 
<p>这样就完成了插件apk中类的加载，热修复也用到了这样的类加载的原理，不同的是将插件的Elements放在了最前面。</p>
<h3 id="二、资源加载"><a href="#二、资源加载" class="headerlink" title="二、资源加载"></a>二、资源加载</h3><p>要加载插件中的资源，可以通过AssetManager来实现，因为资源的加载实际上是通过AssetManager来加载的。AssetManager可以通过文件名访问那些被编译过的应用程序的资源文件也可以访问没有被编译过的应用程序资源文件。</p>
<p>下面分析下AssetManager如何加载资源的，获取资源是通过getResources方法：</p>
<p>在ActivityThread中attach 方法里面的createAppContext创建Context时会设置Resources。</p>
<h4 id="2-1-CL-createAppContext"><a href="#2-1-CL-createAppContext" class="headerlink" title="2.1 CL.createAppContext"></a>2.1 CL.createAppContext</h4><p>  [-&gt;base\core\java\android\app\ContextImpl.java]</p>
<pre><code>1234567static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;     if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);     ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,             null);     context.setResources(packageInfo.getResources());     return context; &#125;</code></pre> 
<h4 id="2-2-LoadedApk-getResources"><a href="#2-2-LoadedApk-getResources" class="headerlink" title="2.2 LoadedApk.getResources"></a>2.2 LoadedApk.getResources</h4><p>[-&gt;base\core\java\android\app\LoadedApk.java]</p>
<pre><code>1234567891011121314151617public Resources getResources() &#123;    if (mResources == null) &#123;        final String[] splitPaths;        try &#123;            splitPaths = getSplitPaths(null);        &#125; catch (NameNotFoundException e) &#123;            // This should never fail.            throw new AssertionError(&quot;null split not found&quot;);        &#125;       //获取ResourceManager对象，调用getResources获取mResources        mResources = ResourcesManager.getInstance().getResources(null, mResDir,                splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,                Display.DEFAULT_DISPLAY, null, getCompatibilityInfo(),                getClassLoader());    &#125;    return mResources;&#125;</code></pre> 
<h4 id="2-3-RM-getResources"><a href="#2-3-RM-getResources" class="headerlink" title="2.3 RM.getResources"></a>2.3 RM.getResources</h4><p>[-&gt;base\core\java\android\app\ResourcesManager.java]</p>
<pre><code>12345678910111213141516171819202122232425public @Nullable Resources getResources(@Nullable IBinder activityToken,         @Nullable String resDir,         @Nullable String[] splitResDirs,         @Nullable String[] overlayDirs,         @Nullable String[] libDirs,         int displayId,         @Nullable Configuration overrideConfig,         @NonNull CompatibilityInfo compatInfo,         @Nullable ClassLoader classLoader) &#123;     try &#123;         Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, &quot;ResourcesManager#getResources&quot;);         final ResourcesKey key = new ResourcesKey(                 resDir,                 splitResDirs,                 overlayDirs,                 libDirs,                 displayId,                 overrideConfig != null ? new Configuration(overrideConfig) : null, // Copy                 compatInfo);         classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();         return getOrCreateResources(activityToken, key, classLoader);     &#125; finally &#123;         Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);     &#125; &#125;</code></pre> 
<h4 id="2-4-RM-getOrCreateResources"><a href="#2-4-RM-getOrCreateResources" class="headerlink" title="2.4 RM.getOrCreateResources"></a>2.4 RM.getOrCreateResources</h4><p>[-&gt;base\core\java\android\app\ResourcesManager.java]</p>
<pre><code>123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private @Nullable Resources getOrCreateResources(@Nullable IBinder activityToken,          @NonNull ResourcesKey key, @NonNull ClassLoader classLoader) &#123;      synchronized (this) &#123;          if (DEBUG) &#123;              Throwable here = new Throwable();              here.fillInStackTrace();              Slog.w(TAG, &quot;!! Get resources for activity=&quot; + activityToken + &quot; key=&quot; + key, here);          &#125;          if (activityToken != null) &#123;              final ActivityResources activityResources =                      getOrCreateActivityResourcesStructLocked(activityToken);              // Clean up any dead references so they don&apos;t pile up.              ArrayUtils.unstableRemoveIf(activityResources.activityResources,                      sEmptyReferencePredicate);              // Rebase the key&apos;s override config on top of the Activity&apos;s base override.              if (key.hasOverrideConfiguration()                      &amp;&amp; !activityResources.overrideConfig.equals(Configuration.EMPTY)) &#123;                  final Configuration temp = new Configuration(activityResources.overrideConfig);                  temp.updateFrom(key.mOverrideConfiguration);                  key.mOverrideConfiguration.setTo(temp);              &#125;              ResourcesImpl resourcesImpl = findResourcesImplForKeyLocked(key);              if (resourcesImpl != null) &#123;                  if (DEBUG) &#123;                      Slog.d(TAG, &quot;- using existing impl=&quot; + resourcesImpl);                  &#125;                  return getOrCreateResourcesForActivityLocked(activityToken, classLoader,                          resourcesImpl, key.mCompatInfo);              &#125;              // We will create the ResourcesImpl object outside of holding this lock.          &#125; else &#123;              // Clean up any dead references so they don&apos;t pile up.              ArrayUtils.unstableRemoveIf(mResourceReferences, sEmptyReferencePredicate);              // Not tied to an Activity, find a shared Resources that has the right ResourcesImpl              ResourcesImpl resourcesImpl = findResourcesImplForKeyLocked(key);              if (resourcesImpl != null) &#123;                  if (DEBUG) &#123;                      Slog.d(TAG, &quot;- using existing impl=&quot; + resourcesImpl);                  &#125;                  return getOrCreateResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);              &#125;              // We will create the ResourcesImpl object outside of holding this lock.          &#125;          // If we&apos;re here, we didn&apos;t find a suitable ResourcesImpl to use, so create one now.          //创建ResourcesImpl对象          ResourcesImpl resourcesImpl = createResourcesImpl(key);          if (resourcesImpl == null) &#123;              return null;          &#125;          // Add this ResourcesImpl to the cache.          mResourceImpls.put(key, new WeakReference&lt;&gt;(resourcesImpl));          final Resources resources;          if (activityToken != null) &#123;              resources = getOrCreateResourcesForActivityLocked(activityToken, classLoader,                      resourcesImpl, key.mCompatInfo);          &#125; else &#123;              resources = getOrCreateResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);          &#125;          return resources;      &#125;  &#125;</code></pre> 
<h4 id="2-5-RM-createResourcesImpl"><a href="#2-5-RM-createResourcesImpl" class="headerlink" title="2.5 RM.createResourcesImpl"></a>2.5 RM.createResourcesImpl</h4><p>[-&gt;base\core\java\android\app\ResourcesManager.java]</p>
<pre><code>12345678910111213141516171819private @Nullable ResourcesImpl createResourcesImpl(@NonNull ResourcesKey key) &#123;      final DisplayAdjustments daj = new DisplayAdjustments(key.mOverrideConfiguration);      daj.setCompatibilityInfo(key.mCompatInfo);      //创建AssetManager      final AssetManager assets = createAssetManager(key);      if (assets == null) &#123;          return null;      &#125;      final DisplayMetrics dm = getDisplayMetrics(key.mDisplayId, daj);      final Configuration config = generateConfig(key, dm);      //将assets对象传入到ResourcesImpl中      final ResourcesImpl impl = new ResourcesImpl(assets, dm, config, daj);      if (DEBUG) &#123;          Slog.d(TAG, &quot;- creating impl=&quot; + impl + &quot; with key: &quot; + key);      &#125;      return impl;  &#125;</code></pre> 
<h4 id="2-6-RM-createAssetManager"><a href="#2-6-RM-createAssetManager" class="headerlink" title="2.6 RM.createAssetManager"></a>2.6 RM.createAssetManager</h4><p>[-&gt;base\core\java\android\app\ResourcesManager.java]</p>
<pre><code>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061protected @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key) &#123;      final AssetManager.Builder builder = new AssetManager.Builder();      // resDir can be null if the &apos;android&apos; package is creating a new Resources object.      // This is fine, since each AssetManager automatically loads the &apos;android&apos; package      // already.      if (key.mResDir != null) &#123;          try &#123;              builder.addApkAssets(loadApkAssets(key.mResDir, false /*sharedLib*/,                      false /*overlay*/));          &#125; catch (IOException e) &#123;              Log.e(TAG, &quot;failed to add asset path &quot; + key.mResDir);              return null;          &#125;      &#125;      if (key.mSplitResDirs != null) &#123;          for (final String splitResDir : key.mSplitResDirs) &#123;              try &#123;                  builder.addApkAssets(loadApkAssets(splitResDir, false /*sharedLib*/,                          false /*overlay*/));              &#125; catch (IOException e) &#123;                  Log.e(TAG, &quot;failed to add split asset path &quot; + splitResDir);                  return null;              &#125;          &#125;      &#125;      if (key.mOverlayDirs != null) &#123;          for (final String idmapPath : key.mOverlayDirs) &#123;              try &#123;                  builder.addApkAssets(loadApkAssets(idmapPath, false /*sharedLib*/,                          true /*overlay*/));              &#125; catch (IOException e) &#123;                  Log.w(TAG, &quot;failed to add overlay path &quot; + idmapPath);                  // continue.              &#125;          &#125;      &#125;      if (key.mLibDirs != null) &#123;          for (final String libDir : key.mLibDirs) &#123;              if (libDir.endsWith(&quot;.apk&quot;)) &#123;                  // Avoid opening files we know do not have resources,                  // like code-only .jar files.                  try &#123;                      builder.addApkAssets(loadApkAssets(libDir, true /*sharedLib*/,                              false /*overlay*/));                  &#125; catch (IOException e) &#123;                      Log.w(TAG, &quot;Asset path &apos;&quot; + libDir +                              &quot;&apos; does not exist or contains no resources.&quot;);                      // continue.                  &#125;              &#125;          &#125;      &#125;      //最后通过build完成创建      return builder.build();  &#125;</code></pre> 
<h4 id="2-7-AssetManager-addApkAssets"><a href="#2-7-AssetManager-addApkAssets" class="headerlink" title="2.7 AssetManager.addApkAssets"></a>2.7 AssetManager.addApkAssets</h4><p>[-&gt;base\core\java\android\content\res\AssetManager.java]</p>
<pre><code>1234567891011121314151617181920212223242526public Builder addApkAssets(ApkAssets apkAssets) &#123;         mUserApkAssets.add(apkAssets);         return this;&#125;public AssetManager build() &#123;         // Retrieving the system ApkAssets forces their creation as well.         final ApkAssets[] systemApkAssets = getSystem().getApkAssets();         final int totalApkAssetCount = systemApkAssets.length + mUserApkAssets.size();         final ApkAssets[] apkAssets = new ApkAssets[totalApkAssetCount];         System.arraycopy(systemApkAssets, 0, apkAssets, 0, systemApkAssets.length);         final int userApkAssetCount = mUserApkAssets.size();         for (int i = 0; i &lt; userApkAssetCount; i++) &#123;             apkAssets[i + systemApkAssets.length] = mUserApkAssets.get(i);         &#125;         // Calling this constructor prevents creation of system ApkAssets, which we took care         // of in this Builder.         final AssetManager assetManager = new AssetManager(false /*sentinel*/);         assetManager.mApkAssets = apkAssets;         AssetManager.nativeSetApkAssets(assetManager.mObject, apkAssets,                 false /*invalidateCaches*/);         return assetManager;     &#125;</code></pre> 
<h4 id="2-8-RM-loadApkAssets"><a href="#2-8-RM-loadApkAssets" class="headerlink" title="2.8 RM.loadApkAssets"></a>2.8 RM.loadApkAssets</h4><p>[-&gt;base\core\java\android\app\ResourcesManager.java]</p>
<pre><code>123456789101112131415161718192021222324252627282930313233343536373839404142private @NonNull ApkAssets loadApkAssets(String path, boolean sharedLib, boolean overlay)          throws IOException &#123;      final ApkKey newKey = new ApkKey(path, sharedLib, overlay);      ApkAssets apkAssets = null;      if (mLoadedApkAssets != null) &#123;          apkAssets = mLoadedApkAssets.get(newKey);          if (apkAssets != null) &#123;              return apkAssets;          &#125;      &#125;      // Optimistically check if this ApkAssets exists somewhere else.      final WeakReference&lt;ApkAssets&gt; apkAssetsRef = mCachedApkAssets.get(newKey);      if (apkAssetsRef != null) &#123;          apkAssets = apkAssetsRef.get();          if (apkAssets != null) &#123;              if (mLoadedApkAssets != null) &#123;                  mLoadedApkAssets.put(newKey, apkAssets);              &#125;              return apkAssets;          &#125; else &#123;              // Clean up the reference.              mCachedApkAssets.remove(newKey);          &#125;      &#125;      // We must load this from disk.      if (overlay) &#123;          apkAssets = ApkAssets.loadOverlayFromPath(overlayPathToIdmapPath(path),                  false /*system*/);      &#125; else &#123;          apkAssets = ApkAssets.loadFromPath(path, false /*system*/, sharedLib);      &#125;      if (mLoadedApkAssets != null) &#123;          mLoadedApkAssets.put(newKey, apkAssets);      &#125;      mCachedApkAssets.put(newKey, new WeakReference&lt;&gt;(apkAssets));      return apkAssets;  &#125;</code></pre> 
<p>按照这样的流程比较难hook，看下之前添加的方法addAssetPath，这个方法已经被废弃，但还可以用，hook这个方法比较简单。</p>
<pre><code>123456789/**   * @deprecated Use &#123;@link #setApkAssets(ApkAssets[], boolean)&#125;   * @hide   */  @Deprecated  @UnsupportedAppUsage  public int addAssetPath(String path) &#123;      return addAssetPathInternal(path, false /*overlay*/, false /*appAsLib*/);  &#125;</code></pre> 
<p>1.创建一个AssetManager对象，并调用addAssetPath方法，将插件apk路径作为参数传入</p>
<p>2.将创建的AssetManager对象作为参数，创建一个新的Resourced对象，并返回给插件使用。</p>
<pre><code>1234567891011121314public static Resources loadResource(Context context)&#123;      try &#123;          AssetManager assetManager = AssetManager.class.newInstance();          Method addAssetPathMethod = AssetManager.class.getDeclaredMethod(&quot;addAssetPath&quot;,String.class);          //加载插件资源          addAssetPathMethod.invoke(assetManager,apkPath);          Resources resources = context.getResources();          return new Resources(assetManager,resources.getDisplayMetrics(),resources.getConfiguration());      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;      return null;  &#125;</code></pre> 
<pre><code>1234567891011121314151617private Resources resources;@Overridepublic void onCreate() &#123;   super.onCreate();   //加载插件类   LoadClassUtil.loadClass(this);   //创建新的resources   resources = LoadClassUtil.loadResource(this);   HookUtil.hookAMS();   HookUtil.hookHandler();&#125;@Overridepublic Resources getResources() &#123;  //resources为空，相当于没有重写，不为空是返回新建的resources对象   return resources==null?super.getResources():resources;&#125;</code></pre> 
<p>然后让插件的Activity重写getResources方法，获取的资源就是新创建的resources对象</p>
<pre><code>1234567@Override public Resources getResources() &#123;     if(getApplication()!=null&amp;&amp;getApplication()!=null)&#123;         return getApplication().getResources();     &#125;     return super.getResources(); &#125;</code></pre> 
<h3 id="三、hook-Activity"><a href="#三、hook-Activity" class="headerlink" title="三、hook Activity"></a>三、hook Activity</h3><p>首先在宿主里面创建一个ProxyActivity，并且在Manifest中注册（如果需要对应不同启动模式的Activity，可以全部把每种启动模式下的Activity都注册）。当启动插件Activity时，进入AMS之前，通过Hook将插件Activity替换成ProxyActivity，在进入AMS之后，通过handler发送消息时使用hook将ProxyActivity替换成插件的Activity。</p>
<p>startActivity的流程如下图，可以看到这两个具体的hook点</p>
<p><img src="/2020/Android10.0如何hook Activity/startActivity.jpg" alt="startActivity" style="zoom: 50%;"></p>
<h4 id="3-1-hook-AMS"><a href="#3-1-hook-AMS" class="headerlink" title="3.1 hook AMS"></a>3.1 hook AMS</h4><p>在进入到AMS之前，这个是最后一步，那么如何将intent换成插件的intent的呢？可以通过动态代理实现。</p>
<pre><code>1234567891011121314151617public ActivityResult execStartActivity(     Context who, IBinder contextThread, IBinder token, String target,     Intent intent, int requestCode, Bundle options) &#123;     ...     try &#123;         intent.migrateExtraStreamToClipData();         intent.prepareToLeaveProcess(who);         int result = ActivityManager.getService()             .startActivity(whoThread, who.getBasePackageName(), intent,                     intent.resolveTypeIfNeeded(who.getContentResolver()),                     token, target, requestCode, 0, null, options);         checkStartActivityResult(result, intent);     &#125; catch (RemoteException e) &#123;         throw new RuntimeException(&quot;Failure from system&quot;, e);     &#125;     return null; &#125;</code></pre> 
<p>ActivityManager.getService具体实现如下</p>
<pre><code>12345678910111213141516171819202122232425262728293031323334/**   * @hide   */  @UnsupportedAppUsage  public static IActivityManager getService() &#123;      return IActivityManagerSingleton.get();  &#125;  public abstract class Singleton&lt;T&gt; &#123;  @UnsupportedAppUsage  private T mInstance;  protected abstract T create();  @UnsupportedAppUsage  public final T get() &#123;      synchronized (this) &#123;          if (mInstance == null) &#123;              mInstance = create();          &#125;          return mInstance;      &#125;  &#125;&#125;    @UnsupportedAppUsage  private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =          new Singleton&lt;IActivityManager&gt;() &#123;              @Override              protected IActivityManager create() &#123;                  final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                  //获取AMS的代理                  final IActivityManager am = IActivityManager.Stub.asInterface(b);                  return am;              &#125;          &#125;;</code></pre> 
<p>第一步获取IActivityManager对象</p>
<pre><code>123456789101112//获取IActivityManagerSingleton对象，用于获取mIntanceClass&lt;?&gt; clazz = Class.forName(&quot;android.app.ActivityManager&quot;);Field singletonFiled = clazz.getDeclaredField(&quot;IActivityManagerSingleton&quot;);singletonFiled.setAccessible(true);Object singleton = singletonFiled.get(null);//获取Singleton对象Class&lt;?&gt; singletonClass = Class.forName(&quot;android.util.Singleton&quot;);Field mInstanceField = singletonClass.getDeclaredField(&quot;mInstance&quot;);mInstanceField.setAccessible(true);//获取mInstance对象final Object mInstance = mInstanceField.get(singleton);</code></pre> 
<p>第二步将intent替换成插件的intent</p>
<pre><code>123456789101112131415161718192021222324252627Class&lt;?&gt; iActivityManagerClass = Class.forName(&quot;android.app.IActivityManager&quot;);         Object proxyInstance = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]&#123;iActivityManagerClass&#125;,                 new InvocationHandler() &#123;                     @Override                     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                         if(&quot;startActivity&quot;.equals(method.getName()))&#123;                             int index = 0;                             for(int i=0;i&lt;args.length;i++)&#123;                                 if(args[i] instanceof Intent)&#123;                                     index = i;                                     break;                                 &#125;                             &#125;                             //启动插件的intent                             Intent intent = (Intent) args[index];                             //启动代理的intent                             Intent proxyIntent = new Intent();                  proxyIntent.setClassName(&quot;com.android.test&quot;,&quot;com.android.test.ProxyActivity&quot;);                             //保存插件的intent                             proxyIntent.putExtra(&quot;target&quot;,intent);                             args[index] = proxyIntent;                         &#125;                         return method.invoke(mInstance,args);                     &#125;                 &#125;);//替换mInstance对象mInstanceField.set(singleton,proxyInstance);</code></pre> 
<p>这样第一个hook点就完成了，下面看下第二步hook点</p>
<h4 id="3-2-hook-Handler"><a href="#3-2-hook-Handler" class="headerlink" title="3.2 hook Handler"></a>3.2 hook Handler</h4><p>在启动Activity之前的操作，Android10.0用状态模式完成Activity的生命周期的启动，那么如何将代理的intent替换成插件的intent的呢？从源码可以看出最后通过scheduleTransaction方法启动Activity，那么是否通过clientTransaction替换intent的呢，通过分析startActivity的启动流程，答案是可以的。</p>
<pre><code>123456789101112131415161718192021222324252627//创建Activity启动事务// Create activity launch transaction.final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,       r.appToken);clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),       System.identityHashCode(r), r.info,       // TODO: Have this take the merged configuration instead of separate global       // and override configs.       mergedConfiguration.getGlobalConfiguration(),       mergedConfiguration.getOverrideConfiguration(), r.compat,       r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,       r.persistentState, results, newIntents, mService.isNextTransitionForward(),       profilerInfo));//设置目标事务的状态为onResume// Set desired final state.final ActivityLifecycleItem lifecycleItem;if (andResume) &#123;   lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());&#125; else &#123;   lifecycleItem = PauseActivityItem.obtain();&#125;clientTransaction.setLifecycleStateRequest(lifecycleItem);//通过transaciton方式开始activity生命周期，onCreate,onStart,onResume// Schedule transaction.mService.getLifecycleManager().scheduleTransaction(clientTransaction);</code></pre> 
<p>scheduleTransaction还是要通过Handler发送消息，进入EXECUTE_TRANSACTION分支</p>
<pre><code>123456789101112131415public void handleMessage(Message msg) &#123;        ...        case EXECUTE_TRANSACTION:                   final ClientTransaction transaction = (ClientTransaction) msg.obj;                   mTransactionExecutor.execute(transaction);                   if (isSystem()) &#123;                       // Client transactions inside system process are recycled on the client side                       // instead of ClientLifecycleManager to avoid being cleared before this                       // message is handled.                       transaction.recycle();                   &#125;                   // TODO(lifecycler): Recycle locally scheduled transactions.                   break;          ....    &#125;</code></pre> 
<p>那么要替换intent首先需要hook handleMessage</p>
<pre><code>12345678910111213141516171819202122232425262728293031323334353637383940414243//获取ActivityThread对象Class&lt;?&gt; clazz = Class.forName(&quot;android.app.ActivityThread&quot;);Field sCurrentActivityThreadField = clazz.getDeclaredField(&quot;sCurrentActivityThread&quot;);sCurrentActivityThreadField.setAccessible(true);Object activityThread = sCurrentActivityThreadField.get(null);//获取handlerField mHField = clazz.getDeclaredField(&quot;mH&quot;);mHField.setAccessible(true);Object mH = mHField.get(activityThread);//获取callback对象Field mCallbackField = Handler.class.getDeclaredField(&quot;mCallback&quot;);mCallbackField.setAccessible(true);mCallbackField.set(mH, new Handler.Callback() &#123;   @Override   public boolean handleMessage(Message msg) &#123;     switch (msg.what)&#123;         case 159:             try &#123;                 //获取List&lt;ClientTransactionItem&gt; mActivityCallbacks对象                 Class&lt;?&gt; clientTransactionClass = msg.obj.getClass();                 Field mActivityCallbacksField = clientTransactionClass.getDeclaredField(&quot;mActivityCallbacks&quot;);                 mActivityCallbacksField.setAccessible(true);                 List mActivityCallbacks = (List) mActivityCallbacksField.get(msg.obj);                 for(int i=0;i&lt;mActivityCallbacks.size();i++)&#123;                          if(mActivityCallbacks.get(i).getClass().getName().equals(&quot;android.app.servertransaction.LaunchActivityItem&quot;))&#123;                         //获取LaunchActivityItem                         Object launchActivityItem = mActivityCallbacks.get(i);                         Class&lt;?&gt; launchActivityItemClass = launchActivityItem.getClass();                         Field mIntentField = launchActivityItemClass.getDeclaredField(&quot;mIntent&quot;);                         mIntentField.setAccessible(true);                         //代理intent                         Intent proxyIntent = (Intent) mIntentField.get(launchActivityItem);                         //插件intent                         Intent intent = proxyIntent.getParcelableExtra(&quot;target&quot;);                         //插件intent替换代理intent                         proxyIntent.setComponent(intent.getComponent());                     &#125;                 &#125;</code></pre> 
<p>hook了handleMessage后，通过LaunchActivityItem中的mIntent完成代理intent的替换。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>hook Activity涉及的技术比较多，Activity的启动流程，类加载，动态代理，资源加载，反射，binder机制等，只有在掌握了这些技术的基础上才能够完成插件化技术的开发。</p>
<p>本文介绍了hook Activity的具体实现方法，通过该方法引申出类的加载和资源加载的原理，并分析具体插件的加载实现，后面结合之前文章分析的<a href="https://skytoby.github.io/2019/startActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">startActivity的启动流程</a>，引出了两个具体的hook点：</p>
<p>1.在ActivityManager.getService().startActivity时通过反射获取IActivityManager对象，startActivity时将插件的Activity替换成代理的Activity；</p>
<p>2.反射获取ActivityThread对象，通过获取类成员变量mH，重新设置callback，将handleMessage中的EXECUTE_TRANSACTION分支进行hook，在mActivityCallbacks中找到LaunchActivityItem，将其类成员变量mIntent替换成插件的Activity，这样就完成的插件Activity的启动过程。</p>