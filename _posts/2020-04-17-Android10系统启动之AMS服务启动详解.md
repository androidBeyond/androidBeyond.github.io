---
layout:     post
title:      Android10系统启动之AMS服务启动详解
subtitle:   这篇文章我们来详细学习下Android10系统启动中AMS服务启动过程
date:       2020-04-17
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - 系统启动
	- AMS
	- 系统服务
--- 

<h1>1.概述</h1> 
<p>上一节我们讲完了SystemServer的启动过程&#xff0c;这一节接着上一节的步骤&#xff0c;来讲解ActivityManagerService的启动过程。</p> 
<p>ActivityManagerService简称AMS&#xff0c;具有管理Activity行为、控制activity的生命周期、派发消息事件、内存管理等功能。</p> 
<p> </p> 
<h1>2.核心源码</h1> 
<p> </p> 
<pre class="has"><code>/frameworks/base/services/java/com/android/server/SystemServer.java
/frameworks/base/core/java/android/app/ActivityThread.java
/frameworks/base/core/java/android/app/Instrumentation.java
/frameworks/base/core/java/android/app/ContextImpl.java
/frameworks/base/core/java/android/app/LoadedApk.java
/frameworks/base/core/java/android/app/Application.java

/frameworks/base/core/java/com/android/server/LocalServices.java
/frameworks/base/services/core/java/com/android/server/ServiceThread.java

/frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerInternal.java
/frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java
/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</code></pre> 
<p> </p> 
<h1>3.架构</h1> 
<p>ActivityManagerService启动共分为以下4个阶段&#xff1a;</p> 
<p><strong>阶段1&#xff1a;</strong>为SystemSerer进程创建Android运行环境。AMS运行与SystemServer进程中&#xff0c;它的许多工作依赖于该运行环境</p> 
<pre class="has"><code>createSystemContext() -&gt; new ActvityThread()--&gt;attach -&gt;getSystemContext -&gt;createSystemContext</code></pre> 
<p><strong>阶段2&#xff1a;</strong>启动AMS&#xff0c;主要进行一些初始化工作</p> 
<pre class="has"><code>new ActivityManagerService()

start()</code></pre> 
<p><strong>阶段3&#xff1a;</strong>将SystemServer进程纳入到AMS的进程管理体系中</p> 
<pre class="has"><code>setSystemProcess() //将framework-res.apk的信息加入到SystemServer进程的LoadedApk中&#xff1b;构建SystemServer进程的ProcessRecord&#xff0c;保存到AMS中&#xff0c;以便AMS进程统一管理

installSystemProvider() //安装SystemServer进程中的SettingsProvider.apk</code></pre> 
<p><strong>阶段4&#xff1a;</strong>AMS启动完成&#xff0c;通知服务或应用完成后续的工作&#xff0c;或直接启动一些进程</p> 
<p>AMS.systemReady() //许多服务或应用进程必须等待AMS完成启动工作后&#xff0c;才能启动或进行一些后续工作&#xff1b;AMS就是在systemReady中&#xff0c;通知或者启动这些等待的服务和应用进程&#xff0c;例如启动桌面等。</p> 
<p> </p> 
<p><strong>ActivityManagerService时序图如下</strong>&#xff1a;</p> 
<p><img alt="" class="has" height="727" src="https://img-blog.csdnimg.cn/20191215171942555.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" width="842" /></p> 
<h1> </h1> 
<h1>4. ActivityManagerService启动流程-源码分析</h1> 
<h1> </h1> 
<p><img alt="" class="has" height="1200" src="https://img-blog.csdnimg.cn/2019121517201180.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" width="1200" /></p> 
<p> <img alt="" class="has" height="518" src="https://img-blog.csdnimg.cn/20191215172020774.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" width="1200" /></p> 
<p> </p> 
<h2>4.1 SystemServer启动</h2> 
<p>Zygote进行启动后&#xff0c;第一个Fork出SystemServer进程&#xff0c;SystemServer的启动流程可以参考我之前的文章&#xff0c;这里只分析与AMS相关的启动流程&#xff1a;</p> 
<ol><li>初始化 SystemContext</li><li>创建SystemServiceManager 对象&#xff0c;用来启动后面的服务</li><li>启动系统服务&#xff0c;共分为三种系统服务&#xff1a;系统引导服务&#xff08;Boot Service&#xff09;、核心服务&#xff08;Core Service&#xff09;和其他服务&#xff08;Other Service&#xff09;</li><li>在引导服务&#xff08;Boot Service&#xff09;中启动ATM、AMS服务</li><li>在其他服务&#xff08;Other Service&#xff09;中完成AMS的最后工作systemReady</li></ol>
<p><strong>源码&#xff1a;</strong></p> 
<p><strong>[SystemServer.java]</strong></p> 
<p> </p> 
<pre class="has"><code>public static void main(String[] args) {
    new SystemServer().run();
}

private void run() {
    ...
    //1.初始化 System Context
    createSystemContext(); //参考[4.2]

    //2.创建 SystemServiceManager 对象&#xff0c;用来启动后面的服务
    mSystemServiceManager &#61; new SystemServiceManager(mSystemContext); 
    //参考[4.3]
    mSystemServiceManager.setStartInfo(mRuntimeRestart,
            mRuntimeStartElapsedTime, mRuntimeStartUptime);
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
    ...
    
    //3.启动服务
    startBootstrapServices();  //启动引导服务&#xff0c;参考[4.1.1]
    startCoreServices();       //启动核心服务
    startOtherServices();      //启动其他服务&#xff0c;参考[4.1.2]
    ...
}
</code></pre> 
<h3>4.1.1 [SystemServer.java] startBootstrapServices()</h3> 
<p><strong>说明&#xff1a;</strong>启动引导服务&#xff0c;在其中启动了ATM和AMS服务&#xff0c;通过AMS安装Installer、初始化Power&#xff0c;设置系统进程等。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">private void startBootstrapServices() {
    ...
    //启动ActivityTaskManagerService服务&#xff0c;简称ATM,Android10新引入功能&#xff0c;用来管理Activity的启动、调度等功能
    //参考[4.4]
    atm &#61; mSystemServiceManager.startService(
            ActivityTaskManagerService.Lifecycle.class).getService();

    //参考[4.5]
    //启动服务 ActivityManagerService&#xff0c;简称AMS
    mActivityManagerService &#61; ActivityManagerService.Lifecycle.startService(
            mSystemServiceManager, atm);

    //安装Installer
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);
    
    //初始化PowerManager
    mActivityManagerService.initPowerManagement();
    
    //设置系统进程&#xff0c;参考4.6
    mActivityManagerService.setSystemProcess();
    
}</code></pre> 
<p> </p> 
<p> </p> 
<h3>4.1.2 [SystemServer.java] startOtherServices</h3> 
<p><strong>说明&#xff1a;</strong>启动其他服务&#xff0c;AMS启动后&#xff0c;完成后续桌面启动等操作</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void startOtherServices() {
    ...
    //安装SettingsProvider.apk
    mActivityManagerService.installSystemProviders();
    mActivityManagerService.setWindowManager(wm);

    //AMS启动完成&#xff0c;完成后续的工作&#xff0c;例如启动桌面等
    //参考[4.7]
    mActivityManagerService.systemReady(() -&gt; {
        ...
    }, BOOT_TIMINGS_TRACE_LOG);
    ...
}</code></pre> 
<h2>4.2 System Context初始化</h2> 
<p><strong>说明&#xff1a; </strong>在SystemServer的run函数中&#xff0c;在启动AMS之前&#xff0c;调用了createSystemContext函&#xff0c;主要用来是初始化 System Context和SystemUi Context&#xff0c;并设置主题</p> 
<p>当SystemServer 调用createSystemContext()完毕后&#xff0c;完成以下两个内容&#xff1a;</p> 
<ol><li>得到了一个ActivityThread对象&#xff0c;它代表当前进程 (此时为系统进程) 的主线程&#xff1b; </li><li>得到了一个Context对象&#xff0c;对于SystemServer而言&#xff0c;它包含的Application运行环境与framework-res.apk有关。</li></ol>
<p><strong>源码&#xff1a;</strong></p> 
<p><strong>[SystemServer.java]</strong></p> 
<pre class="has"><code class="language-java">private void createSystemContext() {
    ActivityThread activityThread &#61; ActivityThread.systemMain();  //参考[4.2.1]
    
    //获取system context
    mSystemContext &#61; activityThread.getSystemContext();
    //设置系统主题
    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);

    //获取systemui context
    final Context systemUiContext &#61; activityThread.getSystemUiContext();
    //设置systemUI 主题
    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);
}
</code></pre> 
<h3>4.2.1 [ActivityThread.java] systemMain()</h3> 
<p><strong>说明&#xff1a;</strong>systemMain函数主要作用是&#xff1a; 创建ActivityThread对象&#xff0c;然后调用该对象的attach函数。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p><strong>[ActivityThread.java]</strong></p> 
<pre class="has"><code class="language-java">public static ActivityThread systemMain() {
    // The system process on low-memory devices do not get to use hardware
    // accelerated drawing, since this can add too much overhead to the
    // process.
    if (!ActivityManager.isHighEndGfx()) {
        ThreadedRenderer.disable(true);
    } else {
        ThreadedRenderer.enableForegroundTrimming();
    }
    //获取ActivityThread对象
    ActivityThread thread &#61; new ActivityThread(); //参考[4.2.2]
    thread.attach(true, 0); 参考[4.2.3]
    return thread;
}
</code></pre> 
<p> </p> 
<h3>4.2.2 ActivityThread 对象创建</h3> 
<p><strong>说明&#xff1a;</strong>ActivityThread是Android Framework中一个非常重要的类&#xff0c;它代表一个应用进程的主线程&#xff0c;其职责就是调度及执行在该线程中运行的四大组件。 </p> 
<p>注意到此处的ActivityThread创建于SystemServer进程中。 </p> 
<p>由于SystemServer中也运行着一些系统APK&#xff0c;例如framework-res.apk、SettingsProvider.apk等&#xff0c;因此也可以认为SystemServer是一个特殊的应用进程。</p> 
<p>AMS负责管理和调度进程&#xff0c;因此AMS需要通过Binder机制和应用进程通信。 </p> 
<p>为此&#xff0c;Android提供了一个IApplicationThread接口&#xff0c;该接口定义了AMS和应用进程之间的交互函数。</p> 
<p>ActivityThread的构造函数比较简单&#xff0c;获取ResourcesManager的单例对象&#xff0c;比较关键的是它的成员变量&#xff1a;</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public final class ActivityThread extends ClientTransactionHandler {

    ...
    //定义了AMS与应用通信的接口&#xff0c;拿到ApplicationThread的对象
    final ApplicationThread mAppThread &#61; new ApplicationThread();

    //拥有自己的looper&#xff0c;说明ActivityThread确实可以代表事件处理线程
    final Looper mLooper &#61; Looper.myLooper();

    //H继承Handler&#xff0c;ActivityThread中大量事件处理依赖此Handler
    final H mH &#61; new H();

    //用于保存该进程的ActivityRecord
    final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities &#61; new ArrayMap&lt;&gt;();

    //用于保存进程中的Service
    final ArrayMap&lt;IBinder, Service&gt; mServices &#61; new ArrayMap&lt;&gt;();

    用于保存进程中的Application
    final ArrayList&lt;Application&gt; mAllApplications
        &#61; new ArrayList&lt;Application&gt;();
    //构造函数
    &#64;UnsupportedAppUsage
    ActivityThread() {
        mResourcesManager &#61; ResourcesManager.getInstance();
    }
}</code></pre> 
<h3>4.2.3 [ActivityThread.java] attach</h3> 
<p><strong>说明&#xff1a;</strong>对于系统进程而言&#xff0c;ActivityThread的attach函数最重要的工作就是创建了Instrumentation、Application和Context</p> 
<p><strong>调用&#xff1a;</strong>attach(true, 0)&#xff0c;传入的system为0</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">private void attach(boolean system, long startSeq) {
    mSystemThread &#61; system;
    //传入的system为0
    if (!system) {
        //应用进程的处理流程
        ...
    } else {
        //系统进程的处理流程&#xff0c;该情况只在SystemServer中处理
        //创建ActivityThread中的重要成员&#xff1a;Instrumentation、 Application 和 Context
        mInstrumentation &#61; new Instrumentation();
        mInstrumentation.basicInit(this);
        
        //创建系统的Context&#xff0c;参考[4.2.4]
        ContextImpl context &#61; ContextImpl.createAppContext(
                this, getSystemContext().mPackageInfo);
        
        //调用LoadedApk的makeApplication函数
        mInitialApplication &#61; context.mPackageInfo.makeApplication(true, null);
        mInitialApplication.onCreate();
    }
    
}</code></pre> 
<p>Instrumentation </p> 
<p>Instrumentation是Android中的一个工具类&#xff0c;当该类被启用时&#xff0c;它将优先于应用中其它的类被初始化。 </p> 
<p>此时&#xff0c;系统先创建它&#xff0c;再通过它创建其它组件。</p> 
<pre class="has"><code>mInstrumentation &#61; new Instrumentation();
mInstrumentation.basicInit(this);</code></pre> 
<p><strong>Context</strong></p> 
<p>Context是Android中的一个抽象类&#xff0c;用于维护应用运行环境的全局信息。</p> 
<p>通过Context可以访问应用的资源和类&#xff0c;甚至进行系统级的操作&#xff0c;例如启动Activity、发送广播等。</p> 
<p>ActivityThread的attach函数中&#xff0c;通过下面的代码创建出系统应用对应的Context:</p> 
<pre class="has"><code>ContextImpl context &#61; ContextImpl.createAppContext(this, getSystemContext().mPackageInfo);</code></pre> 
<p><strong>Application:</strong></p> 
<p>Android中Application类用于保存应用的全局状态。</p> 
<p>在ActivityThread中&#xff0c;针对系统进程&#xff0c;通过下面的代码创建了初始的Application&#xff1a;</p> 
<pre class="has"><code>mInitialApplication &#61; context.mPackageInfo.makeApplication(true, null);
mInitialApplication.onCreate();</code></pre> 
<p> </p> 
<h3>4.2.4 [ContextImpl.java] getSystemContext()</h3> 
<p><strong>说明&#xff1a;</strong>创建并返回System Context</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public ContextImpl getSystemContext() {
    synchronized (this) {
        if (mSystemContext &#61;&#61; null) {
            //调用ContextImpl的静态函数createSystemContext
            mSystemContext &#61; ContextImpl.createSystemContext(this);
        }
        return mSystemContext;
    }
}</code></pre> 
<p><strong>说明&#xff1a;</strong>createSystemContext的内容就是创建一个LoadedApk&#xff0c;然后初始化一个ContextImpl对象。 <br /> 注意到createSystemContext函数中&#xff0c;创建的LoadApk对应packageName为”android”&#xff0c;也就是framwork-res.apk。 <br /> 由于该APK仅供SystemServer进程使用&#xff0c;因此创建的Context被定义为System Context。 <br /> 现在该LoadedApk还没有得到framwork-res.apk实际的信息。<br /> 当PKMS启动&#xff0c;完成对应的解析后&#xff0c;AMS将重新设置这个LoadedApk。</p> 
<pre class="has"><code>static ContextImpl createSystemContext(ActivityThread mainThread) {
    //创建LoadedApk类&#xff0c;代表一个加载到系统中的APK
    //注意此时的LoadedApk只是一个空壳
    //PKMS还没有启动&#xff0c;无法得到有效的ApplicationInfo
    LoadedApk packageInfo &#61; new LoadedApk(mainThread);

    //拿到ContextImpl 的对象
    ContextImpl context &#61; new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,
            null, null);
     //初始化资源信息
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(),
            context.mResourcesManager.getDisplayMetrics());
    return context;
}</code></pre> 
<h2>4.3 SystemServiceManager 创建</h2> 
<p><strong>说明&#xff1a;</strong> 通过 SystemServiceManager 的构造方法创建一个 SystemServiceManager 对象&#xff0c;并将该对象添加到 LocalServices 中。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void run() {
    ...
    //1.创建SystemServiceManager对象&#xff0c;参考 [4.3.1]
    mSystemServiceManager &#61; new SystemServiceManager(mSystemContext);
    mSystemServiceManager.setStartInfo(mRuntimeRestart,
            mRuntimeStartElapsedTime, mRuntimeStartUptime);
    //2.启动SystemServiceManager服务,参考[4.3.2]
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
    ...
}
</code></pre> 
<p> </p> 
<h3>4.3.1 [SystemServiceManager.java] SystemServiceManager()</h3> 
<p><strong>说明&#xff1a;</strong>SystemServiceManager 对象主要用于管理 SystemService 的创建、启动等生命周期&#xff0c;SystemService 类是一个抽象类</p> 
<p>在 SystemServiceManager 中都是通过反射创建 SystemService 中对象的&#xff0c;而且在 startService(&#64;NonNull final SystemService service) 方法中&#xff0c;会将 SystemService 添加到 mServices 中&#xff0c;并调用 onStart() 方法</p> 
<p>SystemServiceManager构造函数没有多少内容&#xff0c;主要是把传进来的system Context赋值给 mContext&#xff0c;供后续服务创建使用</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">public class SystemServiceManager {
    ...
    private final Context mContext;
    private final ArrayList&lt;SystemService&gt; mServices &#61; new ArrayList&lt;SystemService&gt;();
    ...
    SystemServiceManager(Context context) {
        mContext &#61; context;
    }

    public SystemService startService(String className) {
        final Class&lt;SystemService&gt; serviceClass;
        try {
            //通过反射根据类名&#xff0c;拿到类对象
            serviceClass &#61; (Class&lt;SystemService&gt;)Class.forName(className);
        } catch (ClassNotFoundException ex) {
            Slog.i(TAG, &#34;Starting &#34; &#43; className);
            ...
        }
        return startService(serviceClass);
    }

    public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {
        try {
            final String name &#61; serviceClass.getName();
            // Create the service.
            final T service;
            ...
                service &#61; constructor.newInstance(mContext);
            ...
            startService(service);
            return service;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
    }
    
    public void startService(&#64;NonNull final SystemService service) {
        // Register it.
        mServices.add(service);
        // Start it.
        long time &#61; SystemClock.elapsedRealtime();
        try {
            service.onStart();  //调用各个服务中的onStart()方法完成服务启动
        } catch (RuntimeException ex) {
            throw new RuntimeException(&#34;Failed to start service &#34; &#43; service.getClass().getName()
                    &#43; &#34;: onStart threw an exception&#34;, ex);
        }
    }
}
</code></pre> 
<h3>4.3.2 [LocalServices.java] addService(SystemServiceManager.class, mSystemServiceManager);</h3> 
<p><strong>说明&#xff1a;</strong>把SystemServiceManager的对象加入到本地服务的全局注册表中</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">public final class LocalServices {
    private LocalServices() {}

    private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects &#61;
            new ArrayMap&lt;Class&lt;?&gt;, Object&gt;();

    //返回实现指定接口的本地服务实例对象
    &#64;SuppressWarnings(&#34;unchecked&#34;)
    public static &lt;T&gt; T getService(Class&lt;T&gt; type) {
        synchronized (sLocalServiceObjects) {
            return (T) sLocalServiceObjects.get(type);
        }
    }

    //将指定接口的服务实例添加到本地服务的全局注册表中
    public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) {
        synchronized (sLocalServiceObjects) {
            if (sLocalServiceObjects.containsKey(type)) {
                throw new IllegalStateException(&#34;Overriding service registration&#34;);
            }
            sLocalServiceObjects.put(type, service);
        }
    }

    //删除服务实例&#xff0c;只能在测试中使用。
    public static &lt;T&gt; void removeServiceForTest(Class&lt;T&gt; type) {
        synchronized (sLocalServiceObjects) {
            sLocalServiceObjects.remove(type);
        }
    }
}
</code></pre> 
<h2>4.4 ActivityTaskManagerService 服务启动</h2> 
<p><strong>说明&#xff1a;</strong>ActivityTaskManagerService简称ATM&#xff0c;Android10中引入新功能,用来管理Activity的启动、调度等功能</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void startBootstrapServices() {
    ...
    //启动ATM
    atm &#61; mSystemServiceManager.startService(
                ActivityTaskManagerService.Lifecycle.class).getService();
    ...
}
</code></pre> 
<h3>4.4.1 ATM服务启动过程</h3> 
<p><strong>说明&#xff1a;</strong>从4.3.1 中我们知道SystemServiceManager.startService最终调用的是启动对象中的onStart方法</p> 
<p>因此ATM启动&#xff0c;最终会调用ActivityTaskManagerService.Lifecycle.onStart()来启动ATM服务</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code>public static final class Lifecycle extends SystemService {
        private final ActivityTaskManagerService mService;

        public Lifecycle(Context context) {
            super(context);
            //1.创建ActivityTaskManagerService&#xff0c;得到对象&#xff0c;参考[4.4.2]
            mService &#61; new ActivityTaskManagerService(context);
        }

        &#64;Override
        public void onStart() {
            publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);
            //2.启动ATM服务,&#xff0c;参考[4.4.3]
            mService.start();
        }
        ...
        public ActivityTaskManagerService getService() {
            return mService;
        }
    }</code></pre> 
<h3>4.4.2 ActivityTaskManagerService 对象创建</h3> 
<p><strong>说明&#xff1a;</strong>ActivityTaskManagerService简称ATM, Android10新引入功能&#xff0c;用来管理Activity的启动、调度等功能</p> 
<p>Android10 中把原先在AMS中activity的管理移动到ATM中</p> 
<p>从Android 10的代码路径可以看出&#xff0c;管理Activity的ATM被放入到的wm路径中&#xff0c;这个路径原先归WindowManagerService -WMS控制&#xff0c;谷歌的目的也是希望在将来把activity和window融合在一起&#xff0c;减少冗余代码以及AMS和WMS的协调工作</p> 
<p><strong>ATM的路径为&#xff1a;</strong>frameworks\base\services\core\java\com\android\server\wm</p> 
<p><strong>AMS的路径为&#xff1a;</strong>frameworks\base\services\core\java\com\android\server\am</p> 
<p>ATM服务提供了AIDL接口供</p> 
<p> </p> 
<pre class="has"><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    final Context mUiContext;
    final ActivityThread mSystemThread;
    final ActivityTaskManagerInternal mInternal;

    //ActivityStackSupervisor 是ATM中用来管理Activity启动和调度的核心类
    public ActivityStackSupervisor mStackSupervisor;
    //Activity 容器的根节点
    RootActivityContainer mRootActivityContainer;
    //WMS 负责窗口的管理
    WindowManagerService mWindowManager;
    
    //这是我们目前认为是&#34;Home&#34; Activity的过程
    WindowProcessController mHomeProcess;
    
    public ActivityTaskManagerService(Context context) {
        //拿到System Context
        mContext &#61; context;  
        mFactoryTest &#61; FactoryTest.getMode();

        //取出的是ActivityThread的静态变量sCurrentActivityThread
        //这意味着mSystemThread与SystemServer中的ActivityThread一致
        mSystemThread &#61; ActivityThread.currentActivityThread();
        
        //拿到System UI Context
        mUiContext &#61; mSystemThread.getSystemUiContext();
        mLifecycleManager &#61; new ClientLifecycleManager();
        //拿到LocalService的对象
        mInternal &#61; new LocalService();
        GL_ES_VERSION &#61; SystemProperties.getInt(&#34;ro.opengles.version&#34;, GL_ES_VERSION_UNDEFINED);
    }
}
</code></pre> 
<h3>4.4.3 [ActivityTaskManagerService.java] start()</h3> 
<p><strong>说明&#xff1a;</strong>将 ActivityTaskManagerInternal添加到本地服务的全局注册表中&#xff0c;ActivityTaskManagerInternal为抽象类</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void start() {
    LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);
}
</code></pre> 
<h2>4.5 ActivityManagerService 服务启动</h2> 
<p><strong>说明&#xff1a;</strong>ActivityManagerService简称AMS,在Android 10的版本中&#xff0c;Activity的管理和调度移到ATM中&#xff0c;AMS负责 service,broadcast,provider的管理和调度</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void startBootstrapServices() {
    ...
    //启动AMS
    mActivityManagerService &#61; ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);
    ...
}
</code></pre> 
<p> </p> 
<h3>4.5.1 AMS服务启动过程</h3> 
<p><strong>说明&#xff1a;</strong>从4.3.1 中我们知道SystemServiceManager.startService最终调用的是启动对象中的onStart方法</p> 
<p>因此AMS服务启动&#xff0c;最终会调用ActivityManagerService.Lifecycle.onStart()来启动ATM服务</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<p> </p> 
<pre class="has"><code class="language-java">public static final class Lifecycle extends SystemService {
    private final ActivityManagerService mService;
    private static ActivityTaskManagerService sAtm;

    public Lifecycle(Context context) {
        super(context);
        //1.创建ActivityManagerService&#xff0c;得到对象&#xff0c;传入ATM的对象&#xff0c;参考[4.5.2]
        mService &#61; new ActivityManagerService(context, sAtm);
    }

    &#64;Override
    public void onStart() {
        mService.start();
    }
    ...
    public ActivityManagerService getService() {
        return mService;
    }
}
</code></pre> 
<h3>4.5.2 AMS 对象创建</h3> 
<p><strong>说明&#xff1a;</strong>Android10中,Activity的管理和调度放入到ATM中执行&#xff0c;AMS中保留 service,broadcast,provider的管理和调度</p> 
<p>构造函数初始化主要工作就是初始化一些变量&#xff0c;供之后的service,broadcast,provider的管理和调度</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
    public ActivityManagerService(Context systemContext, ActivityTaskManagerService atm) {
        ...
        //AMS的运行上下文与SystemServer一致
        mContext &#61; systemContext;
        ...
        //取出的是ActivityThread的静态变量sCurrentActivityThread
        //这意味着mSystemThread与SystemServer中的ActivityThread一致
        mSystemThread &#61; ActivityThread.currentActivityThread();
        mUiContext &#61; mSystemThread.getSystemUiContext();

        mHandlerThread &#61; new ServiceThread(TAG,
                THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);
        mHandlerThread.start();
        
        //处理AMS中消息的主力
        mHandler &#61; new MainHandler(mHandlerThread.getLooper());
        
        //UiHandler对应于Android中的UiThread
        mUiHandler &#61; mInjector.getUiHandler(this);

        //创建 BroadcastQueue 前台广播对象&#xff0c;处理超时时长是 10s
        mFgBroadcastQueue &#61; new BroadcastQueue(this, mHandler,
                &#34;foreground&#34;, foreConstants, false);
        //创建 BroadcastQueue 后台广播对象&#xff0c;处理超时时长是 60s
        mBgBroadcastQueue &#61; new BroadcastQueue(this, mHandler,
                &#34;background&#34;, backConstants, true);
        //创建 BroadcastQueue 分流广播对象&#xff0c;处理超时时长是 60s
        mOffloadBroadcastQueue &#61; new BroadcastQueue(this, mHandler,
                &#34;offload&#34;, offloadConstants, true);
        mBroadcastQueues[0] &#61; mFgBroadcastQueue;
        mBroadcastQueues[1] &#61; mBgBroadcastQueue;
        mBroadcastQueues[2] &#61; mOffloadBroadcastQueue;

        // 创建 ActiveServices 对象&#xff0c;用于管理 ServiceRecord 对象
        mServices &#61; new ActiveServices(this);
        // 创建 ProviderMap 对象&#xff0c;用于管理 ContentProviderRecord 对象
        mProviderMap &#61; new ProviderMap(this);
        
        //得到ATM的对象&#xff0c;调用ATM.initialize
        mActivityTaskManager &#61; atm;
        mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController,
                DisplayThread.get().getLooper());
        //得到ATM的服务信息
        mAtmInternal &#61; LocalServices.getService(
ActivityTaskManagerInternal.class);

        //加入Watchdog的监控
        Watchdog.getInstance().addMonitor(this);
        Watchdog.getInstance().addThread(mHandler);
    }
}
</code></pre> 
<h3>4.5.3 [ActivityManagerService.java] start()</h3> 
<p><strong>说明&#xff1a;</strong>start中做了两件事</p> 
<p>1)启动 CPU 监控线程&#xff0c;在启动 CPU 监控线程之前&#xff0c;首先将进程复位</p> 
<p>2)注册电池状态服务和权限管理服务</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">private void start() {
    //1.移除所有的进程组
    removeAllProcessGroups();
    //启动 CPU 监控线程
    mProcessCpuThread.start();

    //2.注册电池状态和权限管理服务
    mBatteryStatsService.publish();
    mAppOpsService.publish(mContext);
    Slog.d(&#34;AppOps&#34;, &#34;AppOpsService published&#34;);
    LocalServices.addService(ActivityManagerInternal.class, new LocalService());
    mActivityTaskManager.onActivityManagerInternalAdded();
    mUgmInternal.onActivityManagerInternalAdded();
    mPendingIntentController.onActivityManagerInternalAdded();
    // Wait for the synchronized block started in mProcessCpuThread,
    // so that any other access to mProcessCpuTracker from main thread
    // will be blocked during mProcessCpuTracker initialization.
    try {
        mProcessCpuInitLatch.await();
    } catch (InterruptedException e) {
        Slog.wtf(TAG, &#34;Interrupted wait during start&#34;, e);
        Thread.currentThread().interrupt();
        throw new IllegalStateException(&#34;Interrupted wait during start&#34;);
    }
}
</code></pre> 
<h2>4.6 [SystemServer.java] setSystemProcess()</h2> 
<p><strong>说明&#xff1a;</strong>为系统进程设置应用程序实例并开始</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">private void startOtherServices() {
     //参考[4.6.1]
     Set up the Application instance for the system process and get started.
     mActivityManagerService.setSystemProcess();
 }
</code></pre> 
<h3>4.6.1 [ActivityManagerService.java] setSystemProcess()</h3> 
<p><strong>说明&#xff1a;</strong>AMS的setSystemProcess主要有五个主要的功能&#xff1a; </p> 
<ol><li>注册一些服务:包括 activity、procstats、meminfo、gfxinfo、dbinfo、permission、processinfo</li><li>获取package名为“android”的应用的 ApplicationInfo&#xff1b; </li><li>为ActivityThread 安装 system application相关信息,将framework-res.apk对应的ApplicationInfo安装到LoadedApk中的mApplicationInfo </li><li>为systemserver 主进程开辟一个ProcessRecord来维护进程的相关信息</li><li>AMS进程管理相关的操作。</li></ol>
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">public void setSystemProcess() {
  try {
      //1.注册一些服务到ServiceManager&#xff1a;包括 activity、procstats、meminfo、gfxinfo、dbinfo、permission、processinfo
      ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated&#61; */ true,
              DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);
      ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);
      ServiceManager.addService(&#34;meminfo&#34;, new MemBinder(this), /* allowIsolated&#61; */ false,
              DUMP_FLAG_PRIORITY_HIGH);
      ServiceManager.addService(&#34;gfxinfo&#34;, new GraphicsBinder(this));
      ServiceManager.addService(&#34;dbinfo&#34;, new DbBinder(this));
      if (MONITOR_CPU_USAGE) {
          ServiceManager.addService(&#34;cpuinfo&#34;, new CpuBinder(this),
                  /* allowIsolated&#61; */ false, DUMP_FLAG_PRIORITY_CRITICAL);
      }
      ServiceManager.addService(&#34;permission&#34;, new PermissionController(this));
      ServiceManager.addService(&#34;processinfo&#34;, new ProcessInfoService(this));

      //2.通过解析framework-res.apk里的AndroidManifest.xml获得ApplicationInfo
      ApplicationInfo info &#61; mContext.getPackageManager().getApplicationInfo(
              &#34;android&#34;, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);
      //3.为ActivityThread 安装 system application相关信息,将framework-res.apk对应的ApplicationInfo安装到LoadedApk中的mApplicationInfo
      mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());

       //4.为systemserver 主进程开辟一个ProcessRecord来维护进程的相关信息
      synchronized (this) {
          ProcessRecord app &#61; mProcessList.newProcessRecordLocked(info, info.processName,
                  false,
                  0,
                  new HostingRecord(&#34;system&#34;));
          app.setPersistent(true); //设置进程常驻
          app.pid &#61; MY_PID;  //为ProcessRecord赋值当前进程ID&#xff0c;即system_server进程ID
          app.getWindowProcessController().setPid(MY_PID);
          app.maxAdj &#61; ProcessList.SYSTEM_ADJ;
          app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
          mPidsSelfLocked.put(app); //将ProcessRecord放到mPidSelfLocked里统一管理
          mProcessList.updateLruProcessLocked(app, false, null);
          updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE);
      }
  } catch (PackageManager.NameNotFoundException e) {
      throw new RuntimeException(
              &#34;Unable to find android system package&#34;, e);
  }

  // Start watching app ops after we and the package manager are up and running.
  mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null,
          new IAppOpsCallback.Stub() {
              &#64;Override public void opChanged(int op, int uid, String packageName) {
                  if (op &#61;&#61; AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName !&#61; null) {
                      if (mAppOpsService.checkOperation(op, uid, packageName)
                              !&#61; AppOpsManager.MODE_ALLOWED) {
                          runInBackgroundDisabled(uid);
                      }
                  }
              }
          });
  }
</code></pre> 
<h2>4.7 完成ActivityManagerService 最后工作[ActivityManagerService.java] systemReady()</h2> 
<p><strong>说明&#xff1a; </strong>AMS的systemReady 处理分为三个阶段</p> 
<p><strong>阶段1&#xff1a;</strong>主要是调用一些关键服务的初始化函数&#xff0c; 然后杀死那些没有FLAG_PERSISTENT却在AMS启动完成前已经存在的进程&#xff0c; </p> 
<p>同时获取一些配置参数。 需要注意的是&#xff0c;由于只有Java进程才会向AMS注册&#xff0c;而一般的Native进程不会向AMS注册&#xff0c;因此此处杀死的进程是Java进程。</p> 
<p><strong>阶段2&#xff1a;</strong>执行goingCallback的处理&#xff0c;主要的工作就是通知一些服务可以进行systemReady、systemRunning相关的工作&#xff0c;并进行启动服务或应用进程的工作</p> 
<p><strong>阶段3&#xff1a;</strong>启动Home Activity&#xff0c;当启动结束&#xff0c;并发送ACTION_BOOT_COMPLETED广播时&#xff0c;AMS的启动过程告一段落</p> 
<p> </p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">   private void startOtherServices() {
        mActivityManagerService.systemReady(() -&gt; {xxxxxgoingCallbackxxx,
BOOT_TIMINGS_TRACE_LOG);
    }

    public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
        阶段1&#xff1a;关键服务的初始化
        阶段2&#xff1a;goingCallback处理
        阶段3&#xff1a;启动Home Activity&#xff0c;完成AMS启动
    }</code></pre> 
<p> </p> 
<h3>4.7.1 systemReady 阶段1</h3> 
<p><strong>说明&#xff1a;</strong>主要是调用一些关键服务的初始化函数&#xff0c; 然后杀死那些没有 FLAG_PERSISTENT 却在AMS启动完成前已经存在的进程&#xff0c; 同时获取一些配置参数。 需要注意的是&#xff0c;由于只有Java进程才会向AMS注册&#xff0c;而一般的Native进程不会向AMS注册&#xff0c;因此此处杀死的进程是Java进程。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code class="language-java">public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
    synchronized(this) {
        //第一次进入mSystemReady 为false&#xff0c;不走该流程
        if (mSystemReady) {
            if (goingCallback !&#61; null) {
                goingCallback.run();
            }
            return;
        }

        /** PowerSaveMode_start */
        Settings.System.putInt(mContext.getContentResolver(),
                ActivityTaskManagerService.SUPER_POWER_SAVE_MODE,
                ActivityTaskManagerService.SUPER_POWER_SAVE_MODE_NORMAL);
        /** PowerSaveMode_end */

        //这一部分主要是调用一些关键服务SystemReady相关的函数&#xff0c;
        //进行一些等待AMS初始完&#xff0c;才能进行的工作
        mActivityTaskManager.onSystemReady();
        mUserController.onSystemReady();
        mAppOpsService.systemReady();
        ...
        mSystemReady &#61; true;
    }

    try {
        sTheRealBuildSerial &#61; IDeviceIdentifiersPolicyService.Stub.asInterface(
                ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE))
                .getSerial();
    } catch (RemoteException e) {}

    ArrayList&lt;ProcessRecord&gt; procsToKill &#61; null;
    synchronized(mPidsSelfLocked) {
        //mPidsSelfLocked 中保存当前正在运行的所有进程的信息
        for (int i&#61;mPidsSelfLocked.size()-1; i&gt;&#61;0; i--) {
            ProcessRecord proc &#61; mPidsSelfLocked.valueAt(i);
            //在AMS启动完成前&#xff0c;如果没有FLAG_PERSISTENT标志的进程已经启动了&#xff0c;
            //就将这个进程加入到procsToKill中
            if (!isAllowedWhileBooting(proc.info)){
                if (procsToKill &#61;&#61; null) {
                    procsToKill &#61; new ArrayList&lt;ProcessRecord&gt;();
                }
                procsToKill.add(proc);
            }
        }
    }

    //收集已经启动的进程并杀死&#xff0c;排除persistent常驻进程
    synchronized(this) {
        //利用removeProcessLocked关闭procsToKill中的进程
        if (procsToKill !&#61; null) {
            for (int i&#61;procsToKill.size()-1; i&gt;&#61;0; i--) {
                ProcessRecord proc &#61; procsToKill.get(i);
                Slog.i(TAG, &#34;Removing system update proc: &#34; &#43; proc);
                mProcessList.removeProcessLocked(proc, true, false, &#34;system update done&#34;);
            }
        }
        //至此系统准备完毕
        mProcessesReady &#61; true;
    }
    ...
    mUgmInternal.onSystemReady();

}
</code></pre> 
<h3>4.7.2 systemReady 阶段2</h3> 
<p><strong>说明&#xff1a;</strong>执行goingCallback的处理&#xff0c;主要的工作就是通知一些服务可以进行systemReady相关的工作&#xff0c;并进行启动服务或应用进程的工作</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
    ...
    //1.调用参数传入的runnable对象&#xff0c;SystemServer中有具体的定义,参考[4.7.2.1]
    if (goingCallback !&#61; null) goingCallback.run();
    ...
    //调用所有系统服务的onStartUser接口
    mSystemServiceManager.startUser(currentUserId);
    synchronized (this) {
        //启动persistent为1的application所在的进程,参考[4.7.2.2]
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
        // Start up initial activity.
        mBooting &#61; true;
        ...
}
</code></pre> 
<p><strong>4.7.2.1 goingCallback.run()</strong></p> 
<p><strong>说明&#xff1a;</strong>监控Native的crash&#xff0c;启动WebView&#xff0c;执行一些服务的systemReady 和systemRunning方法</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">private void startOtherServices() {
  mActivityManagerService.systemReady(() -&gt; {
  //阶段 550
  mSystemServiceManager.startBootPhase(
              SystemService.PHASE_ACTIVITY_MANAGER_READY);
  ...
  //监控Native的crash
  mActivityManagerService.startObservingNativeCrashes();
  , BOOT_TIMINGS_TRACE_LOG);
  ...
  //启动WebView
  mWebViewUpdateService.prepareWebViewInSystemServer();
  //启动systemUI,参考[4.7.2.3]
  startSystemUi(context, windowManagerF);
  
  // 执行一系列服务的systemReady方法
  networkManagementF.systemReady();
  ipSecServiceF.systemReady();
  networkStatsF.systemReady();
  connectivityF.systemReady();
  networkPolicyF.systemReady(networkPolicyInitReadySignal);
  ...
  //阶段 600
  mSystemServiceManager.startBootPhase(
              SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
  
  //执行一系列服务的systemRunning方法
  locationF.systemRunning();
  countryDetectorF.systemRunning();
  networkTimeUpdaterF.systemRunning();
  inputManagerF.systemRunning();
  telephonyRegistryF.systemRunning();
  mediaRouterF.systemRunning();
  mmsServiceF.systemRunning();
  ...
}
</code></pre> 
<p><strong>4.7.2.2 [ActivityManagerService.java] startPersistentApps</strong></p> 
<p><strong>说明:</strong>启动persistent为1的application所在的进程</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">void startPersistentApps(int matchFlags) {
  if (mFactoryTest &#61;&#61; FactoryTest.FACTORY_TEST_LOW_LEVEL) return;
  
  synchronized (this) {
      try {
           //从PKMS中得到persistent为1的ApplicationInfo
          final List&lt;ApplicationInfo&gt; apps &#61; AppGlobals.getPackageManager()
                  .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();
          for (ApplicationInfo app : apps) {
               //由于framework-res.apk已经由系统启动&#xff0c;所以此处不再启动它
              if (!&#34;android&#34;.equals(app.packageName)) {
                   //addAppLocked中将启动application所在进程 
                  addAppLocked(app, null, false, null /* ABI override */);
              }
          }
      } catch (RemoteException ex) {
      }
  }
}
</code></pre> 
<p><strong>4.7.2.3 启动systemUI startSystemUi</strong></p> 
<p><strong>说明&#xff1a;</strong>启动system UI, 启动服务&#xff0c;服务名称”com.android.systemui/.SystemUIService”</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p><strong>[SystemServer.java]</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">private static void startSystemUi(Context context, WindowManagerService windowManager) {
  Intent intent &#61; new Intent();
  intent.setComponent(new ComponentName(&#34;com.android.systemui&#34;,
          &#34;com.android.systemui.SystemUIService&#34;));
  intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
  //Slog.d(TAG, &#34;Starting service: &#34; &#43; intent);
  context.startServiceAsUser(intent, UserHandle.SYSTEM);
  windowManager.onSystemUiStarted();
}
</code></pre> 
<h3>4.7.3 systemReady 阶段3</h3> 
<p><strong>说明&#xff1a;</strong>启动Home Activity&#xff0c;当启动结束&#xff0c;并发送ACTION_BOOT_COMPLETED广播时&#xff0c;AMS的启动过程告一段落</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">public  void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {
  ...
  //1.通过ATM&#xff0c;启动Home Activity&#xff0c;参考[4.7.3.1]
  mAtmInternal.startHomeOnAllDisplays(currentUserId, &#34;systemReady&#34;);
  ...
  //2.发送一些广播消息
  try {
      //system发送广播 ACTION_USER_STARTED &#61; &#34;android.intent.action.USER_STARTED&#34;;
      Intent intent &#61; new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
              | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
      broadcastIntentLocked(null, null, intent,
              null, null, 0, null, null, null, OP_NONE,
              null, false, false, MY_PID, SYSTEM_UID, callingUid, callingPid,
              currentUserId);
      //system发送广播 ACTION_USER_STARTING&#61; &#34;android.intent.action.USER_STARTING&#34;;
      intent &#61; new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
      broadcastIntentLocked(null, null, intent,
              null, new IIntentReceiver.Stub() {
                  &#64;Override
                  public void performReceive(Intent intent, int resultCode, String data,
                          Bundle extras, boolean ordered, boolean sticky, int sendingUser)
                          throws RemoteException {
                  }
              }, 0, null, null,
              new String[] {INTERACT_ACROSS_USERS}, OP_NONE,
              null, true, false, MY_PID, SYSTEM_UID, callingUid, callingPid,
              UserHandle.USER_ALL);
      } catch (Throwable t) {
          Slog.wtf(TAG, &#34;Failed sending first user broadcasts&#34;, t);
      } finally {
          Binder.restoreCallingIdentity(ident);
  }
}
</code></pre> 
<p><strong>4.7.3.1 [ActivityTaskManagerService] startHomeOnAllDisplays</strong></p> 
<p><strong>说明&#xff1a;</strong>启动Home Activity</p> 
<p><strong>源码&#xff1a;</strong></p> 
<p><strong>[ActivityTaskManagerService.java]</strong></p> 
<pre class="has"><code class="language-java">public boolean startHomeOnAllDisplays(int userId, String reason) {
    synchronized (mGlobalLock) {
        //调用RootActivityContainer的startHomeOnAllDisplays()&#xff0c;最终到startHomeOnDisplay()
        return mRootActivityContainer.startHomeOnAllDisplays(userId, reason);
    }
}
</code></pre> 
<p><strong>[RootActivityContainer.java]</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">boolean startHomeOnDisplay(int userId, String reason, int displayId, boolean allowInstrumenting,
        boolean fromHomeKey) {
    // Fallback to top focused display if the displayId is invalid.
    if (displayId &#61;&#61; INVALID_DISPLAY) {
        displayId &#61; getTopDisplayFocusedStack().mDisplayId;
    }

    Intent homeIntent &#61; null;
    ActivityInfo aInfo &#61; null;
    if (displayId &#61;&#61; DEFAULT_DISPLAY) {
        //home intent有CATEGORY_HOME
        homeIntent &#61; mService.getHomeIntent();
         //根据intent中携带的ComponentName&#xff0c;利用PKMS得到ActivityInfo
        aInfo &#61; resolveHomeActivity(userId, homeIntent);
    } else if (shouldPlaceSecondaryHomeOnDisplay(displayId)) {
        Pair&lt;ActivityInfo, Intent&gt; info &#61;
                RootActivityContainerMifavor.resolveSecondaryHomeActivityPcMode(this, userId, displayId);
        aInfo &#61; info.first;
        homeIntent &#61; info.second;
    }
    if (aInfo &#61;&#61; null || homeIntent &#61;&#61; null) {
        return false;
    }

    if (!canStartHomeOnDisplay(aInfo, displayId, allowInstrumenting)) {
        return false;
    }

    // Updates the home component of the intent.
    homeIntent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
    homeIntent.setFlags(homeIntent.getFlags() | FLAG_ACTIVITY_NEW_TASK);
    // Updates the extra information of the intent.
    if (fromHomeKey) {
        homeIntent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, true);
    }
    // Update the reason for ANR debugging to verify if the user activity is the one that
    // actually launched.
    final String myReason &#61; reason &#43; &#34;:&#34; &#43; userId &#43; &#34;:&#34; &#43; UserHandle.getUserId(
            aInfo.applicationInfo.uid) &#43; &#34;:&#34; &#43; displayId;
    //启动Home Activity--Luncher
    mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,
            displayId);
    return true;
}
</code></pre> 
<h1>5.Android10中AMS的一些变化</h1> 
<p>在Android 10 中安卓为了将来的方案更设计更加明确&#xff0c;对AMS做了很多修改,安卓的最终目的是把activity 和window融合&#xff0c;在Android 10.0上只是简单的代码路径变化&#xff0c;整体逻辑还是跟Android 9.0 类似</p> 
<p><strong>Android 10中引入了ActivityTaskManager--ATM的概念。</strong></p> 
<h2>5.1 Android P 的冗余问题</h2> 
<p>Android 9.0 及以前版本&#xff0c;Acitivity 管理由AMS 和WMS 协作完成&#xff0c;导致在AMS 和WMS 中都有相似功能的实体&#xff0c;除了大量的代码冗余之外&#xff0c;二者之间的协作也非常困难。</p> 
<p> <img alt="" class="has" height="267" src="https://img-blog.csdnimg.cn/20191215174712349.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" width="937" /></p> 
<h2>5.2 Android 10的变化</h2> 
<p>  从Android 10.0 的代码变更看&#xff0c;google 最终的目的是把activity 和window融合&#xff0c;目前发布的版本虽然做了大量的代码变更&#xff0c;但和P 之前的版本的流程变化不大&#xff0c;</p> 
<p>目前只是简单的把代码整理到一起了&#xff0c;还属于中间状态&#xff0c;按android文档介绍&#xff0c;完全融合在M 甚至更靠后的版本才能完成。</p> 
<p>      目前已完成的工作&#xff1a;</p> 
<ul><li>把AMS 下面只和activity 管理相关的代码移到WMS的目录下&#xff0c;actvityStack、activityRecord 等文件&#xff0c;全部移到WMS 目录下&#xff0c;和window 统一管理.</li><li>AMS 中部分文件拆分&#xff0c;把原来activity和其他组件融合在一起处理的文件进行拆分&#xff0c;activity 相关部分单独拆分&#xff0c;移到WMS 中统一管理。比如ActivityManagerService.java 拆分成了ActivityManagerService.java 和ActivityTaskManagerService.java 两个文件&#xff0c;activity 的启动由ActivityTaskManagerService.java 负责&#xff1a;</li><li>因为Activity 和window的管理统一由WMS 完成&#xff0c;不再需要之前的DispayWindowController、stackWindowController 来居中协调&#xff0c;可以把display、stack、task 等统一管理。最终要做到完全融合&#xff0c;以stack 为例&#xff0c;完成后会把taskstack的功能完全融合进activityStack&#xff0c;目前只做到了在activityStack 中包含taskstack。创建、管理流程也随之发生变化。</li></ul>
<h1>6.总结</h1> 
<p><strong>AMS的启动主要经历了如下几个阶段&#xff1a;</strong></p> 
<ul><li>为SystemServer进程创建Android运行环境&#xff0c;例如System Context</li><li>启动AMS&#xff0c;做一些初始化的工作</li><li>将SystemServer进程纳入到AMS的进程管理体系中</li><li>AMS启动完成&#xff0c;通知服务或应用完成后续的工作&#xff0c;调用一些服务的systemReady()方法中&#xff0c;</li><li>启动Luncher&#xff0c;完成AMS的启动工作</li></ul>
<p> </p> 