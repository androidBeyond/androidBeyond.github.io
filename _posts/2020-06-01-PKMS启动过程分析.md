---
layout:     post
title:      Android10应用启动与进程创建关系分析
subtitle:   android中弱化了进程的概念，取而代之的是四大组件，本篇文章我们就来学习一下应用和进程的关系
date:       2020-05-16
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - Android
    - framework
---
 

<h1><strong>1.概述</strong></h1> 
<p>    PackageManagerService是Android系统核心服务之一&#xff0c;在Android中的非常重要&#xff0c;主要负责的功能如下&#xff1a;</p> 
<ol><li> <p>解析 AndroidManifest.xml&#xff0c;主要包括AndroidManifest中节点信息的解析和target-name的分析和提炼</p> </li><li> <p>扫描本地文件&#xff0c;主要针对apk&#xff0c;主要是系统应用、本地安装应用等等。这部分会在下面仔细讲解。</p> </li><li> <p>管理本地apk&#xff0c;主要包括安装、删除等等。</p> </li></ol>
<p>下面称PackageManagerService为PKMS。</p> 
<p> </p> 
<h1><strong>2.核心源码</strong></h1> 
<pre class="has"><code>/frameworks/base/core/java/android/app/ApplicationPackageManager.java
/frameworks/base/services/java/com/android/server/SystemServer.java
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
/frameworks/base/services/core/java/com/android/server/pm/PackageDexOptimizer.java
/frameworks/base/services/core/java/com/android/server/pm/Installer.java
/frameworks/base/services/core/java/com/android/server/pm/Settings.java
/frameworks/base/services/core/java/com/android/server/pm/permission/BasePermission.java
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
/frameworks/base/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
/frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
/frameworks/base/core/java/android/content/pm/IPackageManager.aidl
/frameworks/base/core/java/android/content/pm/PackageManager.java
/frameworks/base/core/java/com/android/server/SystemConfig.java</code></pre> 
<h1><strong>3.架构</strong></h1> 
<h2><strong>3.1 PKMS 启动过程</strong></h2> 
<p><strong><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111222701346.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></strong></p> 
<h2><strong>3.2 PKMS 继承关系</strong></h2> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111222737581.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h2><strong>3.3 权限管理</strong></h2> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111222809308.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h2><strong>3.4 APK扫描</strong></h2> 
<p>    扫描APK的AndroidManifest.xml中的各个标签信息&#xff0c;</p> 
<p>例如&#34;application&#34;、&#34;overlay&#34;、&#34;permission&#34;、&#34;uses-permission&#34;等信息。</p> 
<p>再针对各个标签的子标签进程扫描&#xff0c;</p> 
<p>例如application会扫描&#34;activity&#34;、&#34;receiver&#34;、&#34;service&#34;、&#34;provider&#34;等信息</p> 
<p>后面会详细讲解扫描过程</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111222841346.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h1><strong>4.启动过程</strong></h1> 
<h2>4.1 启动过程</h2> 
<p>PKMS服务由SystemServer进行启动&#xff0c;在SystemServer中startBootstrapServices()启动PKMS服务,再调用startOtherServices()进行dex优化&#xff0c;磁盘管理等功能&#xff0c;并让PKMS进入systemready状态。</p> 
<p>启动调用栈如下图所示&#xff1a;</p> 
<p> <img alt="" class="has" src="https://img-blog.csdnimg.cn/2020011122290763.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<p><strong>4.1.1 [SystemServer.java] startBootstrapServices()</strong></p> 
<p><strong>说明&#xff1a;</strong>startBootstrapServices()首先启动Installer服务&#xff0c;也就是安装器&#xff0c;随后判断当前的设备是否处于加密状态&#xff0c;如果是则只是解析核心应用&#xff0c;接着调用PackageManagerService的静态方法main来创建pms对象</p> 
<p>(1)启动Installer服务</p> 
<p>(2)获取设备是否加密(手机设置密码)&#xff0c;如果设备加密了&#xff0c;则只解析&#34;core&#34;应用</p> 
<p>(3)调用PKMS main方法初始化PackageManagerService&#xff0c;其中调用PackageManagerService()构造函数创建了PKMS对象</p> 
<p>(4)如果设备没有加密&#xff0c;操作它。管理A/B OTA dexopting。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>
private void startBootstrapServices() {
    ...
    //(1)启动Installer
    //阻塞等待installd完成启动&#xff0c;以便有机会创建具有适当权限的关键目录&#xff0c;如/data/user。
    //我们需要在初始化其他服务之前完成此任务。
    Installer installer &#61; mSystemServiceManager.startService(Installer.class);
    mActivityManagerService.setInstaller(installer);
    ...
    //(2)获取设别是否加密(手机设置密码)&#xff0c;如果设备加密了&#xff0c;则只解析&#34;core&#34;应用&#xff0c;mOnlyCore &#61; true&#xff0c;后面会频繁使用该变量进行条件判断
    String cryptState &#61; VoldProperties.decrypt().orElse(&#34;&#34;);
    if (ENCRYPTING_STATE.equals(cryptState)) {
        Slog.w(TAG, &#34;Detected encryption in progress - only parsing core apps&#34;);
        mOnlyCore &#61; true;
    } else if (ENCRYPTED_STATE.equals(cryptState)) {
        Slog.w(TAG, &#34;Device encrypted - only parsing core apps&#34;);
        mOnlyCore &#61; true;
    }
    
    //(3)调用main方法初始化PackageManagerService&#xff0c;参考[4.1.3]
    mPackageManagerService &#61; PackageManagerService.main(mSystemContext, installer,
                mFactoryTestMode !&#61; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);

    //PKMS是否是第一次启动
    mFirstBoot &#61; mPackageManagerService.isFirstBoot();
    
    //(4)如果设备没有加密&#xff0c;操作它。管理A/B OTA dexopting。
    if (!mOnlyCore) {
        boolean disableOtaDexopt &#61; SystemProperties.getBoolean(&#34;config.disable_otadexopt&#34;,
                false);
        OtaDexoptService.main(mSystemContext, mPackageManagerService);
    }
    ...
}</code></pre> 
<p><strong>4.1.2 [SystemServer.java] </strong></p> 
<p><strong>startOtherServices()</strong></p> 
<p><strong>说明&#xff1a;</strong></p> 
<p>(5)执行 updatePackagesIfNeeded &#xff0c;完成dex优化&#xff1b;</p> 
<p>(6)执行 performFstrimIfNeeded &#xff0c;完成磁盘维护&#xff1b;</p> 
<p>(7)调用systemReady&#xff0c;准备就绪。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>
private void startOtherServices() {
    ...
    if (!mOnlyCore) {
        ...
        //(5)如果设备没有加密&#xff0c;执行performDexOptUpgrade&#xff0c;完成dex优化&#xff1b;[参考4.3]
        mPackageManagerService.updatePackagesIfNeeded();
    }
    ...
    //(6) 最终执行performFstrim&#xff0c;完成磁盘维护,[参考4.4]
    mPackageManagerService.performFstrimIfNeeded();
    ...
    //(7)PKMS准备就绪,[参考4.5]
    mPackageManagerService.systemReady();
    ...
}</code></pre> 
<p><strong>4.1.3 [PackageManagerService.java] main()</strong></p> 
<p><strong>说明&#xff1a;</strong></p> 
<p>main函数主要工作&#xff1a;</p> 
<p>(1)检查Package编译相关系统属性</p> 
<p>(2)调用PackageManagerService构造方法</p> 
<p>(3)启用部分应用服务于多用户场景</p> 
<p>(4)往ServiceManager中注册”package”和”package_native”。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public static PackageManagerService main(Context context, Installer installer,
        boolean factoryTest, boolean onlyCore) {
    // (1)检查Package编译相关系统属性
    PackageManagerServiceCompilerMapping.checkProperties();

    //(2)调用PackageManagerService构造方法,参考[4.2]
    PackageManagerService m &#61; new PackageManagerService(context, installer,
            factoryTest, onlyCore);
    //(3)启用部分应用服务于多用户场景
    m.enableSystemUserPackages();
    
    //(4)往ServiceManager中注册”package”和”package_native”。
    ServiceManager.addService(&#34;package&#34;, m);
    final PackageManagerNative pmn &#61; m.new PackageManagerNative();
    ServiceManager.addService(&#34;package_native&#34;, pmn);
    return m;
}</code></pre> 
<p>PKMS初始化时的核心部分为PackageManagerService()构造函数的内容&#xff0c;我们下面就来分析该流程</p> 
<p> </p> 
<p><strong>4.2 PKMS构造函数分析</strong></p> 
<p>PKMS的构造函数中由两个重要的锁(mInstallLock、mPackages) 和5个阶段构成&#xff0c;下面会详细的来分析这些内容。</p> 
<p> </p> 
<p><strong>mInstallLock &#xff1a;</strong>用来保护所有安装apk的访问权限&#xff0c;此操作通常涉及繁重的磁盘数据读写等操作&#xff0c;并且是单线程操作&#xff0c;故有时候会处理很慢。</p> 
<p>此锁不会在已经持有mPackages锁的情况下火的&#xff0c;反之&#xff0c;在已经持有mInstallLock锁的情况下&#xff0c;立即获取mPackages是安全的</p> 
<p> </p> 
<p><strong>mPackages&#xff1a;</strong>用来解析内存中所有apk的package信息及相关状态。</p> 
<p> </p> 
<p><strong>5个阶段&#xff1a;</strong></p> 
<p><strong>阶段1&#xff1a;</strong>BOOT_PROGRESS_PMS_START</p> 
<p><strong>阶段2&#xff1a;</strong>BOOT_PROGRESS_PMS_SYSTEM_SCAN_START</p> 
<p><strong>阶段3&#xff1a;</strong>BOOT_PROGRESS_PMS_DATA_SCAN_START</p> 
<p><strong>阶段4&#xff1a;</strong>BOOT_PROGRESS_PMS_SCAN_END</p> 
<p><strong>阶段5&#xff1a;</strong>BOOT_PROGRESS_PMS_READY</p> 
<p>    PKMS服务也是通过binder进行通信&#xff0c;IPackageManager.aidl由工具转换后自动生成binder的服务端IPackageManager.Stub和客户端IPackageManager.Stub.Proxy&#xff0c;具体关系如图&#xff1a;</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111223023202.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<p><strong>Binder服务端&#xff1a;</strong>PackageManagerService继承于IPackageManager.Stub&#xff1b;</p> 
<p><strong>Binder客户端&#xff1a;</strong>ApplicationPackageManager(简称APM)的成员变量mPM继承于IPackageManager.Stub.Proxy; 本身APM是继承于PackageManager对象。</p> 
<p> </p> 
<p><strong>4.2.1 [PackageManagerService.java]</strong></p> 
<p><strong>说明&#xff1a;</strong>IPackageManager.Stub是IPackageManager.aidl自动生成的&#xff0c;正好也说明了PKMS是service端的&#xff0c;通过binder交互</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public class PackageManagerService extends IPackageManager.Stub
        implements PackageSender {
}</code></pre> 
<p> </p> 
<p><strong>4.2.2 [PackageManagerService.java]   PackageManagerService()</strong></p> 
<p><strong>说明&#xff1a;</strong>PackageManagerService构造函数</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public PackageManagerService(Context context, Installer installer,
        boolean factoryTest, boolean onlyCore) {
        ...
        //阶段1&#xff1a;BOOT_PROGRESS_PMS_START&#xff0c; 参考[4.2.3]
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,
                SystemClock.uptimeMillis());

        //阶段2&#xff1a;BOOT_PROGRESS_PMS_SYSTEM_SCAN_START ,参考[4.2.4]
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,
                    startTime);
        ...
        
        //阶段3&#xff1a;BOOT_PROGRESS_PMS_DATA_SCAN_START ,参考[4.2.5]
        if (!mOnlyCore) {
                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,
                        SystemClock.uptimeMillis());
        }
        ...
        //阶段4&#xff1a;BOOT_PROGRESS_PMS_SCAN_END ,参考[4.2.6]
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,
                    SystemClock.uptimeMillis());
        ...
        //阶段5&#xff1a;BOOT_PROGRESS_PMS_READY,参考[4.2.7]
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,
                    SystemClock.uptimeMillis());
}</code></pre> 
<p> </p> 
<p><strong>4.2.3 阶段1&#xff1a;</strong><strong>BOOT_PROGRESS_PMS_START</strong></p> 
<p><strong>主要工作&#xff1a;</strong></p> 
<p>(1)构造 DisplayMetrics &#xff0c;保存分辨率等相关信息&#xff1b;</p> 
<p>(2)创建Installer对象&#xff0c;与installd交互&#xff1b;</p> 
<p>(3)创建mPermissionManager对象&#xff0c;进行权限管理&#xff1b;</p> 
<p>(4)构造Settings类&#xff0c;保存安装包信息&#xff0c;清除路径不存在的孤立应用&#xff0c;主要涉及/data/system/目录的packages.xml&#xff0c;packages-backup.xml&#xff0c;packages.list&#xff0c;packages-stopped.xml&#xff0c;packages-stopped-backup.xml等文件。</p> 
<p>(5)构造PackageDexOptimizer及DexManager类&#xff0c;处理dex优化&#xff1b;</p> 
<p>(6)创建SystemConfig实例&#xff0c;获取系统配置信息&#xff0c;配置共享lib库&#xff1b;</p> 
<p>(7)创建PackageManager的handler线程&#xff0c;循环处理外部安装相关消息。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public PackageManagerService(...) {
    LockGuard.installLock(mPackages, LockGuard.INDEX_PACKAGES);
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,
                SystemClock.uptimeMillis());
    mContext &#61; context;

    mFactoryTest &#61; factoryTest; // 一般为false&#xff0c;即非工厂生产模式
    mOnlyCore &#61; onlyCore; //标记是否只加载核心服务
    mMetrics &#61; new DisplayMetrics(); // 分辨率配置
    mInstaller &#61; installer; //保存installer对象

    //创建提供服务/数据的子组件。这里的顺序很重要,使用到了两个重要的同步锁&#xff1a;mInstallLock、mPackages
    synchronized (mInstallLock) {
    synchronized (mPackages) {
        // 公开系统组件使用的私有服务
        // 本地服务
        LocalServices.addService(
                PackageManagerInternal.class, new PackageManagerInternalImpl());
        // 多用户管理服务
        sUserManager &#61; new UserManagerService(context, this,
                new UserDataPreparer(mInstaller, mInstallLock, mContext, mOnlyCore), mPackages);
        mComponentResolver &#61; new ComponentResolver(sUserManager,
                LocalServices.getService(PackageManagerInternal.class),
                mPackages);
        // 权限管理服务
        mPermissionManager &#61; PermissionManagerService.create(context,
                mPackages /*externalLock*/);
        mDefaultPermissionPolicy &#61; mPermissionManager.getDefaultPermissionGrantPolicy();
        
        //创建Settings对象
        mSettings &#61; new Settings(Environment.getDataDirectory(),
                mPermissionManager.getPermissionSettings(), mPackages);
    }
    }
    
    // 添加system, phone, log, nfc, bluetooth, shell&#xff0c;se&#xff0c;networkstack 这8种shareUserId到mSettings&#xff1b;
    mSettings.addSharedUserLPw(&#34;android.uid.system&#34;, Process.SYSTEM_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.phone&#34;, RADIO_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.log&#34;, LOG_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.nfc&#34;, NFC_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.bluetooth&#34;, BLUETOOTH_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.shell&#34;, SHELL_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.se&#34;, SE_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    mSettings.addSharedUserLPw(&#34;android.uid.networkstack&#34;, NETWORKSTACK_UID,
            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
    ...
    // DexOpt优化
    mPackageDexOptimizer &#61; new PackageDexOptimizer(installer, mInstallLock, context,
                &#34;*dexopt*&#34;);
    mDexManager &#61; new DexManager(mContext, this, mPackageDexOptimizer, installer, mInstallLock);
    // ART虚拟机管理服务
    mArtManagerService &#61; new ArtManagerService(mContext, this, installer, mInstallLock);
    mMoveCallbacks &#61; new MoveCallbacks(FgThread.get().getLooper());

    mViewCompiler &#61; new ViewCompiler(mInstallLock, mInstaller);
    // 权限变化监听器
    mOnPermissionChangeListeners &#61; new OnPermissionChangeListeners(
            FgThread.get().getLooper());
    mProtectedPackages &#61; new ProtectedPackages(mContext);
    mApexManager &#61; new ApexManager(context);
    
    // 获取默认分辨率
    getDefaultDisplayMetrics(context, mMetrics);
    //拿到SystemConfig()的对象&#xff0c;其中会调用SystemConfig的readPermissions()完成权限的读取&#xff0c;参考[5 权限管理]
    SystemConfig systemConfig &#61; SystemConfig.getInstance();
    synchronized (mInstallLock) {
            // writer
            synchronized (mPackages) {
                // 启动&#34;PackageManager&#34;线程&#xff0c;负责apk的安装、卸载
                mHandlerThread &#61; new ServiceThread(TAG,
                        Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);
                mHandlerThread.start();
                // 应用handler
                mHandler &#61; new PackageHandler(mHandlerThread.getLooper());
                // 进程记录handler
                mProcessLoggingHandler &#61; new ProcessLoggingHandler();
                // Watchdog监听ServiceThread是否超时&#xff1a;10分钟
                Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);
                // Instant应用注册
                mInstantAppRegistry &#61; new InstantAppRegistry(this);
                 // 共享lib库配置
                ArrayMap&lt;String, SystemConfig.SharedLibraryEntry&gt; libConfig
                        &#61; systemConfig.getSharedLibraries();
                final int builtInLibCount &#61; libConfig.size();
                for (int i &#61; 0; i &lt; builtInLibCount; i&#43;&#43;) {
                    String name &#61; libConfig.keyAt(i);
                    SystemConfig.SharedLibraryEntry entry &#61; libConfig.valueAt(i);
                    addBuiltInSharedLibraryLocked(entry.filename, name);
                }
                ...
                // 读取安装相关SELinux策略
                SELinuxMMAC.readInstallPolicy();

                // 返回栈加载
                FallbackCategoryProvider.loadFallbacks();
                //读取并解析/data/system下的XML文件
                mFirstBoot &#61; !mSettings.readLPw(sUserManager.getUsers(false));

                // 清理代码路径不存在的孤立软件包
                final int packageSettingCount &#61; mSettings.mPackages.size();
                for (int i &#61; packageSettingCount - 1; i &gt;&#61; 0; i--) {
                    PackageSetting ps &#61; mSettings.mPackages.valueAt(i);
                    if (!isExternal(ps) &amp;&amp; (ps.codePath &#61;&#61; null || !ps.codePath.exists())
                            &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) !&#61; null) {
                        mSettings.mPackages.removeAt(i);
                        mSettings.enableSystemPackageLPw(ps.name);
                    }
                }

                // 如果不是首次启动&#xff0c;也不是CORE应用&#xff0c;则拷贝预编译的DEX文件
                if (!mOnlyCore &amp;&amp; mFirstBoot) {
                    requestCopyPreoptedFiles();
                }
                ...
            } // synchronized (mPackages)
        }
}</code></pre> 
<p> </p> 
<p><strong>readLPw()会扫描下面5个文件</strong></p> 
<p>1) &#34;/data/system/packages.xml&#34;</p> 
<p>2) &#34;/data/system/packages-backup.xml&#34;</p> 
<p>3) &#34;/data/system/packages.list&#34;</p> 
<p>4) &#34;/data/system/packages-stopped.xml&#34;</p> 
<p>5) &#34;/data/system/packages-stopped-backup.xml&#34;</p> 
<p> </p> 
<p>个文件共分为三组&#xff0c;简单的作用描述如下&#xff1a;</p> 
<ol><li> <p><strong>packages.xml&#xff1a;</strong>PKMS 扫描完目标文件夹后会创建该文件。当系统进行程序安装、卸载和更新等操作时&#xff0c;均会更新该文件。该文件保存了系统中与 package 相关的一些信息。</p> </li><li> <p><strong>packages.list&#xff1a;</strong>描述系统中存在的所有非系统自带的 APK 的信息。当这些程序有变动时&#xff0c;PKMS 就会更新该文件。</p> </li><li> <p><strong>packages-stopped.xml&#xff1a;</strong>从系统自带的设置程序中进入应用程序页面&#xff0c;然后在选择强制停止&#xff08;ForceStop&#xff09;某个应用时&#xff0c;系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的 Package 的信息。</p> </li></ol>
<p>这些目录的指向&#xff0c;都在Settings中的构造函数完成&#xff0c; 如下所示&#xff0c;得到目录后调用readLPw()进行扫描</p> 
<pre class="has"><code>Settings(File dataDir, PermissionSettings permission,
        Object lock) {
    mLock &#61; lock;
    mPermissions &#61; permission;
    mRuntimePermissionsPersistence &#61; new RuntimePermissionPersistence(mLock);

    mSystemDir &#61; new File(dataDir, &#34;system&#34;);  //mSystemDir指向目录&#34;/data/system&#34;
    mSystemDir.mkdirs();  //创建 &#34;/data/system&#34;
    //设置权限
    FileUtils.setPermissions(mSystemDir.toString(),
            FileUtils.S_IRWXU|FileUtils.S_IRWXG
            |FileUtils.S_IROTH|FileUtils.S_IXOTH,
            -1, -1);

    //(1)指向目录&#34;/data/system/packages.xml&#34;
    mSettingsFilename &#61; new File(mSystemDir, &#34;packages.xml&#34;);
    //(2)指向目录&#34;/data/system/packages-backup.xml&#34;
    mBackupSettingsFilename &#61; new File(mSystemDir, &#34;packages-backup.xml&#34;);
    //(3)指向目录&#34;/data/system/packages.list&#34;
    mPackageListFilename &#61; new File(mSystemDir, &#34;packages.list&#34;);
    FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID);
    //(4)指向目录&#34;/data/system/packages-stopped.xml&#34;
    mStoppedPackagesFilename &#61; new File(mSystemDir, &#34;packages-stopped.xml&#34;);
    //(5)指向目录&#34;/data/system/packages-stopped-backup.xml&#34;
    mBackupStoppedPackagesFilename &#61; new File(mSystemDir, &#34;packages-stopped-backup.xml&#34;);
}</code></pre> 
<p>解析上面这个几个xml的内容&#xff0c;建立对应的数据结构</p> 
<pre class="has"><code>[Settings.java]
boolean readLPw(&#64;NonNull List&lt;UserInfo&gt; users) {
    FileInputStream str &#61; null;
    ...
    if (str &#61;&#61; null) {
        str &#61; new FileInputStream(mSettingsFilename);
    }
    //解析&#34;/data/system/packages.xml&#34;
    XmlPullParser parser &#61; Xml.newPullParser();
    parser.setInput(str, StandardCharsets.UTF_8.name());

    int type;
    while ((type &#61; parser.next()) !&#61; XmlPullParser.START_TAG
            &amp;&amp; type !&#61; XmlPullParser.END_DOCUMENT) {
        ;
    }
    int outerDepth &#61; parser.getDepth();
    while ((type &#61; parser.next()) !&#61; XmlPullParser.END_DOCUMENT
            &amp;&amp; (type !&#61; XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) {
        if (type &#61;&#61; XmlPullParser.END_TAG || type &#61;&#61; XmlPullParser.TEXT) {
            continue;
        }
        //根据XML的各个节点进行各种操作&#xff0c;例如读取权限、shared-user等
        String tagName &#61; parser.getName();
        if (tagName.equals(&#34;package&#34;)) {
            readPackageLPw(parser);
        } else if (tagName.equals(&#34;permissions&#34;)) {
            mPermissions.readPermissions(parser);
        } else if (tagName.equals(&#34;permission-trees&#34;)) {
            mPermissions.readPermissionTrees(parser);
        } else if (tagName.equals(&#34;shared-user&#34;)) {
            readSharedUserLPw(parser);
        }...
    }
    str.close();
    ...
    return true;
}</code></pre> 
<p><strong>说明&#xff1a;</strong>创建 SharedUserSetting 对象并添加到 Settings 的成员变量 mSharedUsers 中&#xff0c;在 Android 系统中&#xff0c;多个 package 通过设置 sharedUserId 属性可以运行在同一个进程&#xff0c;共享同一个 UID</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>mSettings.addSharedUserLPw(&#34;android.uid.system&#34;, //字符串
                           Process.SYSTEM_UID, //系统进程使用的用户id&#xff0c;值为1000
                           ApplicationInfo.FLAG_SYSTEM, //标志系统 Package
                           ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); //特权系统应用

SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) {
    //mSharedUsers 是一个 HashMap&#xff0c;key 为字符串&#xff0c;值为 SharedUserSetting 对象
    SharedUserSetting s &#61; mSharedUsers.get(name);
    if (s !&#61; null) {
        if (s.userId &#61;&#61; uid) {
            return s;
        }
        PackageManagerService.reportSettingsProblem(Log.ERROR,
                &#34;Adding duplicate shared user, keeping first: &#34; &#43; name);
        return null;
    }
    //创建一个新的 SharedUserSetting 对象&#xff0c;并设置的 userId 为 uid
    s &#61; new SharedUserSetting(name, pkgFlags, pkgPrivateFlags);
    s.userId &#61; uid;
    if (registerExistingAppIdLPw(uid, s, name)) {
        mSharedUsers.put(name, s);//将name与s键值对添加到mSharedUsers中保存
        return s;
    }
    return null;
}</code></pre> 
<p><strong>4.2.4 阶段2&#xff1a;</strong><strong>BOOT_PROGRESS_PMS_SYSTEM_SCAN_START</strong></p> 
<p><strong>主要工作&#xff1a;</strong></p> 
<p>(1)从init.rc中获取环境变量BOOTCLASSPATH和SYSTEMSERVERCLASSPATH&#xff1b;</p> 
<p>(2)对于旧版本升级的情况&#xff0c;将安装时获取权限变更为运行时申请权限&#xff1b;</p> 
<p>(3)扫描system/vendor/product/odm/oem等目录的priv-app、app、overlay包&#xff1b;</p> 
<p>(4)清除安装时临时文件以及其他不必要的信息。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            // 记录扫描开始时间
            long startTime &#61; SystemClock.uptimeMillis();
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,
                    startTime);
            
            //获取环境变量&#xff0c;init.rc
            final String bootClassPath &#61; System.getenv(&#34;BOOTCLASSPATH&#34;);
            final String systemServerClassPath &#61; System.getenv(&#34;SYSTEMSERVERCLASSPATH&#34;);
            ...
            // 获取system/framework目录
            File frameworkDir &#61; new File(Environment.getRootDirectory(), &#34;framework&#34;);
            // 获取内部版本
            final VersionInfo ver &#61; mSettings.getInternalVersion();
            // 判断fingerprint是否有更新
            mIsUpgrade &#61; !Build.FINGERPRINT.equals(ver.fingerprint);
            ...
            // 对于Android M之前版本升级上来的情况&#xff0c;需将系统应用程序权限从安装升级到运行时
            mPromoteSystemApps &#61;
                    mIsUpgrade &amp;&amp; ver.sdkVersion &lt;&#61; Build.VERSION_CODES.LOLLIPOP_MR1;
            // 对于Android N之前版本升级上来的情况&#xff0c;需像首次启动一样处理package
            mIsPreNUpgrade &#61; mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;
            mIsPreNMR1Upgrade &#61; mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;
            mIsPreQUpgrade &#61; mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.Q;
            // 在扫描之前保存预先存在的系统package的名称&#xff0c;不希望自动为新系统应用授予运行时权限
            if (mPromoteSystemApps) {
                Iterator&lt;PackageSetting&gt; pkgSettingIter &#61; mSettings.mPackages.values().iterator();
                while (pkgSettingIter.hasNext()) {
                    PackageSetting ps &#61; pkgSettingIter.next();
                    if (isSystemApp(ps)) {
                        mExistingSystemPackages.add(ps.name);
                    }
                }
            }
            // 准备解析package的缓存
            mCacheDir &#61; preparePackageParserCache();
            // 设置flag&#xff0c;而不在扫描安装时更改文件路径
            int scanFlags &#61; SCAN_BOOTING | SCAN_INITIAL;
            ...
            //扫描以下路径&#xff1a;
            /vendor/overlay、/product/overlay、/product_services/overlay、/odm/overlay、/oem/overlay、/system/framework
            /system/priv-app、/system/app、/vendor/priv-app、/vendor/app、/odm/priv-app、/odm/app、/oem/app、/oem/priv-app、
            /product/priv-app、/product/app、/product_services/priv-app、/product_services/app、/product_services/priv-app
      //参考[6 PMS jar包、apk的安装]
            scanDirTracedLI(new File(VENDOR_OVERLAY_DIR),...);
            scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR),...);
            scanDirTracedLI(new File(PRODUCT_SERVICES_OVERLAY_DIR),...);
            scanDirTracedLI(new File(ODM_OVERLAY_DIR),...);
            scanDirTracedLI(new File(OEM_OVERLAY_DIR),...);
            ...
            final List&lt;String&gt; possiblyDeletedUpdatedSystemApps &#61; new ArrayList&lt;&gt;();
            final List&lt;String&gt; stubSystemApps &#61; new ArrayList&lt;&gt;();
            // 删掉不存在的package
            if (!mOnlyCore) {
                final Iterator&lt;PackageParser.Package&gt; pkgIterator &#61; mPackages.values().iterator();
                while (pkgIterator.hasNext()) {
                    final PackageParser.Package pkg &#61; pkgIterator.next();
                    if (pkg.isStub) {
                        stubSystemApps.add(pkg.packageName);
                    }
                }
                final Iterator&lt;PackageSetting&gt; psit &#61; mSettings.mPackages.values().iterator();
                while (psit.hasNext()) {
                    PackageSetting ps &#61; psit.next();
                    // 如果不是系统应用&#xff0c;则不被允许disable
                    if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) &#61;&#61; 0) {
                        continue;
                    }
                    
                    // 如果应用被扫描&#xff0c;则不允许被擦除
                    final PackageParser.Package scannedPkg &#61; mPackages.get(ps.name);
                    if (scannedPkg !&#61; null) {
                        // 如果系统应用被扫描且存在disable应用列表中&#xff0c;则只能通过OTA升级添加
                        if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
                            ...
                            removePackageLI(scannedPkg, true);
                            mExpectingBetter.put(ps.name, ps.codePath);
                        }
                        continue;
                    }
                    ...
                }
            }
            // 删除临时文件
            deleteTempPackageFiles();
            // 删除没有关联应用的共享UID标识
            mSettings.pruneSharedUsersLPw();
            ...
        }
        ...
    }
    ...
}</code></pre> 
<p><strong>4.2.5 阶段3&#xff1a;</strong><strong>BOOT_PROGRESS_PMS_DATA_SCAN_START</strong></p> 
<p><strong>主要工作有&#xff1a;</strong>对于不仅仅解析核心应用的情况下&#xff0c;还处理data目录的应用信息&#xff0c;及时更新&#xff0c;祛除不必要的数据。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            ...
            if (!mOnlyCore) {
                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,
                        SystemClock.uptimeMillis());
                scanDirTracedLI(sAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);
                ...
                // 移除通过OTA删除的更新系统应用程序的禁用package设置
                // 如果更新不再存在&#xff0c;则完全删除该应用。否则&#xff0c;撤消其系统权限
                for (int i &#61; possiblyDeletedUpdatedSystemApps.size() - 1; i &gt;&#61; 0; --i) {
                    final String packageName &#61; possiblyDeletedUpdatedSystemApps.get(i);
                    final PackageParser.Package pkg &#61; mPackages.get(packageName);
                    final String msg;

                    mSettings.removeDisabledSystemPackageLPw(packageName);
                    ...
                }
                // 确保期望在userdata分区上显示的所有系统应用程序实际显示
                // 如果从未出现过&#xff0c;需要回滚以恢复系统版本
                for (int i &#61; 0; i &lt; mExpectingBetter.size(); i&#43;&#43;) {
                    final String packageName &#61; mExpectingBetter.keyAt(i);
                    if (!mPackages.containsKey(packageName)) {
                        final File scanFile &#61; mExpectingBetter.valueAt(i);
                        ...
                        mSettings.enableSystemPackageLPw(packageName);
                        try {
              //扫描APK
                            scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, null);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, &#34;Failed to parse original system package: &#34;
                                    &#43; e.getMessage());
                        }
                    }
                }
                // 解压缩并安装任何存根系统应用程序。必须最后执行此操作以确保替换或禁用所有存根
                installSystemStubPackages(stubSystemApps, scanFlags);
                ...
                // 获取storage manager包名
                mStorageManagerPackage &#61; getStorageManagerPackageName();
                // 解决受保护的action过滤器。只允许setup wizard&#xff08;开机向导&#xff09;为这些action设置高优先级过滤器
                mSetupWizardPackage &#61; getSetupWizardPackageName();
                ...
                // 更新客户端以确保持有正确的共享库路径
                updateAllSharedLibrariesLocked(null, Collections.unmodifiableMap(mPackages));
                ...
                // 读取并更新要保留的package的上次使用时间
                mPackageUsage.read(mPackages);
                mCompilerStats.read();
            }
        }
    }
}</code></pre> 
<p><strong>4.2.6 阶段4&#xff1a;</strong><strong>BOOT_PROGRESS_PMS_SCAN_END</strong></p> 
<p><strong>主要工作&#xff1a;</strong></p> 
<p>(1)sdk版本变更&#xff0c;更新权限&#xff1b;</p> 
<p>(2)OTA升级后首次启动&#xff0c;清除不必要的缓存数据&#xff1b;</p> 
<p>(3)权限等默认项更新完后&#xff0c;清理相关数据&#xff1b;</p> 
<p>(4)更新package.xml</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>
public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            ...
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,
                    SystemClock.uptimeMillis());
            // 如果自上次启动以来&#xff0c;平台SDK已改变&#xff0c;则需要重新授予应用程序权限以捕获出现的任何新权限
            final boolean sdkUpdated &#61; (ver.sdkVersion !&#61; mSdkVersion);
            mPermissionManager.updateAllPermissions(
                    StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, mPackages.values(),
                    mPermissionCallback);
            ...
            // 如果这是第一次启动或来自Android M之前的版本的升级&#xff0c;并且它是正常启动&#xff0c;那需要在所有已定义的用户中初始化默认的首选应用程序
            if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) {
                for (UserInfo user : sUserManager.getUsers(true)) {
                    mSettings.applyDefaultPreferredAppsLPw(user.id);
                    primeDomainVerificationsLPw(user.id);
                }
            }
            // 在启动期间确实为系统用户准备存储&#xff0c;因为像SettingsProvider和SystemUI这样的核心系统应用程序无法等待用户启动
            final int storageFlags;
            if (StorageManager.isFileEncryptedNativeOrEmulated()) {
                storageFlags &#61; StorageManager.FLAG_STORAGE_DE;
            } else {
                storageFlags &#61; StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;
            }
            ...
            // 如果是在OTA之后首次启动&#xff0c;并且正常启动&#xff0c;那需要清除代码缓存目录&#xff0c;但不清除应用程序配置文件
            if (mIsUpgrade &amp;&amp; !onlyCore) {
                Slog.i(TAG, &#34;Build fingerprint changed; clearing code caches&#34;);
                for (int i &#61; 0; i &lt; mSettings.mPackages.size(); i&#43;&#43;) {
                    final PackageSetting ps &#61; mSettings.mPackages.valueAt(i);
                    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {
                        // No apps are running this early, so no need to freeze
                        clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,
                                FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL
                                        | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
                    }
                }
                ver.fingerprint &#61; Build.FINGERPRINT;
            }
            
            //安装Android-Q前的非系统应用程序在Launcher中隐藏他们的图标
            if (!onlyCore &amp;&amp; mIsPreQUpgrade) {
                Slog.i(TAG, &#34;Whitelisting all existing apps to hide their icons&#34;);
                int size &#61; mSettings.mPackages.size();
                for (int i &#61; 0; i &lt; size; i&#43;&#43;) {
                    final PackageSetting ps &#61; mSettings.mPackages.valueAt(i);
                    if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) !&#61; 0) {
                        continue;
                    }
                    ps.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME,
                            UserHandle.USER_SYSTEM);
                }
            }

            // 仅在权限或其它默认配置更新后清除
            mExistingSystemPackages.clear();
            mPromoteSystemApps &#61; false;
            ...
             // 所有变更均在扫描过程中完成
            ver.databaseVersion &#61; Settings.CURRENT_DATABASE_VERSION;
            //降级去读取
            mSettings.writeLPr();
        }
    }
}</code></pre> 
<p><strong>4.2.7 阶段5&#xff1a;</strong><strong>BOOT_PROGRESS_PMS_READY</strong></p> 
<p><strong>主要工作有&#xff1a;</strong></p> 
<p>(1)创建PackageInstallerService对象</p> 
<p>(2)GC回收内存</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>
public PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            ...
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,
                    SystemClock.uptimeMillis());
            ...
            //PermissionController 主持 缺陷许可证的授予和角色管理&#xff0c;所以这是核心系统的一个关键部分。
            mRequiredPermissionControllerPackage &#61; getRequiredPermissionControllerLPr();
            ...
            updateInstantAppInstallerLocked(null);
            // 阅读并更新dex文件的用法
            // 在PM init结束时执行此操作&#xff0c;以便所有程序包都已协调其数据目录
            // 此时知道了包的代码路径&#xff0c;因此可以验证磁盘文件并构建内部缓存
            // 使用文件预计很小&#xff0c;因此与其他活动&#xff08;例如包扫描&#xff09;相比&#xff0c;加载和验证它应该花费相当小的时间
            final Map&lt;Integer, List&lt;PackageInfo&gt;&gt; userPackages &#61; new HashMap&lt;&gt;();
            for (int userId : userIds) {
                userPackages.put(userId, getInstalledPackages(/*flags*/ 0, userId).getList());
            }
            mDexManager.load(userPackages);
            if (mIsUpgrade) {
                MetricsLogger.histogram(null, &#34;ota_package_manager_init_time&#34;,
                        (int) (SystemClock.uptimeMillis() - startTime));
            }
        }
    }
    ...
    // 打开应用之后&#xff0c;及时回收处理
    Runtime.getRuntime().gc();
    // 上面的初始扫描在持有mPackage锁的同时对installd进行了多次调用
    mInstaller.setWarnIfHeld(mPackages);
    ...
}</code></pre> 
<h2>4.3 dex 优化</h2> 
<p>    检查是否需要去更新Packages并进行dex优化&#xff0c;如果没有OTA升级、没有大版本升级、没有清楚过dalvik虚拟机的缓存&#xff0c;可以去更新packages&#xff0c;</p> 
<p>最终调用的是Installer的dexopt()进行优化</p> 
<p><strong>调用栈如下&#xff1a;</strong></p> 
<p><img alt="" class="has" height="365" src="https://img-blog.csdnimg.cn/20200111223325553.png" width="295" /></p> 
<p><strong>4.3.1 [PackageManagerService.java] updatePackagesIfNeeded()</strong></p> 
<p><strong>说明&#xff1a;</strong></p> 
<p>    检查是否需要去更新Packages并进行dex优化&#xff0c;如果没有OTA升级、没有大版本升级、没有清楚过dalvik虚拟机的缓存&#xff0c;可以去更新packages</p> 
<p>更新packages的优先级&#xff1a;core app &gt;system app &gt; other app&#xff0c;调用 performDexOptUpgrade()进行更新</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void updatePackagesIfNeeded() {
     //只有system或是root用户才有权限请求 package update
    enforceSystemOrRoot(&#34;Only the system can request package update&#34;);

    //(1)判断有没有进行OTA升级&#xff0c;我们需要在OTA后重新提取。
    boolean causeUpgrade &#61; isDeviceUpgrading();

    //(2)是否是第一次启动或是系统大版本升级
    boolean causeFirstBoot &#61; isFirstBoot() || mIsPreNUpgrade;

    // We need to re-extract after a pruned cache, as AoT-ed files will be out of date.
    //(3)判断是否有清除过dalvik虚拟机的缓存
    boolean causePrunedCache &#61; VMRuntime.didPruneDalvikCache();

    //(4)如果上面的三个都没有&#xff0c;那么就不进行任何操作
    if (!causeUpgrade &amp;&amp; !causeFirstBoot &amp;&amp; !causePrunedCache) {
        return;
    }

    List&lt;PackageParser.Package&gt; pkgs;
    synchronized (mPackages) {
        //(5)按照package的优先级进行排序&#xff0c;core app &gt;system app &gt; other app
        pkgs &#61; PackageManagerServiceUtils.getPackagesForDexopt(mPackages.values(), this);
    }

    final long startTime &#61; System.nanoTime(); //记录开始时间
    
    //进行dex优化&#xff0c;参考[4.3.2]
    final int[] stats &#61; performDexOptUpgrade(pkgs, mIsPreNUpgrade /* showDialog */,
                causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT,
                false /* bootComplete */);
    ...
}</code></pre> 
<p><strong>4.3.2  [PackageManagerService.java] performDexOptUpgrade()</strong></p> 
<p><strong>说明&#xff1a;</strong>判断是否需要对package进行更新&#xff0c;如果需要更新那么按照优先级完成dex优化&#xff0c;最终调用Install的dexopt()进行dex优化&#xff0c;参考上面的调用栈</p> 
<p><strong>源码:</strong></p> 
<pre class="has"><code>
private int[] performDexOptUpgrade(List&lt;PackageParser.Package&gt; pkgs, boolean showDialog,
        final int compilationReason, boolean bootComplete) {
    ...
    //循环取出packages&#xff0c;进行优化
    for (PackageParser.Package pkg : pkgs) {
        numberOfPackagesVisited&#43;&#43;;

        boolean useProfileForDexopt &#61; false;

        //第一次启动或是ota升级之后并且是系统应用才会进行odex
        if ((isFirstBoot() || isDeviceUpgrading()) &amp;&amp; isSystemApp(pkg)) {
            ...
        }
        ...
        //最终是调用 mInstaller.dexopt 完成优化的&#xff0c;installd守护进程&#xff0c;installer安装器和Installd通信
        int primaryDexOptStaus &#61; performDexOptTraced(new DexoptOptions(
                pkg.packageName,
                pkgCompilationReason,
                dexoptFlags));

        switch (primaryDexOptStaus) {
            case PackageDexOptimizer.DEX_OPT_PERFORMED:
                numberOfPackagesOptimized&#43;&#43;; //odex优化完成的应用
                break;
            case PackageDexOptimizer.DEX_OPT_SKIPPED:
                numberOfPackagesSkipped&#43;&#43;; //跳过的应用
                break;
            case PackageDexOptimizer.DEX_OPT_FAILED:
                numberOfPackagesFailed&#43;&#43;; //失败的应用
                break;
            default:
                Log.e(TAG, &#34;Unexpected dexopt return code &#34; &#43; primaryDexOptStaus);
                break;
        }
    }
    return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped,
            numberOfPackagesFailed };
}</code></pre> 
<p><strong>4.4 磁盘维护</strong></p> 
<p>磁盘维护最终调用的是vold进程的 fstrim()进行清理操作</p> 
<p><strong>调用栈&#xff1a;</strong></p> 
<p><strong><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200111223407384.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></strong></p> 
<p><strong>[PackageManagerService.java] performFstrimIfNeeded()</strong></p> 
<p><strong>说明&#xff1a;</strong>主要是执行磁盘清理工作&#xff0c;释放磁盘空间</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void performFstrimIfNeeded() {
   //只有system或是root用户才有权限请求fstrim
   enforceSystemOrRoot(&#34;Only the system can request fstrim&#34;);

   //在其他事情之前&#xff0c;看看我们是否需要fstrim
   try {
        //获取StorageManager对象
       IStorageManager sm &#61; PackageHelper.getStorageManager();
       if (sm !&#61; null) {
           boolean doTrim &#61; false;
           //获取执行FTRIM间隔&#xff0c;默认是3天&#xff0c;可以通过setting provider更改这个时间
           long interval &#61; android.provider.Settings.Global.getLong(
                   mContext.getContentResolver(),
                   android.provider.Settings.Global.FSTRIM_MANDATORY_INTERVAL,
                   DEFAULT_MANDATORY_FSTRIM_INTERVAL);

           if (interval &gt; 0) {
               final long timeSinceLast &#61; System.currentTimeMillis() - sm.lastMaintenance();
               if (timeSinceLast &gt; interval) {
                   doTrim &#61; true; //如果超过了三天就进行磁盘清理
                   Slog.w(TAG, &#34;No disk maintenance in &#34; &#43; timeSinceLast
                           &#43; &#34;; running immediately&#34;);
               }
           }
           if (doTrim) {
               final boolean dexOptDialogShown;
               synchronized (mPackages) {
                   dexOptDialogShown &#61; mDexOptDialogShown;
               }
               //如果不是第一次启动&#xff0c;显示一个提示框
               if (!isFirstBoot() &amp;&amp; dexOptDialogShown) {
                   try {
                       ActivityManager.getService().showBootMessage(
                               mContext.getResources().getString(
                                       R.string.android_upgrading_fstrim), true);
                   } catch (RemoteException e) {
                   }
               }
               // 这里的sm是 StorageManagerService&#xff0c;发送消息H_FSTRIM给handler&#xff0c;然后再向vold发送fstrim命
               sm.runMaintenance();
           }
       } else {
           Slog.e(TAG, &#34;storageManager service unavailable!&#34;);
       }
   } catch (RemoteException e) {
       // Can&#39;t happen; StorageManagerService is local
   }
}</code></pre> 
<p> </p> 
<p><strong>4.5 PKMS 准备就绪</strong></p> 
<p><strong>[PackageManagerService.java] systemReady()</strong></p> 
<p><strong>说明&#xff1a;</strong>systemReady主要完成的是默认授权和更新package的信息&#xff0c;通知在等待pms的一些组件</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>
public void systemReady() {
    //只有system或是root用户才有权限 声称system已经ready
    enforceSystemOrRoot(&#34;Only the system can claim the system is ready&#34;);

    ContentObserver co &#61; new ContentObserver(mHandler) {
        ...
    };
    co.onChange(true); //注册一个监听
    ...
    synchronized (mPackages) {

        ArrayList&lt;PreferredActivity&gt; removed &#61; new ArrayList&lt;&gt;();
        for (int i&#61;0; i&lt;mSettings.mPreferredActivities.size(); i&#43;&#43;) {
            PreferredIntentResolver pir &#61; mSettings.mPreferredActivities.valueAt(i);
            removed.clear();
            for (PreferredActivity pa : pir.filterSet()) {
                if (!mComponentResolver.isActivityDefined(pa.mPref.mComponent)) {
                    removed.add(pa);
                }
            }//移除不存在的先前用户设置保存的优先选择的activity组件
            if (removed.size() &gt; 0) {
                for (int r&#61;0; r&lt;removed.size(); r&#43;&#43;) {
                    PreferredActivity pa &#61; removed.get(r);
                    Slog.w(TAG, &#34;Removing dangling preferred activity: &#34;
                            &#43; pa.mPref.mComponent);
                    pir.removeFilter(pa);
                }
                mSettings.writePackageRestrictionsLPr(
                        mSettings.mPreferredActivities.keyAt(i)); //写入到文件中
            }
        }

        for (int userId : UserManagerService.getInstance().getUserIds()) {
            if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                grantPermissionsUserIds &#61; ArrayUtils.appendInt(
                        grantPermissionsUserIds, userId);
            }
        }
    }

    sUserManager.systemReady(); //多用户服务 systemReady
    //升级所有已获取的默认权限
    for (int userId : grantPermissionsUserIds) {
        mDefaultPermissionPolicy.grantDefaultPermissions(userId); //默认授权操作&#xff0c;参考[]
    }
    ...

    // Now that we&#39;ve scanned all packages, and granted any default
    // permissions, ensure permissions are updated. Beware of dragons if you
    // try optimizing this.
    synchronized (mPackages) {
        mPermissionManager.updateAllPermissions(
                StorageManager.UUID_PRIVATE_INTERNAL, false, mPackages.values(),
                mPermissionCallback); //更新权限信息
        ...
        });
    }

    //注意随时间变化的外部存储设备
    final StorageManager storage &#61; mContext.getSystemService(StorageManager.class);
    storage.registerListener(mStorageListener);

    mInstallerService.systemReady();
    mApexManager.systemReady();
    mPackageDexOptimizer.systemReady();
    ...

    //清除过期的userid和app
    sUserManager.reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);
    reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);

    mPermissionManager.systemReady();

    if (mInstantAppResolverConnection !&#61; null) {
        mContext.registerReceiver(new BroadcastReceiver() {
            &#64;Override
            public void onReceive(Context context, Intent intent) {
                mInstantAppResolverConnection.optimisticBind();
                mContext.unregisterReceiver(this);
            }
        }, new IntentFilter(Intent.ACTION_BOOT_COMPLETED));
    }

    if (!isFirstBoot()) {
        Slog.i(TAG, &#34;enablePackageStoppedPolicy&#34;);
        synchronized (mPackages) {
            PackageManagerServiceUtilsZTE.enablePackageStoppedPolicy(mPackages.values(), this);
        }
    }

    mModuleInfoProvider.systemReady();

    // Installer service might attempt to install some packages that have been staged for
    // installation on reboot. Make sure this is the last component to be call since the
    // installation might require other components to be ready.
    mInstallerService.restoreAndApplyStagedSessionIfNeeded();

    //update partner app
    new Thread(() -&gt; {
        updatePartnerAppInFota();
    }).start();
}</code></pre> 
<p> </p> 