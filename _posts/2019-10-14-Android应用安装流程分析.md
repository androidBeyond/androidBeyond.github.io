---
layout:     post
title:      Android应用安装流程分析
subtitle:   Android应用安装流程分析学习总结
date:       2019-10-14
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android
    - framework
---

<article class="baidu_pl">
        <div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-1a85854398.css">
                <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>整体介绍</h4> 
<p>一个 Android 应用安装到手机上大致分为四种情形&#xff1a;</p> 
<ul><li>系统应用&#xff0c;在设备每次启动时完成安装</li><li>通过 adb install 命令安装</li><li>应用市场安装&#xff0c;封装安装过程&#xff08;略&#xff09;</li><li>第三方应用安装或双击安装包&#xff0c;会启动系统应用引导安装</li></ul> 
<p>无论采用哪种安装方式&#xff0c;最终的安装过程都会走到 PackageManagerService&#xff0c;由这个类来完成一系列的工作。<br /> PackageManagerService 实际上是一个系统服务&#xff0c;负责提供系统上所有应用的管理&#xff0c;包括安装、优化、查询和卸载&#xff0c;这个类最终会通过 socket 与 installd 这个守护进程通信&#xff0c;真实对应用进行操作的其实是由 installd 这个进程完成。</p> 
<h4><a id="_12"></a>场景一&#xff1a;系统应用安装</h4> 
<p>在设备启动时&#xff0c;Linux 系统的用户空间进程 init &#xff08;pid &#61; 1&#xff09;会孵化许多子进程&#xff0c;包括一系列守护进程&#xff0c;其中就有上面提到的 installd&#xff0c;然后会孵化许多重要的系统服务&#xff0c;如 servicemanager&#xff0c;这个进程会负责管理所有服务的 Binder 通信&#xff0c;此外 init 还会孵化mediaserver&#xff0c;此进程负责启动和管理 Framework 的 C 层的服务&#xff0c;最后 init 还会孵化 zygote 进程&#xff0c;这个进程是第一个 Java 进程&#xff0c;zygote 进程会孵化出许多应用程序进程&#xff0c;包括 launcher 进程&#xff0c;即桌面进程&#xff0c;zygote 还会孵化出 system_server 进程&#xff0c;这个进程与 mediaserver 对应&#xff0c;负责启动和管理 Framework 的 Java 层服务&#xff0c;包括 PackageManagerService、ActivityManagerService 等<br /> <img src="https://img-blog.csdnimg.cn/20190802154952786.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="init孵化进程" /><br /> <strong>补充&#xff1a;system_server 的启动与运行流程</strong></p> 
<p>system_server 由 zygote 进程孵化&#xff0c;是整个 Android Framework 的基础</p> 
<p>zygote 启动阶段会调用 forkSystemServer() 创建子进程 system_server<br /> <img src="https://img-blog.csdnimg.cn/20190802155019548.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="zygote启动system_server" /><br /> ForkAndSpecializeCommon 函数中完成进程创建工作并返回&#xff0c;两次返回&#xff0c;pid&#61;0 时为子进程&#xff0c;pid&gt;0 时为父进程。onZygoteInit() 回调的实现在在 app_main.cpp 中&#xff0c;会调用 ProcessState::self() 初始化 binder 的交互操作&#xff0c;然后调用 proc-&gt;startThreadPool() 创建 binder 线程进行通信</p> 
<p>RuntimeInit 的 findStaticMain() 调用 com.android.server.SystemServer 的 main 方法</p> 
<p>SystemServer 的 run() 方法中会完成以下工作&#xff1a;</p> 
<ul><li>设置时间、语言等&#xff0c;设置虚拟机库文件&#xff0c;设置内存</li><li>Looper.prepareMainLooper() 主线程 looper 运行在当前线程</li><li>加载库文件 android_servers&#xff0c;位于 /frameworks/base/services</li><li>createSystemContext() 初始化系统上下文</li><li>SystemServiceManager() 创建系统服务管理器&#xff0c;并添加到本地服务成员 LocalServices 中</li><li>启动各种系统服务&#xff0c;包括引导服务、核心服务、其他服务</li><li>开启循环&#xff0c;等待其他线程通过 handler 发送消息到主线程来处理</li></ul> 
<p>在 system_server 进程启动过程中会启动各种系统服务&#xff0c;其中就包含 PackageManagerService<br /> <img src="https://img-blog.csdnimg.cn/20190802155121937.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="system_server启动PMS" /><br /> PackageManagerService 类构造函数中完成了许多工作&#xff0c;主要包含&#xff1a;</p> 
<ul><li>创建 Settings 对象&#xff0c;添加系统的 SharedUser 信息</li><li>为 Installer 对象赋值&#xff0c;赋值参数是在 system_server 进程中创建的</li><li>创建 PackageDexOptimizer 和 DexManager 对象</li><li>获取 SystemConfig 实例&#xff0c;获取系统的全局配置信息&#xff0c;如 GlobalGids、SystemPermissions、AvailableFeatures</li><li>创建 ServiceThread 和 PackagerHandler 对象</li><li>创建 UserManagerService&#xff0c;支持多用户</li><li>读取系统定义的权限保存到 permConfig 变量中</li><li>读取系统共享库保存到 libConfig 变量中</li><li>解析 package.xml 文件中的内容保存到 ArrayMap&lt;String, PackageParser.Package&gt; 结构中</li><li>配置扫描参数 scanFlags</li><li>开始扫描系统应用&#xff0c;包括目录 /vender/overlay、/system/framework、/system/priv-app、/system/app、/vendor/app、/oem/app</li><li>开始扫描非系统应用&#xff0c;包括目录 /data/app、/data/app-private</li><li>启动内存垃圾回收</li><li>启动私有服务 PackageManagerInternal</li></ul> 
<p>总结来说主要是这几项内容&#xff1a;</p> 
<ul><li>创建了 Java 层 Installer 和 C 层 installd 之间的 socket 连接</li><li>扫描各目录下 apk文件完成安装&#xff08;建立各安装包的配置结构信息&#xff0c;并添加到全局列表中进行管理&#xff09;</li><li>创建了 PackageHandler 对象并建立消息循环&#xff0c;接收外部的安装请求</li><li>解析权限&#xff0c;建立底层 Linux Kernel 的用户机制和虚拟机层权限机制之间的映射</li></ul> 
<p><strong>详细说明下 Installer&#xff1a;</strong></p> 
<p>Installer 是 PackageManagerService 的一个内部类&#xff0c;继承自SystemService&#xff0c;协助完成安装过程&#xff0c;主要是进行 apk 格式转换和数据目录建立&#xff0c;封装对文件和路径操作&#xff0c;真正的安装工作交由 IInstalld 内部类对象完成。<br /> <img src="https://img-blog.csdnimg.cn/20190802155145752.png" alt="PMS与installer" /><br /> Installer 在 SystemServer 中启动&#xff0c;通过 SystemServiceManager 的 startService(Installer.class) 启动。<br /> <img src="https://img-blog.csdnimg.cn/20190802155203387.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="system_server启动installer" /><br /> 构造函数 Installer() 初始化 context 和 isolated&#xff08;是否真正连接installd&#xff09;成员变量</p> 
<p>重写 onStart() 方法&#xff0c;基于 isolated 判断是否调用 connect() 进行连接</p> 
<p>connect() 通过 ServiceManager 获取 installd 服务并拿到服务的本地代理放到成员变量 mInstalld 中</p> 
<p>Installer 调用 dexopt() 最终调用了 mInstalld 的dexopt() 方法&#xff0c;其他方法类似&#xff0c;几乎就是一个 IInstalld 类的封装</p> 
<p><strong>注意</strong>&#xff1a; Installer 的实现变化很大&#xff1a;6.0 上通过以命令的方式通过 execute 方法执行&#xff1b;8.1 通过 AIDL 接口实现</p> 
<p><strong>PackageManageService&#xff08;system权限&#xff09; 与 installd&#xff08;root权限&#xff09; 守护进程共同完成应用管理</strong></p> 
<p>PackageManagerService 的构造函数中会扫描许多应用目录来安装 apk</p> 
<p>包括&#xff1a;</p> 
<ul><li>系统应用&#xff0c;目录有 <code>/vender/overlay</code>、<code>/system/framework</code>、<code>/system/priv-app</code>、<code>/system/app</code>、<code>/vendor/app</code>、<code>/oem/app</code></li><li>非系统应用&#xff0c;目录有 <code>/data/app</code>、<code>/data/app-private</code></li></ul> 
<p>调用的方法是 <code>scanDirTracedLI()</code><br /> <img src="https://img-blog.csdnimg.cn/20190802155241528.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="scanDirTracedLI" /><br /> 可以看到依次调用 scanDirLI()、scanPackageLI()、scanPackageInternalLI()</p> 
<p>其中&#xff0c;scanDirLI() 调用了 ParallelPackageParser 类进行解析&#xff0c;从名字也能看出做了一些并行的优化处理&#xff0c;真正的工作还是交给 PackageParser 来完成&#xff0c;PackageParser 的 parsePackage() 方法内部完成了应用的解析&#xff0c;实际上是解析了 AndroidManifest.xml 文件里面各个标签&#xff0c;包括包名、版本、权限、各组件这些信息&#xff0c;最后的解析结果放在 PackageParser.Package 类中返回给 PMS&#xff0c;这样 PMS 就拥有应用的信息便与做各种管理</p> 
<p>后面继续调用了 scanPackageLI() 和 scanPackageInternalLI() 是进一步检测应用是否需要更新&#xff0c;如果需要更新则接着调用 createInstallArgsForExisting() 构造安装参数开始安装&#xff08;后面还会遇到这个函数&#xff0c;暂时不展开&#xff09;&#xff0c;安装涉及到的签名校验也是在这里&#xff0c;调用了 collectCertificatesLI()、compareSignatures() 等</p> 
<h4><a id="adb__95"></a>场景二&#xff1a;adb 命令安装</h4> 
<p>adb 是 Android SDK 提供的一个命令行工具&#xff0c;为客户端-服务器架构&#xff0c;服务端为移动端上运行的守护进程 adbd&#xff0c;与 installd 一样由 init 进程创建</p> 
<p>源码路径为&#xff1a;<a href="http://androidxref.com/8.1.0_r33/xref/system/core/adb/">http://androidxref.com/8.1.0_r33/xref/system/core/adb/</a><br /> <img src="https://img-blog.csdnimg.cn/20190802155304629.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="adb install" /><br /> adb_commandline() 函数接收 adb 命令行参数&#xff0c;调用 install_app() 执行安装流程&#xff0c;这个函数会对命令行做一些修改&#xff0c;实际上调用 pm 命令&#xff0c;并通过 send_shell_command() 将命令发送给 Pm 类。</p> 
<p>Pm 启动函数 main 会构造 Pm 类对象并调用 run() 方法&#xff0c;在这个方法里首先会获取 PackageManger 服务 mPm&#xff0c;然后调用 getPackageInstaller() 获取 PackageInstaller 对象 mInstaller&#xff0c;最后基于不同的命令调用不同的方法。</p> 
<p>runInstall() 里面会首先获取之前解析时设置的安装参数 InstallParams&#xff0c;然后依次调用 doCreateSession() 创建安装会话&#xff0c;doWriteSession() 会通过 IO 流将应用信息写入 PackageInstaller.Session 对象&#xff0c;doCommitSession() 会提交相应的会话启动安装&#xff0c;最后调用 abandonSession() 结束会话。<br /> <img src="https://img-blog.csdnimg.cn/20190802155415604.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="PackageInstallerSession" /><br /> PackageInstallerSession 的 commit() 方法首先将包信息封装到 PackageInstallObserverAdapter 这个类中&#xff0c;是 PackageInstallerService 的一个内部类&#xff0c;然后通过这个适配器获取 PackageInstallObserver2 对象代理&#xff0c;这是一个跨进程的观察者&#xff0c;接收安装状态的回调&#xff0c;最后用 Handler 的 obtainMessage 构造一个 MSG_COMMIT 类型的消息并发送出去。</p> 
<p>发送的消息由 PackageInstallerService 的 Handler.Callback 接受&#xff0c;然后调用 commitLocked()&#xff0c;此方法最终会调用 PMS 的 installStage() 方法。</p> 
<p>PackageInstallObserver2 对象接收到安装成功的回调时&#xff0c;会接着调用 PackageInstallerService 的 dispatchSessionFinished()&#xff0c;这个方法最后也是到了 PMS 里面调用 sendSessionCommitBroadcast() 方法。</p> 
<h4><a id="_113"></a>场景三&#xff1a;第三方应用安装</h4> 
<p>当下载一个新的应用包双击安装时&#xff0c;实际上是发送了一个 “android.intent.action.INSTALL_PACKAGE” 的 intent&#xff0c;这个时候会唤起 Android 系统的一个应用 PackageInstaller 来完成安装操作</p> 
<p>PackageInstaller 的应用代码位于&#xff1a;<a href="http://androidxref.com/8.1.0_r33/xref/packages/apps/PackageInstaller/">http://androidxref.com/8.1.0_r33/xref/packages/apps/PackageInstaller/</a></p> 
<p>安装位置 /system/priv-app/GooglePackageInstaller&#xff0c;是一个 Android 系统默认应用程序&#xff0c;提供了用户界面来管理应用或包&#xff0c;用于安装普通文件<br /> <img src="https://img-blog.csdnimg.cn/20190802155434992.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="InstallStart" /><br /> 应用双击安装后会唤起 PackageInstaller 应用&#xff0c;入口类为 InstallStart&#xff0c;onCreate() 首先被调用完成一些初始化过程&#xff0c;然后获取调用源做一些权限检查。</p> 
<p>然后会调起 PackageInstallerActivity&#xff0c;onCreate() 会包括获取 PackageManager 和 PackageInstaller 对象&#xff0c;然后从 intent 中获取 mSessionId、packageUri、mOriginatingURI、mReferrerURI 这些与安装包相关的信息&#xff0c;接着调用 processPackageUri() 解析 uri&#xff0c;这里面会调用 PackageParser 去解析包&#xff0c;再接着会调用 bindUi() 完成安装主界面的展示和部件绑定&#xff0c;最后调用 checkIfAllowedAndInitiateInstall() 检查是否允许安装&#xff0c;如果允许&#xff0c;里面会继续调用 initiateInstall() 初始化安装&#xff0c;实际上这个函数是检查是否需要替换安装&#xff0c;最后调用 startInstallConfirm() 准备安装&#xff0c;设置 mOk 这个安装按钮为 true。</p> 
<p>用户确认点击安装按钮后&#xff0c;调用 startInstall() 开始安装&#xff0c;这个函数里面又会构造一个 intent 传递必要的数据&#xff0c;开启 InstallInstalling 这个 activity。<br /> <img src="https://img-blog.csdnimg.cn/20190802155448477.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="InstallInstalling" /><br /> InstallInstalling 这个类会拿到应用数据开启真正的安装流程。</p> 
<p>首先是 onCreate() 函数&#xff0c;首先从 Intent 中取出数据放到 ApplicationInfo 中&#xff0c;然后基于拿到的应用信息分两种情况&#xff1a;如果是更新&#xff0c;则调用 getPackageManager() 获取 PackageManager 然后调用 installExistingPackage() 安装&#xff0c;成功调用 launchSuccess() 方法&#xff0c;失败调用 launchFailure() 方法&#xff0c;launchSuccess 会构造 Intent 跳转到 InstallSuccess 类&#xff0c; launchFailure 则跳转到 InstallFailed 类&#xff1b;如果是新应用的安装&#xff0c;首先会向 InstallEventReceiver 注册一个安装结果监听的广播&#xff0c;成功调用 launchSuccess&#xff0c;失败调用 launchFailure。</p> 
<p>接下来是 onStart() 方法&#xff0c;这里会依次调用 getPackageManager()&#xff0c;getPackageInstaller()&#xff0c;registerSessionCallback() 注册会话的回调。</p> 
<p>最后是 onResume() 方法&#xff0c;这个方法里会获取 session 的相关信息&#xff0c;然后创建并执行 InstallingAsyncTask() 的安装服务&#xff0c;其中的 doInBackground() 方法会将应用信息通过 IO 流写入 PackageInstaller.Session 中&#xff0c;onPostExecute() 方法则构造一个 PendingIntent 并将它的 IntentSender 通过 PackageInstaller.Session 的 commit() 方法发送出去</p> 
<p>这里就跟 adb 安装走到了同一个流程中。</p> 
<h4><a id="_PMS__137"></a>深入 PMS 中的安装</h4> 
<p>上面的后面两种场景最后都会通过 PackageInstallerSession 的 commit() 方法提交一个安装的会话&#xff0c;并且最终调用到了 PackageManagerService 的 installStage() 方法<br /> <img src="https://img-blog.csdnimg.cn/20190802155507501.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="installStage" /><br /> 在 installStage() 里会基于传入的参数构造一个 InstallParams 对象&#xff0c;这个对象中包含安装包的所有数据&#xff0c;然后将这个对象作为消息内容&#xff0c;通过 mHandler 发送一个类型为 INIT_COPY 的消息。</p> 
<p>所有类型的消息处理都在 PackageHandler 里&#xff0c;这个类会通过 Binder 与 system_server 创建的 ServiceThread 线程绑定&#xff0c;PackageHandler 负责分发任务&#xff0c;ServiceThread 负责处理任务。</p> 
<p><strong>1、处理 INIT_COPY 消息</strong></p> 
<p>首先从消息结构中取出前面封装好的 HandlerParams 对象&#xff0c;然后检查 mBound 标志判断是否绑定 DefaultContainerService&#xff0c;这个服务用于检查和复制文件&#xff0c;位于 com.android.defcontainer 进程&#xff0c;通过 IMediaContainerService 与PMS 通信&#xff0c;mBound 默认为 false&#xff0c;此时调用 connectToService() 来绑定服务&#xff0c;并获取当前索引值的 HandlerParams 对象添加到 mPendingInstalls 这个 HandlerParams 的 ArrayList 中&#xff0c;如果 mBound 为 true&#xff0c;即服务已经连接&#xff0c;则直接添加 HandlerParams 对象&#xff0c;并发送一个 MCS_BOUND 消息。</p> 
<p><strong>2、处理 MCS_BOUND 消息</strong></p> 
<p>首先检查 DefaultContainerService 服务连接没问题&#xff0c;就开始处理安装请求队列&#xff0c;从 mPendingInstalls 中取出 HandlerParams 对象并调用它的 startCopy() 方法<br /> <img src="https://img-blog.csdnimg.cn/20190802155522897.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="startCopy" /><br /> HandlerParams 是 PMS 中的抽象类&#xff0c;它的 startCopy() 会通过一个 mRetries 的私有变量检查尝试次数&#xff0c;超过4次则向 Handler 发送 MCS_GIVE_UP 的消息&#xff0c;抓到异常则发送 MCS_RECONNECT 的消息&#xff0c;成功则继续调用 handleStartCopy() 这个抽象方法&#xff0c;具体实现在 InstallParams 中&#xff0c;</p> 
<p>InstallParams 的 handleStartCopy() 会首先是确定应用安装位置&#xff0c;是sd卡还是内部存储&#xff0c;并且做一些检查如位置冲突&#xff0c;空间够不够&#xff0c;然后通过 createInstallArgs() 创建 InstallArgs 类&#xff0c;然后调用这个类的 copyApk() 方法&#xff0c;InstallArgs 类也是抽象类&#xff0c;定义了应用包安装逻辑&#xff0c;子类包括 FileInstallArgs&#xff0c;处理 non-ASEC 应用&#xff0c;也即内部存储空间的应用&#xff0c; AsecInstallArgs 处理安装到 SD 卡中的应用&#xff0c;以及 MoveInstallArgs 处理已安装的应用&#xff0c;因此实际上是调用各自实例对象的 copyApk() 方法</p> 
<p>以 FileInstallArgs 为例&#xff0c;copyApk() 方法会调用 doCopyApk()&#xff0c;在这个方法里会首先创建一个临时存储目录&#xff0c;然后调用 DefaultContainerService 的 copyPackage() 方法完成 apk 复制</p> 
<p>HandlerParams 复制 apk 后会调用 handleReturnCode()&#xff0c;这个方法又会调用 processPendingInstall() 方法&#xff0c;最终会调用到 InstallArgs 的 doPreInstall() 完成安装前的清理工作&#xff0c;调用 installPackageTracedLI() 实现真正的安装&#xff0c;以及调用 InstallArgs 的 doPostInstall() 完成收尾的清理工作&#xff0c;最后发送一个类型为 POST_INSTALL 的消息<br /> <img src="https://img-blog.csdnimg.cn/20190802155537555.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="installPakcageLI" /><br /> installPackageTracedLI() 里面完成的是真正的安装操作&#xff0c;会依次进行变量初始化&#xff0c;再次解析应用包&#xff0c;获取签名信息&#xff0c;权限检查&#xff0c;安装路径重命名等等操作&#xff0c;最后根据参数有两种不同的处理方式&#xff0c;更新条件下的覆盖安装&#xff0c;调用 replacePackageLI() 方法&#xff0c;以及应用的首次安装&#xff0c;调用 installNewPackageLI() 方法</p> 
<p>其中 replacePackageLI() 会首先清楚应用包的注册信息&#xff0c;然后类似 installNewPackageLI() 里面的流程重新安装更新的包&#xff0c;直接看 installNewPackageLI() 流程</p> 
<p>installNewPackageLI() 里面调用 scanPackageTraceLI() 执行安装&#xff0c;然后这个函数里面又会继续调用 scanPackageInternalLI() 执行包解析&#xff0c;最后将 PackageParser.Package 对象返回出来&#xff0c;扫描完包之后就会调用 updateSettingsLI() 更新 Settings&#xff0c;也就是更新应用在 PMS 中的注册信息&#xff0c;会修改包括 packages.xml、package.list 等相关文件&#xff0c;如果安装成功则调用 prepareAppDataAfterInstallLIF() 来创建相关的数据目录&#xff0c;失败则执行回退操作 deletePackageLIF()</p> 
<p><strong>3、处理 POST_INSTALL 消息</strong></p> 
<p>首先从 mRunningInstalls 中拿到 PostInstallData 对象&#xff0c;mRunningInstalls 是 PostInstallData 格式的列表&#xff0c;在应用安装成功时构建&#xff0c;在安装完成后会调用 delete() 移除这一条记录&#xff0c;接下来取 PostInstallData 对象中的一些信息如安装参数&#xff0c;授予的权限等作为参数调用 handlePackagePostInstall() 执行安装完成的后续操作&#xff0c;包括授予权限&#xff0c;发送安装成功广播&#xff0c;发送启动广播等等</p> 
<h4><a id="_171"></a>安装过程小结</h4> 
<p><strong>与应用相关的一些目录</strong></p> 
<ul><li> <p>/system/priv-app&#xff1a;系统应用安装路径&#xff0c;Android 4.4&#43; 开始出现&#xff0c;区分系统应用权限&#xff0c;拥有 SignatureOrSystem 权限&#xff0c;此目录下的 service 具有保活能力</p> </li><li> <p>/system/app&#xff1a;系统应用安装路径&#xff0c;权限略低于 priv-app 目录下的应用&#xff0c;放置比如厂商内置应用</p> </li><li> <p>/data/app&#xff1a;用户应用安装路径&#xff0c;应用安装时将 apk 复制到此目录下</p> </li><li> <p>/data/data&#xff1a;用户应用数据存放路径&#xff0c;存在沙箱隔离</p> </li><li> <p>/data/dalvik-cache&#xff1a;存放应用的dex 文件</p> </li><li> <p>/data/system&#xff1a;存放应用安装相关文件</p> 
  <ul><li>packages.xml 是一个应用的注册表&#xff0c;在解析应用时创建&#xff0c;有变化时更新&#xff0c;记录系统权限&#xff0c;各应用信息&#xff0c;如name, codePath, flag, version, userid&#xff0c;下次开机时直接读取并添加到内存列表</li><li>package.list 指定应用的默认存储位置&#xff0c;userid 等</li></ul> </li></ul> 
<p><strong>应用安装过程总结</strong></p> 
<ol><li>将应用 apk 拷贝到指定目录下</li><li>解压 apk&#xff0c;将 dex 文件拷贝到 /data/dalvik-cache 目录&#xff0c;创建 /data/data/ 数据目录</li><li>解析 AndroidManifest.xml 及其他资源文件&#xff0c;提取应用包信息&#xff0c;注册到 packags.xml 中</li><li>由 Launcher 进程通过 PMS 取出所有应用程序&#xff0c;展示在桌面上</li></ol> 
<h4><a id="PMS__PM_APM_197"></a>PMS 与 PM 与APM</h4> 
<p>前面的一切分析都是围绕 PackageManagerService 来进行的&#xff0c;但是实际上平时开发过程中基本接触不到这个类&#xff0c;在用户层用得最多的应该是 PackageManager 这个类<br /> <img src="https://img-blog.csdnimg.cn/20190802155640970.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="getPackageManager" /><br /> 通常在用户层通过 Context 的 getPackageManager() 方法来获取 PackageManager 实例&#xff0c;Context 的 getPackageManager() 实现在 ContextImpl 里面&#xff0c;这个函数实际上返回的是一个 ApplicationPackageManager 对象&#xff0c;ApplicationPackageManager 类构造函数需要两个璨是&#xff0c;一个是 ContextImpl 自身&#xff0c;另一个是通过 ActivityThread 的 getPackageManager() 获取 IPackageManager 对象</p> 
<p>ActivityThread 的 getPackageManager() 首先调用 ServiceManager 的 getService(“package”) 获取 IBinder 对象&#xff0c;然后通过 IPackageManger.Stub.asInterface(IBinder) 获取 IPackageManager 对象&#xff0c;实际上为这个对象的一个代理</p> 
<p>继续梳理一下这个类与 PMS 之间的关系<br /> <img src="https://img-blog.csdnimg.cn/20190802155657293.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTAxNjM0Nw&#61;&#61;,size_16,color_FFFFFF,t_70" alt="Binder结构" /><br /> IPackageManager 使用了 Android 接口定义语言&#xff08;AIDL&#xff09;实现进程间通信&#xff0c;通过在 .aidl 后缀的文件中定义好接口&#xff0c;Android SDK 就会基于此文件自动生成一个 IBinder 接口的类&#xff0c;服务端实现这些接口&#xff0c;客户端则通过绑定到服务调用接口中定义的方法</p> 
<p>IPackageManager 通过 AIDL 文件自动生成的一个接口类&#xff0c;继承自 IInterface</p> 
<p>IPackageManager.Stub 是 IPackageManager 的内部类&#xff0c;继承自 Binder&#xff0c;实现 IPackageManager</p> 
<ul><li>asInterface() 方法接受 IBinder 对象&#xff0c;转换成 IPackageManager 类型对象并返回&#xff0c;实际上返回的是 IPackageManager.Stub.Proxy 对象</li><li>asBinder() 方法返回自身&#xff0c;即 IPackageManager.Stub 对象</li><li>重写了 onTransact() 方法&#xff0c;根据命令类型处理数据传输</li></ul> 
<p>IPackageManager.Stub.Proxy 是 IPackageManager.Stub 的内部类&#xff0c;实现了IPackageManager接口</p> 
<ul><li>mRemote对象是IBinder类型&#xff0c;是对IPackageManager.Stub的引用</li><li>重写了asBinder()方法&#xff0c;返回mRemote</li><li>实现了AIDL文件定义的接口</li></ul> 
<p>PackageManager 是系统提供的服务管理类&#xff0c;负责管理应用程序包的&#xff0c;包含以下功能&#xff1a;</p> 
<ul><li>安装/卸载/更新应用&#xff0c;包括 installPackage/</li><li>查询已安装应用&#xff0c;通过 getInstalledPackages() 方法获取 PackageInfo 对象的列表</li><li>查询应用相关信息&#xff0c;通过 getPackageInfo() 方法获取 PackageInfo 对象</li><li>查询权限相关信息&#xff0c;通过 getPermissionInfo() 方法获取 PermissionInfo 对象</li><li>增加/删除权限&#xff0c;包括 addPermission/removePermission</li><li>清除用户数据/缓存/代码等</li></ul> 
<p>PackageManager 是一个抽象类&#xff0c;定义了 IPackageManager 接口的子集</p> 
<p>ApplicationPackageManager 是 PackageManager 的实现类&#xff0c;它继承了 PackageManager 并实现其所有抽象方法</p> 
<p>PackageManagerService 继承了 IPackageManager.Stub</p> 
<p>因此&#xff0c;总结来说就是&#xff0c;<strong>ApplicationPackageManager 是 AIDL 模型中 Binder 通信的客户端&#xff0c;PackageMangerService 就是服务端</strong>&#xff0c;客户端的所有的功能都是通过一个 IPackageManager 类型的成员变量去完成的&#xff0c;实际上这个变量就是 PackageManagerService 的一个代理&#xff0c;通过这个代理客户端可以调用到 PackageManagerService 中的一些方法</p> 
<h4><a id="_241"></a>参考</h4> 
<ul><li><a href="http://androidxref.com/8.1.0_r33/xref/">http://androidxref.com/8.1.0_r33/xref/</a></li><li><a href="https://juejin.im/post/5b7e72bbe51d453894001ef0#heading-6">https://juejin.im/post/5b7e72bbe51d453894001ef0#heading-6</a></li><li><a href="http://solart.cc/2016/10/30/install_apk/">http://solart.cc/2016/10/30/install_apk/</a></li><li><a href="https://www.jianshu.com/p/4f16421d5c7f">https://www.jianshu.com/p/4f16421d5c7f</a></li></ul>
                </div>
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-d7a94ec6ab.css" rel="stylesheet">
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-49037e4d27.css" rel="stylesheet">
        </div>
    </article>