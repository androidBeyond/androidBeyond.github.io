 ---
layout:     post
title:      Android10应用启动与进程创建关系分析
subtitle:   android中弱化了进程的概念，取而代之的是四大组件，本篇文章我们就来学习一下应用和进程的关系
date:       2020-05-16
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - android
    - 组件学习
 --- 


<h1>1.概述</h1> 
<p>    上一节我们学习了Launcher的启动流程。这一节来介绍下应用进程的创建过程以及Zygote Fork的过程。</p> 
<p>    点击桌面图标启动应用概述&#xff1a;</p> 
<p>    在上一节Launcher的启动中我们知道了&#xff0c;手机的桌面其实就是Launcher进程&#xff0c;里面的应用图标都是Launcher通过ListView进行展示。</p> 
<p>    那么我们点击一个桌面图标&#xff0c;比如微信&#xff0c;这个应用是如何启动的呢&#xff0c;这一节我们从系统级的源码来一步步的进行分析。</p> 
<p>    在分析之前&#xff0c;我们简单区分一下进程和线程的概念。</p> 
<p>    在Android中通过Logcat抓取log时&#xff0c;存在PID和TID两个概念。</p> 
<p>    PID&#xff1a;Process ID&#xff0c;进程ID</p> 
<p>    TID: Thread ID&#xff0c;线程ID</p> 
<p>    每个Android都是一个进程&#xff0c;每个进程有一个或多个线程</p> 
<p> </p> 
<p><strong>进程&#xff1a;</strong></p> 
<p>    是并发执行的程序在执行过程中分配和管理资源的基本单位&#xff0c;是一个动态概念&#xff0c;竞争计算机系统资源的基本单位。</p> 
<p>当我们点击某个应用的图标时&#xff0c;必须创建一个进程&#xff0c;该进程是由Zygote fork出来的&#xff0c;进程具有独立的资源空间&#xff0c;用于承载App上运行的各种Activity/Service等组件。</p> 
<p><br /><strong>线程&#xff1a;</strong></p> 
<p>    是进程的一个执行单元&#xff0c;是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p> 
<p>每个应用有多个线程&#xff0c;例如UI展示属于UI主线程&#xff0c;一些通信过程属于独立线程&#xff0c;通常JAVA中使用new Thread().start()来创建一个新的线程。</p> 
<p>该线程并没有自己独立的地址空间&#xff0c;而是与其所在进程之间资源共享。</p> 
<p> </p> 
<p><strong>进程线程的区别</strong></p> 
<ol><li> <p>地址空间&#xff1a;同一进程的线程共享本进程的地址空间&#xff0c;而进程之间则是独立的地址空间。</p> </li><li> <p>资源拥有&#xff1a;同一进程内的线程共享本进程的资源&#xff0c;但是进程之间的资源是独立的。</p> </li><li> <p>一个进程崩溃后&#xff0c;在保护模式下不会对其他进程产生影响&#xff0c;但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p> </li><li> <p>进程切换时&#xff0c;消耗的资源大&#xff0c;效率高。所以涉及到频繁的切换时&#xff0c;使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作&#xff0c;只能用线程不能用进程。</p> </li><li> <p>执行过程&#xff1a;每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行&#xff0c;必须依存在应用程序中&#xff0c;由应用程序提供多个线程执行控制。</p> </li><li> <p>线程是处理器调度的基本单位&#xff0c;但是进程不是。</p> </li><li> <p>两者均可并发执行。</p> <p> </p> </li></ol>
<h1>2.核心源码</h1> 
<pre class="has"><code>/libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
/libcore/libart/src/main/java/java/lang/Daemons.java
/libcore/dalvik/src/main/java/dalvik/system/runtime.cc
/art/runtime/native/dalvik_system_ZygoteHooks.cc
/art/runtime/runtime.cc
/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp	

/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
/frameworks/base/core/java/com/android/internal/os/ZygoteServer.java
/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java
/frameworks/base/core/java/com/android/internal/os/Zygote.java
/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
/frameworks/base/services/java/com/android/server/SystemServer.java
/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
/frameworks/base/services/core/java/com/android/server/am/ProcessList.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityStartController.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java
/frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java
/frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java
/frameworks/base/services/core/java/com/android/server/wm/ClientLifecycleManager.java
/frameworks/base/core/java/android/os/Process.java
/frameworks/base/core/java/android/os/ZygoteProcess.java
/frameworks/base/core/java/android/app/LauncherActivity.java
/frameworks/base/core/java/android/app/ActivityThread.java
/frameworks/base/core/java/android/app/Activity.java
/frameworks/base/core/java/android/app/ActivityManagerInternal.java
/frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java
/frameworks/base/core/java/android/app/servertransaction/ClientTransaction.aidl
/frameworks/base/core/java/android/app/ClientTransactionHandler.java
/frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java
/frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java
/frameworks/base/core/java/android/app/Instrumentation.java
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code></pre> 
<h1>3.架构</h1> 
<p>    App发起进程&#xff1a;点击一个桌面应用(例如微信)&#xff0c;Launcher 加载应用&#xff0c; LauncherActivity收到触发事件&#xff0c;组装Intent&#xff0c;通过binder发送消息给SystemServer进程&#xff0c;调用Activity的startActivity()来启动进程&#xff0c;启动Activity时&#xff0c;受ActivityManagerService-AMS的服务控制&#xff0c;AMS属于SystemServer进程&#xff0c;因此SystemServer进行会通过Process 来向Zygote发送一个Socket。</p> 
<p>    Zygote有一个无限循环&#xff0c;一直在等待Socket请求&#xff0c;收到SystemServer发来新的Socket请求后&#xff0c;Zygote调用系统的fork函数来孵化一个新的进程&#xff0c;比如这里的微信。</p> 
<p>    再把启动的入口交给ActivityThread&#xff0c;进入微信的进程中&#xff0c;进行详细的UI展示。</p> 
<p> </p> 
<h2>3.1 进程创建图</h2> 
<p>    从点击Launcher中的图标&#xff0c;到启动Activity&#xff0c;再到Zygote Fork操作&#xff0c;最终进入新的进行进行UI绘制。</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102225207424.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h2>3.2 Zygote Fork图</h2> 
<p>    Zygote调用系统的fork()函数&#xff0c;孵化出一个新的进程&#xff0c;fork()采用copy-on-write机制&#xff0c;有些类如果不做改变&#xff0c;甚至都不用复制&#xff0c;子进程可以和父进程共享这部分数据&#xff0c;从而省去不少内存的占用。</p> 
<p> 图片来源Gityuan</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102225234844.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h1>4.源码分析</h1> 
<p>    应用的启动共分以下四个步骤完成&#xff1a;</p> 
<ol><li> <p>点击桌面的图标&#xff0c;Launcher调用系统的startActivity进行启动Activity&#xff0c;此时的动作在Launcher进程中</p> </li><li> <p>ATM\AMS 进行Activity的处理&#xff0c;组装message&#xff0c;通过socket发送给Socket</p> </li><li> <p>Zygote收到SystemServer发来的消息&#xff0c;进行消息拆分&#xff0c;再调用系统的fork()函数&#xff0c;进行进行孵化操作。</p> </li><li> <p>进入ActivityThread的main()&#xff0c;完成最终应用进程的的onCreate操作</p> </li></ol>
<p>    接下来我们根据这四个步骤来进行详细的源码分析.</p> 
<p> </p> 
<h2>4.1 第一阶段&#xff0c;点击桌面图标&#xff0c; 触发Launcher listview的点击事件 onListItemClick()</h2> 
<p><strong>说明&#xff1a;</strong>桌面图标按照5*5或者6*6的方式进行排列&#xff0c;这其实是Launcher进程展示的ListView&#xff0c;每个应用图标填入其中&#xff0c;点击图标进入Launcher的点击事件处理</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>[LauncherActivity.java] onListItemClick()
protected void onListItemClick(ListView l, View v, int position, long id) {
	//ListView的点击事件也就是桌面的Icon的点击事件 &#xff0c;这是整个启动流程的时间启动源。
    Intent intent &#61; intentForPosition(position); //构造一个Intent
    startActivity(intent); //启动Activity&#xff0c;参考[4.1.1]
}</code></pre> 
<h3>4.1.1 [Activity.java] startActivity()</h3> 
<p><strong>说明&#xff1a;</strong>这里比较简单&#xff0c;调用startActivityForResult()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void startActivity(Intent intent, &#64;Nullable Bundle options) {
    if (options !&#61; null) {
		//调用startActivityForResult()&#xff0c;参考[4.1.2]
        startActivityForResult(intent, -1, options);
    } else {
        startActivityForResult(intent, -1);
    }
}</code></pre> 
<h3>4.1.2 [Activity.java] startActivityForResult()</h3> 
<p><strong>说明&#xff1a;</strong>不难发现&#xff0c;不论有没有父Activity&#xff0c;最终都交给了 Instrumentation 来开启</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void startActivityForResult(&#64;RequiresPermission Intent intent, int requestCode,
        &#64;Nullable Bundle options) {
	//  Activity mParent;  其实是一个Activity &#xff0c;
	//判断是否有父类&#xff0c;没有父类的话交给Instrumentation
    if (mParent &#61;&#61; null) {
        options &#61; transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar &#61;
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar !&#61; null) {
			// 回调 ActivityResult
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode &gt;&#61; 0) {
            mStartedActivity &#61; true;
        }

        cancelInputsAndStartExitTransition(options);
        // TODO Consider clearing/flushing other event sources and events for child windows.
    } else {
        if (options !&#61; null) {
			//最终调用的还是Instrumentation 的 execStartActivity()&#xff0c;参考[4.1.3]
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            // Note we want to go through this method for compatibility with
            // existing applications that may have overridden it.
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}</code></pre> 
<h3>4.1.3  [Instrumentation.java]  execStartActivity()</h3> 
<p><strong>说明&#xff1a;</strong>Binder 调用 ActivityTaskManagerService-ATM 来启动 Activity</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
	...
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        // Binder 调用 ATM 来启动 Activity, 参考[4.2.1]
        int result &#61; ActivityTaskManager.getService()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target !&#61; null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
		// 检测启动结果
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException(&#34;Failure from system&#34;, e);
    }
    return null;
}</code></pre> 
<p>从下面代码可以看到&#xff0c;IActivityTaskManager其实获得的是activity_task对应服务的Binder对象&#xff0c;</p> 
<p>即是ActivityTaskManagerService-ATM</p> 
<pre class="has"><code>[ActivityTaskManager.java]
public static IActivityTaskManager getService() {
    return IActivityTaskManagerSingleton.get();
}

private static final Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton &#61;
    new Singleton&lt;IActivityTaskManager&gt;() {
        &#64;Override
        protected IActivityTaskManager create() {
			//获取服务&#xff1a;ACTIVITY_TASK_SERVICE &#61; &#34;activity_task&#34;&#xff0c;对应的服务为ATM-ActivityTaskManagerService
            final IBinder b &#61; ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
            return IActivityTaskManager.Stub.asInterface(b);
        }
};</code></pre> 
<h2><strong>4.2 第二阶段&#xff1a;</strong><strong>ATM\AMS 进行Activity的处理</strong></h2> 
<p>调用栈如下&#xff1a;</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102225809152.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h3>4.2.1 [ActivityTaskManagerService.java]  startActivity()</h3> 
<p><strong>说明&#xff1a;</strong>这里很简单&#xff0c;直接调用startActivityAsUser()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public final int startActivity(IApplicationThread caller, ...) {
	//参考[4.2.2]
    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
            resultWho, requestCode, startFlags, profilerInfo, bOptions,
            UserHandle.getCallingUserId());
}</code></pre> 
<h3>4.2.2 [ActivityTaskManagerService.java]  startActivityAsUser()</h3> 
<p><strong>说明&#xff1a;</strong>获取 ActivityStarter 对象,最终调用ActivityStarter的execute()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>int startActivityAsUser(IApplicationThread caller, String callingPackage,Intent intent, ...) {
	...
    // 获取 ActivityStarter 对象,最终调用ActivityStarter的execute(), 参考[4.2.3]
    return getActivityStartController().obtainStarter(intent, &#34;startActivityAsUser&#34;)
            .setCaller(caller)
            .setCallingPackage(callingPackage)
            .setResolvedType(resolvedType)
            .setResultTo(resultTo)
            .setResultWho(resultWho)
            .setRequestCode(requestCode)
            .setStartFlags(startFlags)
            .setProfilerInfo(profilerInfo)
            .setActivityOptions(bOptions)
            .setMayWait(userId)  //这里调用了setMayWait()&#xff0c;因此ActivityStarter中的mRequest.mayWait为true
            .execute();
}</code></pre> 
<h3>4.2.3 [ActivityStarter.java] execute()</h3> 
<p><strong>说明&#xff1a;</strong>根据[4.2.2]中调用了setMayWait&#xff0c;因此这里的mRequest.mayWait为true</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>int execute() {
    try {
        // setMayWait()  方法中将设置mayWait的值为true
        //HomeActivity不设置&#xff0c;值为0
        if (mRequest.mayWait) { 
			//应用进程走这一步&#xff0c;参考[4.2.4]
            return startActivityMayWait(mRequest.caller, mRequest.callingUid,
                    mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,
                    mRequest.intent, mRequest.resolvedType,
                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,
                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,
                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,
                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,
                    mRequest.inTask, mRequest.reason,
                    mRequest.allowPendingRemoteAnimationRegistryLookup,
                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);
        } else {
            //Home Activity走这一步
            return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,
                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,
                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,
                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,
                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,
                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,
                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,
                    mRequest.outActivity, mRequest.inTask, mRequest.reason,
                    mRequest.allowPendingRemoteAnimationRegistryLookup,
                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);
        }
    } finally {
        onExecutionComplete();
    }
}</code></pre> 
<h3>4.2.4 [ActivityStarter.java] startActivityMayWait()</h3> 
<p><strong>说明&#xff1a;</strong>调用startActivity()来启动Activity</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private int startActivityMayWait(IApplicationThread caller, ... WaitResult outResult,
        ...) {
        ...
        final ActivityRecord[] outRecord &#61; new ActivityRecord[1];
        //调用startActivity()来启动Activity,参考[4.2.5]
        int res &#61; startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,
                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,
                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,
                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,
                allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,
                allowBackgroundActivityStart);
        ...
        //通知ActivityMetricsLogger&#xff0c;activity已经被启动起来
        //ActivityMetricsLogger 将等待windows被绘制出来
        mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[0]);
        if (outResult !&#61; null) {
           // 设置启动结果
            outResult.result &#61; res;
            final ActivityRecord r &#61; outRecord[0];
            switch(res) {
                case START_SUCCESS: {
                    mSupervisor.mWaitingActivityLaunched.add(outResult);
                    do {
                        try {
                            // 启动成功&#xff0c;等待启动结果
                            mService.mGlobalLock.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (outResult.result !&#61; START_TASK_TO_FRONT
                            &amp;&amp; !outResult.timeout &amp;&amp; outResult.who &#61;&#61; null);
                    if (outResult.result &#61;&#61; START_TASK_TO_FRONT) {
                        res &#61; START_TASK_TO_FRONT;
                    }
                    break;
                }
                ...
            }
        }
        return res;
    }
}</code></pre> 
<h3>4.2.5 [ActivityStarter.java]   startActivity()</h3> 
<p><strong>说明&#xff1a;</strong>延时布局&#xff0c;然后通过startActivityUnchecked()来处理启动标记 flag &#xff0c;要启动的任务栈等&#xff0c;最后恢复布局</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity, boolean restrictedBgActivity) {
    ...
    try {
        //延时布局
        mService.mWindowManager.deferSurfaceLayout();
        //调用 startActivityUnchecked ,一路调用到 resumeFocusedStacksTopActivities()&#xff0c;参考[4.2.6]
        result &#61; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                startFlags, doResume, options, inTask, outActivity, restrictedBgActivity);
    } finally {
        //恢复布局
        mService.mWindowManager.continueSurfaceLayout();
    }
    ...
}</code></pre> 
<h3>4.2.6 [RootActivityContainer.java] resumeFocusedStacksTopActivities()</h3> 
<p><strong> 说明&#xff1a;</strong>获取栈顶的Activity&#xff0c;恢复它</p> 
<p><strong> 源码&#xff1a;</strong></p> 
<pre class="has"><code>boolean resumeFocusedStacksTopActivities(
        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
    ...
    //如果目标栈就是栈顶Activity&#xff0c;启动 resumeTopActivityUncheckedLocked()
    if (targetStack !&#61; null &amp;&amp; (targetStack.isTopStackOnDisplay()
        || getTopDisplayFocusedStack() &#61;&#61; targetStack)) {
    result &#61; targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
    ...
    if (!resumedOnDisplay) {
        // 获取  栈顶的 ActivityRecord
        final ActivityStack focusedStack &#61; display.getFocusedStack();
        if (focusedStack !&#61; null) {
            //最终调用 startSpecificActivityLocked(),参考[4.2.7]
            focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
    }
  }
}</code></pre> 
<h3>4.2.7 [ActivityStackSupervisor.java] startSpecificActivityLocked()</h3> 
<p><strong>说明&#xff1a;</strong>发布消息以启动进程&#xff0c;以避免在ATM锁保持的情况下调用AMS时可能出现死锁,最终调用到ATM的startProcess()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {
        ...
        //发布消息以启动进程&#xff0c;以避免在ATM锁保持的情况下调用AMS时可能出现死锁
        //最终调用到AMS的startProcess()&#xff0c;参考[4.2.8]
        final Message msg &#61; PooledLambda.obtainMessage(
                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,
                r.info.applicationInfo, knownToBeDead, &#34;activity&#34;, r.intent.getComponent());
        mService.mH.sendMessage(msg);
        ...
    }</code></pre> 
<h3>4.2.8 [ActivityManagerService.java] startProcess()</h3> 
<p><strong>说明&#xff1a;</strong>一路调用Process start()&#xff0c;最终到ZygoteProcess的attemptUsapSendArgsAndGetResult()&#xff0c;用来fork一个新的Launcher的进程</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void startProcess(String processName, ApplicationInfo info,
        boolean knownToBeDead, String hostingType, ComponentName hostingName) {
        ..
        //同步操作&#xff0c;避免死锁
        synchronized (ActivityManagerService.this) {
            //调用startProcessLocked,然后到 Process的start&#xff0c;最终到ZygoteProcess的attemptUsapSendArgsAndGetResult()
            //用来fork一个新的Launcher的进程&#xff0c;参考[4.2.9]
            startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */,
                    new HostingRecord(hostingType, hostingName),
                    false /* allowWhileBooting */, false /* isolated */,
                    true /* keepIfLarge */);
        }
        ...
}</code></pre> 
<p><strong>调用栈如下:</strong></p> 
<p><strong><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102230210296.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></strong></p> 
<h3>4.2.9 [ZygoteProcess.java]  attemptZygoteSendArgsAndGetResult()</h3> 
<p><strong>说明&#xff1a;</strong>通过Socket连接Zygote进程&#xff0c;把之前组装的msg发给Zygote&#xff0c;其中processClass &#61;&#34;android.app.ActivityThread&#34;&#xff0c;通过Zygote进程来Fork出一个新的进程&#xff0c;并执行 &#34;android.app.ActivityThread&#34;的main方法</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        //传入的zygoteState为openZygoteSocketIfNeeded()&#xff0c;里面会通过abi来检查是第一个zygote还是第二个
        final BufferedWriter zygoteWriter &#61; zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream &#61; zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);  //把应用进程的一些参数写给前面连接的zygote进程&#xff0c;包括前面的processClass &#61;&#34;android.app.ActivityThread&#34;
        zygoteWriter.flush(); //进入Zygote进程&#xff0c;处于阻塞状态&#xff0c; 参考[4.3]

         //从socket中得到zygote创建的应用pid&#xff0c;赋值给 ProcessStartResult的对象
        Process.ProcessStartResult result &#61; new Process.ProcessStartResult();
        result.pid &#61; zygoteInputStream.readInt();
        result.usingWrapper &#61; zygoteInputStream.readBoolean();

        if (result.pid &lt; 0) {
            throw new ZygoteStartFailedEx(&#34;fork() failed&#34;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        Log.e(LOG_TAG, &#34;IO Exception while communicating with Zygote - &#34;
                &#43; ex.toString());
        throw new ZygoteStartFailedEx(ex);
    }
}</code></pre> 
<h2>4.3 第三阶段 Zygote Fork 应用进程</h2> 
<p><strong>说明&#xff1a;</strong>Zygote的启动过程我们前面有详细讲到过。</p> 
<p>SystemServer的AMS服务向启动Home Activity发起一个fork请求&#xff0c;Zygote进程通过Linux的fork函数&#xff0c;孵化出一个新的进程。</p> 
<p>由于Zygote进程在启动时会创建Java虚拟机&#xff0c;因此通过fork而创建的Launcher程序进程可以在内部获取一个Java虚拟机的实例拷贝。</p> 
<p>fork采用copy-on-write机制&#xff0c;有些类如果不做改变&#xff0c;甚至都不用复制&#xff0c;子进程可以和父进程共享这部分数据&#xff0c;从而省去不少内存的占用。</p> 
<p><strong>调用栈如下&#xff1a;</strong></p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102230258628.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h3>4.3.1 [ZygoteInit.java] main()</h3> 
<p><strong>说明&#xff1a;</strong>Zygote先fork出SystemServer进程&#xff0c;接着进入循环等待&#xff0c;用来接收Socket发来的消息&#xff0c;用来fork出其他应用进程&#xff0c;比如Launcher</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public static void main(String argv[]) {
    ...
    Runnable caller;
    ....
    if (startSystemServer) {
        //Zygote Fork出的第一个进程 SystmeServer
        Runnable r &#61; forkSystemServer(abiList, zygoteSocketName, zygoteServer);

        if (r !&#61; null) {
            r.run();
            return;
        }
    }
    ...
    //循环等待fork出其他的应用进程&#xff0c;比如Launcher
    //最终通过调用processOneCommand()来进行进程的处理&#xff0c;参考[4.3.2]
    caller &#61; zygoteServer.runSelectLoop(abiList);
    ...
    if (caller !&#61; null) {
        caller.run(); //执行返回的Runnable对象&#xff0c;进入子进程
    }
}
</code></pre> 
<h3>4.3.2 [ZygoteConnection.java] processOneCommand()</h3> 
<p><strong>说明&#xff1a;</strong>通过 forkAndSpecialize()来fork出Launcher的子进程&#xff0c;并执行handleChildProc&#xff0c;进入子进程的处理</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>Runnable processOneCommand(ZygoteServer zygoteServer) {
    int pid &#61; -1;
    ...
    //Fork子进程&#xff0c;得到一个新的pid
    /fork子进程,采用copy on write方式&#xff0c;这里执行一次&#xff0c;会返回两次
    ///pid&#61;0 表示Zygote  fork子进程成功
    //pid &gt; 0 表示子进程 的真正的PID
	//参考[4.3.3]
    pid &#61; Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,
            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,
            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion);
    ...
    if (pid &#61;&#61; 0) {
        // in child, fork成功&#xff0c;第一次返回的pid &#61; 0
        ...
        //参考[4.3.7]
        return handleChildProc(parsedArgs, descriptors, childPipeFd,
                parsedArgs.mStartChildZygote);
    } else {
        //in parent
        ...
        childPipeFd &#61; null;
        handleParentProc(pid, descriptors, serverPipeFd);
        return null;
    }
}</code></pre> 
<h3>4.3.3 [Zygote.java] forkAndSpecialize</h3> 
<p><strong>说明&#xff1a;</strong>主要是调用dalvik中ZygoteHooks的preFrok进行预处理&#xff0c;再调用postForkCommon进行完成的进程fork</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags,
        int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
        int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir,
        int targetSdkVersion) {
    ZygoteHooks.preFork(); //参考[4.3.3.1]
	//参考[4.3.5]
	int pid &#61; nativeForkAndSpecialize(
                uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
                fdsToIgnore, startChildZygote, instructionSet, appDataDir);
	...
	//参考[4.3.6]
    ZygoteHooks.postForkCommon();
    return pid;
}</code></pre> 
<h3>4.3.3.1 [ZygoteHooks.java] preFork()</h3> 
<p>说明&#xff1a;Zygote进程有4个Daemon子线程分别是 &#xff1a;</p> 
<p>HeapTaskDaemon、ReferenceQueueDaemon、FinalizerDaemon、FinalizerWatchdogDaemon</p> 
<p>preFork()预处理主要是先停止4个子线程&#xff0c;等待所有的子线程结束&#xff0c;最后完成gc堆的初始化工作</p> 
<p><strong>Zygote子线程如下图所示&#xff1a;</strong></p> 
<p><img alt="" class="has" height="96" src="https://img-blog.csdnimg.cn/20200102230633607.jpg" width="684" /></p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void preFork() {
    Daemons.stop();	//停止4个Daemon子线程&#xff0c;参考[4.3.3.2]
    waitUntilAllThreadsStopped();	//等待所有子线程结束&#xff0c;参考[4.3.3.3]
    token &#61; nativePreFork();	//完成gc堆的初始化工作&#xff0c;参考[4.3.4]
}</code></pre> 
<h3>4.3.3.2 [Daemons.java] stop()</h3> 
<p><strong>说明&#xff1a;</strong>此处守护线程Stop方式是先调用目标线程interrrupt()方法&#xff0c;然后再调用目标线程join()方法&#xff0c;等待线程执行完成</p> 
<p>停止4个子线程&#xff0c;分别是&#xff1a;Java堆整理线程&#xff1b;引用队列线程&#xff1b;析构线程&#xff1b;析构监控线程</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private static final Daemon[] DAEMONS &#61; new Daemon[] {
    HeapTaskDaemon.INSTANCE,  //Java堆整理线程
    ReferenceQueueDaemon.INSTANCE,  //引用队列线程
    FinalizerDaemon.INSTANCE,//析构线程
    FinalizerWatchdogDaemon.INSTANCE, //析构监控线程
};

public static void stop() {
    for (Daemon daemon : DAEMONS) {
        daemon.stop(); //循环停止线程
    }
}</code></pre> 
<h3>4.3.3.3 [ZygoteHooks.java] waitUntilAllThreadsStopped()</h3> 
<p><strong>说明&#xff1a;</strong>等待所有子线程结束</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private static void waitUntilAllThreadsStopped() {
    File tasks &#61; new File(&#34;/proc/self/task&#34;);
	// 当/proc中线程数大于1&#xff0c;就出让CPU直到只有一个线程&#xff0c;才退出循环
    while (tasks.list().length &gt; 1) {
      Thread.yield();
    }
}</code></pre> 
<h3>4.3.4 [ZygoteHooks.java] nativePreFork()</h3> 
<p>通过JNI最终调用的是以下方法&#xff1a;</p> 
<p>[dalvik_system_ZygoteHooks.cc] ZygoteHooks_nativePreFork()</p> 
<p><strong>说明&#xff1a;</strong>进行堆的一些预处理</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {
  Runtime* runtime &#61; Runtime::Current();
  CHECK(runtime-&gt;IsZygote()) &lt;&lt; &#34;runtime instance not started with -Xzygote&#34;;

  runtime-&gt;PreZygoteFork(); //参考[4.3.4.1]

  //将线程转换为long型并保存到token&#xff0c;该过程是非安全的
  return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));
}</code></pre> 
<h3>4.3.4.1 [runtime.cpp] PreZygoteFork()</h3> 
<p><strong>说明&#xff1a;</strong>堆的初始化工作&#xff0c;属于虚拟机的范畴&#xff0c;想理解的可以深挖一下</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>void Runtime::PreZygoteFork() {
  if (GetJit() !&#61; nullptr) {
    GetJit()-&gt;PreZygoteFork();
  }

  // 初始化堆的操作
  heap_-&gt;PreZygoteFork();
}</code></pre> 
<h3>4.3.5 [Zygote.java] nativeForkAndSpecialize()</h3> 
<p>通过JNI最终调用的是以下方法&#xff1a;</p> 
<p>[com_android_internal_os_Zygote.cpp] com_android_internal_os_Zygote_nativeForkAndSpecialize</p> 
<p><strong>说明&#xff1a;</strong> fork 子进程</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(...) {
	...
	//fork 应用进程&#xff0c;得到新的pid&#xff0c;fork()操作会有两次返回&#xff0c;第一次返回成功&#xff0c;pid&#61;0
	//第二次返回真正的pid
	//参考[4.3.5.1]
	pid_t pid &#61; ForkCommon(env, false, fds_to_close, fds_to_ignore);
	if (pid &#61;&#61; 0) {
	  //上面第一次fork成功
	  //参考[4.3.5.2]
      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,
                       capabilities, capabilities,
                       mount_external, se_info, nice_name, false,
                       is_child_zygote &#61;&#61; JNI_TRUE, instruction_set, app_data_dir);
    }
    return pid;
}</code></pre> 
<h3>4.3.5.1 [com_android_internal_os_Zygote.cpp] ForkCommon()</h3> 
<p><strong>说明&#xff1a;</strong>调用系统的fork()进行 应用进程的孵化操作&#xff0c;采用copy-on-write的机制&#xff0c;使得应用进程与Zygote共享部分数据&#xff0c;减少内存的占用</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>static pid_t ForkCommon(JNIEnv* env, bool is_system_server,..) {
  //设置子进程的signal
  SetSignalHandlers();
  ...
  //fork子进程,这里执行一次&#xff0c;会返回两次
  //pid&#61;0 表示Zygote  fork SystemServer这个子进程成功
  //pid &gt; 0 表示SystemServer 的真正的PID
  pid_t pid &#61; fork();
  if (pid &#61;&#61; 0) {
     //进入子进程
    PreApplicationInit();
    // 关闭并清除文件描述符
    DetachDescriptors(env, fds_to_close, fail_fn);
    ClearUsapTable();
	...
  } else {
    ALOGD(&#34;Forked child process %d&#34;, pid);
  }
  return pid;
}</code></pre> 
<h3><strong>4.3.5.2 [com_android_internal_os_Zygote.cpp]   SpecializeCommon()</strong></h3> 
<p><strong>说明&#xff1a;</strong>进行进程的一些资源处理&#xff0c;selinux权限处理&#xff0c;并调用Zygote的callPostForkChildHooks()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>static void SpecializeCommon(...){
	...
  if (!is_system_server &amp;&amp; getuid() &#61;&#61; 0) {
    //对于非system_server子进程&#xff0c;则创建进程组
    const int rc &#61; createProcessGroup(uid, getpid());
	...
  }
  SetGids(env, gids, fail_fn);  //设置设置group
  SetRLimits(env, rlimits, fail_fn); //设置资源limit
  ...
   //selinux上下文
  if (selinux_android_setcontext(uid, is_system_server, se_info_ptr, nice_name_ptr) &#61;&#61; -1) {
	...
  }
  ...
  //设置子进程的signal信号处理函数为默认函数
  UnsetChldSignalHandler();
   //等价于调用zygote.callPostForkChildHooks(), 参考[4.3.5.3]
  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,
                            is_system_server, is_child_zygote, managed_instruction_set);
}</code></pre> 
<h3>4.3.5.3 [Zygote.java]  callPostForkChildHooks()</h3> 
<p><strong>说明&#xff1a;</strong>JAVA堆线程的一些处理</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>    private static void callPostForkChildHooks(int runtimeFlags, boolean isSystemServer,
            boolean isZygote, String instructionSet) {
        ZygoteHooks.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);
    }

[ZygoteHooks.java] postForkChild 
public void postForkChild(int runtimeFlags, boolean isSystemServer, boolean isZygote,
        String instructionSet) {
	//JNI调用到 ZygoteHooks_nativePostForkChild()
    nativePostForkChild(token, runtimeFlags, isSystemServer, isZygote, instructionSet);
    Math.setRandomSeedInternal(System.currentTimeMillis());
}

[dalvik_system_ZygoteHooks.cc] ZygoteHooks_nativePostForkChild()
static void ZygoteHooks_nativePostForkChild(...) {
  Thread* thread &#61; reinterpret_cast&lt;Thread*&gt;(token);
  //设置新进程的主线程id
  thread-&gt;InitAfterFork();
  ...
   if (instruction_set !&#61; nullptr &amp;&amp; !is_system_server) {
	...
	//调用runtime的InitNonZygoteOrPostFork()进行处理
    Runtime::Current()-&gt;InitNonZygoteOrPostFork(
        env, is_system_server, action, isa_string.c_str());
  } else {
    Runtime::Current()-&gt;InitNonZygoteOrPostFork(
        env,
        is_system_server,
        Runtime::NativeBridgeAction::kUnload,
        /*isa*/ nullptr,
        profile_system_server);
  }
}</code></pre> 
<p><strong>创建JAVA的线程池&#xff0c;设置信号处理&#xff0c;启动JDWP线程</strong></p> 
<p> </p> 
<pre class="has"><code>[runtime.cc] InitNonZygoteOrPostFork()
void Runtime::InitNonZygoteOrPostFork(...) {
  is_zygote_ &#61; false;

  if (is_native_bridge_loaded_) {
    switch (action) {
      case NativeBridgeAction::kUnload:
        UnloadNativeBridge();  //卸载用于跨平台的桥连库
        is_native_bridge_loaded_ &#61; false;
        break;

      case NativeBridgeAction::kInitialize:
        InitializeNativeBridge(env, isa); //初始化用于跨平台的桥连库
        break;
    }
  }

  //创建Java堆处理的线程池
  heap_-&gt;CreateThreadPool();
  //重置gc性能数据&#xff0c;以保证进程在创建之前的GCs不会计算到当前app上。
  heap_-&gt;ResetGcPerformanceInfo();
  ...
  StartSignalCatcher();//设置信号处理函数

  //启动JDWP线程&#xff0c;当命令debuger的flags指定&#34;suspend&#61;y&#34;时&#xff0c;则暂停runtime
  ScopedObjectAccess soa(Thread::Current());
  GetRuntimeCallbacks()-&gt;StartDebugger();
}</code></pre> 
<h3>4.3.6 [ZygoteHooks.java] postForkCommon()</h3> 
<p><strong>说明&#xff1a;</strong>在fork新进程后&#xff0c;启动Zygote的4个Daemon线程&#xff0c;java堆整理&#xff0c;引用队列&#xff0c;以及析构线程。</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public void postForkCommon() {
    Daemons.startPostZygoteFork();
    nativePostZygoteFork();
}</code></pre> 
<p><strong>启动Zygote的4个新的子线程</strong></p> 
<p> </p> 
<pre class="has"><code>[Daemons.java]
private static final Daemon[] DAEMONS &#61; new Daemon[] {
    HeapTaskDaemon.INSTANCE,         //Java堆整理线程
    ReferenceQueueDaemon.INSTANCE,   //引用队列线程
    FinalizerDaemon.INSTANCE,        //析构线程
    FinalizerWatchdogDaemon.INSTANCE, //析构监控线程
};

public static void startPostZygoteFork() {
    postZygoteFork &#61; true;
    for (Daemon daemon : DAEMONS) {
        daemon.startPostZygoteFork();
    }
}</code></pre> 
<h3>4.3.7 [ZygoteConnection.java] handleChildProc()</h3> 
<p><strong>说明&#xff1a;</strong>进行子进程的操作&#xff0c;最终获得需要执行的ActivityThread的main()</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor[] descriptors,
        FileDescriptor pipeFd, boolean isZygote) {
    ...
    if (parsedArgs.mInvokeWith !&#61; null) {
        ...
        throw new IllegalStateException(&#34;WrapperInit.execApplication unexpectedly returned&#34;);
    } else {
        if (!isZygote) {
            // App进程将会调用到这里&#xff0c;执行目标类的main()方法
            return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                    parsedArgs.mRemainingArgs, null /* classLoader */);
        } else {
            return ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,
                    parsedArgs.mRemainingArgs, null /* classLoader */);
        }
    }
}</code></pre> 
<p><strong>zygoteInit 进行一些环境的初始化、启动Binder进程等操作</strong></p> 
<pre class="has"><code>public static final Runnable zygoteInit(int targetSdkVersion, String[] argv,
        ClassLoader classLoader) {
    RuntimeInit.commonInit(); //初始化运行环境 
    ZygoteInit.nativeZygoteInit(); //启动Binder线程池 
     //调用程序入口函数  
    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}
</code></pre> 
<p><strong>把之前传来的&#34;android.app.ActivityThread&#34; 传递给findStaticMain</strong></p> 
<pre class="has"><code>protected static Runnable applicationInit(int targetSdkVersion, String[] argv,
        ClassLoader classLoader) {
    ...
    // startClass: 如果AMS通过socket传递过来的是 ActivityThread
    return findStaticMain(args.startClass, args.startArgs, classLoader);
}</code></pre> 
<p><strong>通过反射&#xff0c;拿到ActivityThread的main()方法</strong></p> 
<pre class="has"><code>protected static Runnable findStaticMain(String className, String[] argv,
        ClassLoader classLoader) {
    Class&lt;?&gt; cl;

    try {
        cl &#61; Class.forName(className, true, classLoader);
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                &#34;Missing class when invoking static main &#34; &#43; className,
                ex);
    }

    Method m;
    try {
        m &#61; cl.getMethod(&#34;main&#34;, new Class[] { String[].class });
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(
                &#34;Missing static main on &#34; &#43; className, ex);
    } catch (SecurityException ex) {
        throw new RuntimeException(
                &#34;Problem getting static main on &#34; &#43; className, ex);
    }

    int modifiers &#61; m.getModifiers();
    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {
        throw new RuntimeException(
                &#34;Main method is not public and static on &#34; &#43; className);
    }
    return new MethodAndArgsCaller(m, argv);
}</code></pre> 
<p><strong>把反射得来的ActivityThread main()入口返回给ZygoteInit的main&#xff0c;通过caller.run()进行调用</strong></p> 
<p> </p> 
<pre class="has"><code>static class MethodAndArgsCaller implements Runnable {
    /** method to call */
    private final Method mMethod;

    /** argument array */
    private final String[] mArgs;

    public MethodAndArgsCaller(Method method, String[] args) {
        mMethod &#61; method;
        mArgs &#61; args;
    }

    //调用ActivityThread的main()
    public void run() {
        try {
            mMethod.invoke(null, new Object[] { mArgs });
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(ex);
        } catch (InvocationTargetException ex) {
            Throwable cause &#61; ex.getCause();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else if (cause instanceof Error) {
                throw (Error) cause;
            }
            throw new RuntimeException(ex);
        }
    }
}</code></pre> 
<p>至此&#xff0c;Zygote fork进程的操作全部完成&#xff0c;下一步进入JAVA世界&#xff0c;进行真正的Activity的启动流程。</p> 
<p> </p> 
<h2>4.4 第四阶段 进入应用进程&#xff0c;启动Activity的onCreate()</h2> 
<p><strong>调用栈如下&#xff1a;</strong></p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102231344623.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<h3>4.4.1 [ActivityThread.java] main()</h3> 
<p><strong>说明&#xff1a; </strong>主线程处理&#xff0c; 创建ActivityThread对象&#xff0c;调用attach进行处理&#xff0c;最终进入Looper循环</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public static void main(String[] args) {
    // 安装选择性的系统调用拦截
    AndroidOs.install();
	...
	//主线程处理
    Looper.prepareMainLooper();
	...
	
	//之前SystemServer调用attach传入的是true&#xff0c;这里到应用进程传入false就行
    ActivityThread thread &#61; new ActivityThread();
    thread.attach(false, startSeq);
	...
	//一直循环&#xff0c;如果退出&#xff0c;说明程序关闭
    Looper.loop();

    throw new RuntimeException(&#34;Main thread loop unexpectedly exited&#34;);
}</code></pre> 
<p><strong>调用ActivityThread的attach进行处理</strong></p> 
<p> </p> 
<pre class="has"><code>   private void attach(boolean system, long startSeq) {
    sCurrentActivityThread &#61; this;
    mSystemThread &#61; system;
    if (!system) {
        //应用进程启动&#xff0c;走该流程
		...
        RuntimeInit.setApplicationObject(mAppThread.asBinder());
         //获取AMS的本地代理类
        final IActivityManager mgr &#61; ActivityManager.getService();
        try {
            //通过Binder调用AMS的attachApplication方法&#xff0c;参考[4.4.2]
            mgr.attachApplication(mAppThread, startSeq);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
		...
    } else {
        //通过system_server启动ActivityThread对象
        ...
    }

    // 为 ViewRootImpl 设置配置更新回调&#xff0c;
  //当系统资源配置&#xff08;如&#xff1a;系统字体&#xff09;发生变化时&#xff0c;通知系统配置发生变化
    ViewRootImpl.ConfigChangedCallback configChangedCallback
            &#61; (Configuration globalConfig) -&gt; {
        synchronized (mResourcesManager) {
			...
        }
    };
    ViewRootImpl.addConfigCallback(configChangedCallback);
}</code></pre> 
<h3>4.4.2  [ActivityManagerService.java] attachApplication()</h3> 
<p><strong>说明&#xff1a;</strong>清除一些无用的记录&#xff0c;最终调用ActivityStackSupervisor.java的 realStartActivityLocked()&#xff0c;进行Activity的启动</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public final void attachApplication(IApplicationThread thread, long startSeq) {
    synchronized (this) {
		//通过Binder获取传入的pid信息
        int callingPid &#61; Binder.getCallingPid();
        final int callingUid &#61; Binder.getCallingUid();
        final long origId &#61; Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid, callingUid, startSeq);
        Binder.restoreCallingIdentity(origId);
    }
}
private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid, int callingUid, long startSeq) {
	...
    //如果当前的Application记录仍然依附到之前的进程中&#xff0c;则清理掉
    if (app.thread !&#61; null) {
        handleAppDiedLocked(app, true, true);
    }·

    //mProcessesReady这个变量在AMS的 systemReady 中被赋值为true&#xff0c;
    //所以这里的normalMode也为true
    boolean normalMode &#61; mProcessesReady || isAllowedWhileBooting(app.info);
	...
    //上面说到&#xff0c;这里为true&#xff0c;进入StackSupervisor的attachApplication方法
    //去真正启动Activity
    if (normalMode) {
		...
			//调用ATM的attachApplication()&#xff0c;最终层层调用到ActivityStackSupervisor.java的 realStartActivityLocked()
			//参考[4.4.3]
            didSomething &#61; mAtmInternal.attachApplication(app.getWindowProcessController());
		...
    }
	...
    return true;
}</code></pre> 
<h3>4.4.3 [ActivityStackSupervisor.java]  realStartActivityLocked()</h3> 
<p><strong>说明&#xff1a;</strong>真正准备去启动Activity&#xff0c;通过clientTransaction.addCallback把LaunchActivityItem的obtain作为回调参数加进去&#xff0c;再调用</p> 
<p>ClientLifecycleManager.scheduleTransaction()得到LaunchActivityItem的execute()方法进行最终的执行</p> 
<p>参考上面的第四阶段的调用栈流程&#xff1a;</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200102231542221.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<p><strong>源码&#xff1a;</strong></p> 
<p> </p> 
<pre class="has"><code> boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
        boolean andResume, boolean checkConfig) throws RemoteException {
     // 直到所有的 onPause() 执行结束才会去启动新的 activity
    if (!mRootActivityContainer.allPausedActivitiesComplete()) {
		...
        return false;
    }
	try {
            // Create activity launch transaction.
            // 添加 LaunchActivityItem
            final ClientTransaction clientTransaction &#61; ClientTransaction.obtain(
                    proc.getThread(), r.appToken);
			//LaunchActivityItem.obtain(new Intent(r.intent)作为回调参数
            clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
                    System.identityHashCode(r), r.info,
                    // TODO: Have this take the merged configuration instead of separate global
                    // and override configs.
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),
                    r.icicle, r.persistentState, results, newIntents,
                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),
                            r.assistToken));

			...
			// 设置生命周期状态
            final ActivityLifecycleItem lifecycleItem;
            if (andResume) {
                lifecycleItem &#61; ResumeActivityItem.obtain(dc.isNextTransitionForward());
            } else {
                lifecycleItem &#61; PauseActivityItem.obtain();
            }
            clientTransaction.setLifecycleStateRequest(lifecycleItem);

            // Schedule transaction.
            // 重点关注&#xff1a;调用 ClientLifecycleManager.scheduleTransaction()&#xff0c;得到上面addCallback的LaunchActivityItem的execute()方法
			//参考[4.4.4]
            mService.getLifecycleManager().scheduleTransaction(clientTransaction);

        } catch (RemoteException e) {
            if (r.launchFailed) {
                 // 第二次启动失败&#xff0c;finish activity
                stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,
                        &#34;2nd-crash&#34;, false);
                return false;
            }
            // 第一次失败&#xff0c;重启进程并重试
            r.launchFailed &#61; true;
            proc.removeActivity(r);
            throw e;
        }
    } finally {
        endDeferResume();
    }
	...
    return true;
}</code></pre> 
<h3>4.4.4 [TransactionExecutor.java] execute()</h3> 
<p><strong>说明&#xff1a;</strong>执行之前realStartActivityLocked()中的 clientTransaction.addCallback</p> 
<p><strong>调用栈&#xff1a;</strong></p> 
<p><strong><img alt="" class="has" height="225" src="https://img-blog.csdnimg.cn/20200102231622799.png" width="280" /></strong></p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>  public void execute(ClientTransaction transaction) {
	...
     // 执行 callBack&#xff0c;参考上面的调用栈&#xff0c;执行回调方法&#xff0c;
	 //最终调用到ActivityThread的handleLaunchActivity()参考[4.4.5]
    executeCallbacks(transaction);

     // 执行生命周期状态
    executeLifecycleState(transaction);
    mPendingActions.clear();
}</code></pre> 
<h3>4.4.5 [ActivityThread.java] handleLaunchActivity()</h3> 
<p><strong>说明&#xff1a;</strong>主要干了两件事&#xff0c;第一件&#xff1a;初始化WindowManagerGlobal&#xff1b;第二件&#xff1a;调用performLaunchActivity方法</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>public Activity handleLaunchActivity(ActivityClientRecord r,
        PendingTransactionActions pendingActions, Intent customIntent) {
	...
	//初始化WindowManagerGlobal
    WindowManagerGlobal.initialize();
	...
	//调用performLaunchActivity&#xff0c;来处理Activity&#xff0c;参考[4.4.6]
    final Activity a &#61; performLaunchActivity(r, customIntent);
	..
    return a;
}</code></pre> 
<h3>4.4.6 [ActivityThread.java] performLaunchActivity()</h3> 
<p><strong>说明&#xff1a;</strong>获取ComponentName、Context&#xff0c;反射创建Activity&#xff0c;设置Activity的一些内容&#xff0c;比如主题等&#xff1b;</p> 
<p>最终调用callActivityOnCreate()来执行Activity的onCreate()方法</p> 
<p><strong>源码&#xff1a;</strong></p> 
<pre class="has"><code>  private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
     // 获取 ComponentName
    ComponentName component &#61; r.intent.getComponent();
	...
     // 获取 Context
    ContextImpl appContext &#61; createBaseContextForActivity(r);
    Activity activity &#61; null;
    try {
         // 反射创建 Activity
        java.lang.ClassLoader cl &#61; appContext.getClassLoader();
        activity &#61; mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state !&#61; null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
		...
    }

    try {
        // 获取 Application
        Application app &#61; r.packageInfo.makeApplication(false, mInstrumentation);
        if (activity !&#61; null) {
			...
			//Activity的一些处理
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window, r.configCallback,
                    r.assistToken);

            if (customIntent !&#61; null) {
                activity.mIntent &#61; customIntent;
            }
			...
            int theme &#61; r.activityInfo.getThemeResource();
            if (theme !&#61; 0) {
              // 设置主题
                activity.setTheme(theme);
            }

            activity.mCalled &#61; false;
            // 执行 onCreate()
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }
			...
            r.activity &#61; activity;
        }
		//当前状态为ON_CREATE
        r.setState(ON_CREATE);
		...
    } catch (SuperNotCalledException e) {
        throw e;
    } catch (Exception e) {
		...
    }
    return activity;
}</code></pre> 
<p><strong>callActivityOnCreate先执行activity onCreate的预处理&#xff0c;再去调用Activity的onCreate&#xff0c;最终完成Create创建后的内容处理</strong></p> 
<p> </p> 
<p> </p> 
<pre class="has"><code>public void callActivityOnCreate(Activity activity, Bundle icicle,
        PersistableBundle persistentState) {
    prePerformCreate(activity); //activity onCreate的预处理
    activity.performCreate(icicle, persistentState);//执行onCreate()
    postPerformCreate(activity); //activity onCreate创建后的一些信息处理
}</code></pre> 
<p><strong>performCreate()主要调用Activity的onCreate()</strong></p> 
<p> </p> 
<pre class="has"><code>final void performCreate(Bundle icicle, PersistableBundle persistentState) {
	...
    if (persistentState !&#61; null) {
        onCreate(icicle, persistentState);
    } else {
        onCreate(icicle);
    }
	...
}</code></pre> 
<p>  至此&#xff0c;看到了我们最熟悉的Activity的onCreate()&#xff0c;应用启动的启动完成&#xff0c;应用程序被真正的调用起来。</p> 
<p> </p> 
<h1>5.总结</h1> 
<p>    通过上面一系列的流程&#xff0c;我们理解了应用进程的创建流程&#xff0c;以及Zygote fork这些应用进程的流程。</p> 
<p>主要分为4步完成&#xff1a;</p> 
<ol><li> <p>点击桌面的图标&#xff0c;Launcher调用系统的startActivity进行启动Activity&#xff0c;此时的动作在Launcher进程中</p> </li><li> <p>通过Binder向SystemServer进行发送消息&#xff0c;让ATM\AMS 进行Activity的处理&#xff0c;组装message&#xff0c;通过socket发送给Socket&#xff0c;此时动作在SystemServer进程中</p> </li><li> <p>Zygote收到SystemServer发来的消息&#xff0c;进行消息拆分&#xff0c;再调用系统的fork()函数&#xff0c;进行进行孵化操作&#xff0c;此时动作在Zygote进程中</p> </li><li> <p>进入ActivityThread的main()&#xff0c;完成最终应用进程的的onCreate操作&#xff0c;该步动作处于新创建的应用进程中</p> </li></ol>
