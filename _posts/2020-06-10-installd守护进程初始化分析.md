---
layout:     post
title:      Android10 APK安装过程分析
subtitle:   本篇文章我们来学习一下APK安装的过程
date:       2020-06-10
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - Android
    - framework
---
 
<h1>1.概述</h1> 
<p>Android应用安装有如下四种方式&#xff1a;</p> 
<ul><li> <p>1)系统应用和预制应用安装――开机时完成&#xff0c;没有安装界面&#xff0c;在PKMS的构造函数中完成安装</p> </li><li> <p>2)网络下载应用安装――通过应用商店应用完成&#xff0c;调用PackageManager.installPackages()&#xff0c;有安装界面。</p> </li><li> <p>3)ADB工具安装――没有安装界面&#xff0c;它通过启动pm脚本的形式&#xff0c;然后调用com.android.commands.pm.Pm类&#xff0c;之后调用到PMS.installStage()完成安装。</p> </li><li> <p>4)第三方应用安装――通过SD卡里的APK文件安装&#xff0c;有安装界面&#xff0c;由packageinstaller.apk应用处理安装及卸载过程的界面。</p> </li></ul>
<p>上述几种方式均通过<strong>PackageInstallObserver来监听安装是否成功</strong>。</p> 
<p> </p> 
<h1>2.代码路径</h1> 
<pre class="has"><code>/frameworks/base/packages/apps/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
/frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java
/frameworks/base/core/java/android/content/pm/IPackageInstallerSession.aidl 
/frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java 
/frameworks/base/services/core/java/com/android/server/pm/Installer.java
/system/core/adb/client/commandline.cpp
/system/core/adb/client/adb_install.cpp
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerShellCommand.java</code></pre> 
<h1>3.APK的包组成</h1> 
<p>    生成的APK文件本质还是一个zip文件&#xff0c;只不过被Google强行修改了一下后缀名称而已。所以我们将APK的后缀修改成.zip就可以查看其包含的内容了。</p> 
<p>如下图所示&#xff1a;</p> 
<p><img alt="" class="has" height="140" src="https://img-blog.csdnimg.cn/20200122223311652.png" width="275" /></p> 
<ul><li> <p>META-INF&#xff1a;关于签名的信息存放&#xff0c;应用安装验证签名的时候会验证该文件里面的信息 -res&#xff1a;资源文件&#xff0c;是被编译过的。raw和图片是保持原样的&#xff0c;但是其他的文件会被编译成二进制文件。</p> </li><li> <p>res&#xff1a;这里面的资源是不经过编译原样打包进来的</p> </li><li> <p>AndroidManifest.xml&#xff1a;程序全局配置文件。该文件是每个应用程序都必须定义和包含的文件&#xff0c;它描述了应用程序的名字、版本、权限、引用的库文件等等信息。</p> </li><li> <p>classes.dex&#xff1a;Dalvik字节码文件&#xff0c;Android会将所有的class文件全部放到这一个文件里。</p> </li><li> <p>resources.arsc&#xff1a;编译后的二进制资源文件&#xff0c;保存资源文件的索引&#xff0c;由aapt生成</p> </li><li> <p>lib: 如果存在的话&#xff0c;存放的是ndk编出来的so库</p> </li></ul>
<h1>4.APK的打包过程</h1> 
<p>打包具体步骤如下图所示&#xff1a;</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200122223421777.png?x-oss-process&#61,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<p>编译器将源代码转换成DEX&#xff08;Dalvik Executable) 文件&#xff0c;将资源文件转换成已编译资源。</p> 
<p>    APK打包器将DEX文件和已编译资源合并成单个APK。不过&#xff0c;必须先将APK签名&#xff0c;才能将应用安装并部署到Android设备上。</p> 
<p>    APK打包器使用密钥签署APK&#xff1a;a. 如果构建的APK是debug版本&#xff0c;那么将使用调试密钥签名&#xff0c;Android会默认提供一个debug的密钥。b. 如果构建的是release版本&#xff0c;会使用发布版本的密钥签名。</p> 
<p>    在生成最终的APK文件之前还会使用zipalign工具来优化文件。</p> 
<h1>5.APK SignatureSchemev2</h1> 
<p>    使用V2的原因Android7.0(Nougat)引入一项新的应用签名方案APK SignatureSchemev2,它是一个对全文件进行签名的方案,能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护.v2signature官方解释同时V2方案对V1方案做了&#43;很好的兼容处理(Apk中同时存在v1,v2签名)。</p> 
<p>    V1签名apk-signature-v1-location.png只是校验了apk资源,并没有约束zip,签名信息存储在zip/META-INF中。</p> 
<p>    APK Signature Scheme v2,它是一个对全文件进行签名的方案,能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护.</p> 
<p>如下图所示&#xff1a;</p> 
<p><img alt="" class="has" height="152" src="https://img-blog.csdnimg.cn/20200122223454463.png" width="835" /></p> 
<p>  新的签名方案会在ZIP文件格式的 Central Directory 区块所在文件位置的前面添加一个APK Signing Block区块&#xff0c;下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。整个APK&#xff08;ZIP文件格式&#xff09;会被分为以下四个区块&#xff1a;</p> 
<ul><li> <p>Contents of ZIP entries&#xff08;from offset 0 until the start of APK Signing Block&#xff09;</p> </li><li> <p>APK Signing Block</p> </li><li> <p>ZIP Central Directory</p> </li><li> <p>ZIP End of Central Directory</p> </li></ul>
<p>    新应用签名方案的签名信息会被保存在区块2&#xff08;APK Signing Block&#xff09;中&#xff0c; 而区块1&#xff08;Contents of ZIP entries&#xff09;、区块3&#xff08;ZIP Central Directory&#xff09;、区块4&#xff08;ZIP End of Central Directory&#xff09;是受保护的&#xff0c;在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。</p> 
<p> </p> 
<h1>6.APK的安装过程</h1> 
<p>    这里我们主要来讲解下载APK后&#xff0c;点击进行安装的过程。</p> 
<p>  <strong>  简单来说分为四步&#xff1a;</strong></p> 
<ul><li> <p>1)将APK的信息通过IO流的形式写入到PackageInstaller.Session中。</p> </li><li> <p>2)调用PackageInstaller.Session的commit方法&#xff0c;将APK的信息交由PKMS处理。</p> </li><li> <p>3)拷贝APK</p> </li><li> <p>4)最后进行安装</p> </li></ul>
<p> </p> 
<p><strong>涉及的Binder服务&#xff1a;</strong></p> 
<ul><li> <p>1)PackageManager&#xff08;抽象类&#xff09;----IPackageManager------ PKMS</p> </li></ul>
<p>(实现类&#xff1a;ApplicationPackageManager )</p> 
<ul><li> <p>2)PackageInstaller-----IPackageInstaller------PackageInstallerService</p> </li></ul>
<p>&#xff08;其中会调用IPackageInstaller对象调用PackageInstallerService中的接口&#xff09;</p> 
<ul><li> <p>3)PackageInstaller.Session-----IPackageInstallerSession------ PackageInstallerSession</p> </li></ul>
<p>    &#xff08;PackageInstaller.Session中有IPackageInstallerSession类型的成员变量&#xff0c;来调用 PackageInstallerSession的接口&#xff09;</p> 
<p>点击安装后到完成APK 拷贝的流程如下&#xff1a;</p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20200122223533847.png?x-oss-process&#61,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<p>  点击一个未安装的apk后&#xff0c;会弹出安装界面&#xff0c;点击点击确定按钮后&#xff0c;会进入 PackageInstallerActivity.java的 bindUi()中的mAlert点击事件</p> 
<p>点击apk后&#xff0c;弹出的安装界面底部显示的是一个diaglog&#xff0c;主要由bindUi构成&#xff0c;上面有”取消“和”安装“两个按钮&#xff0c;点击安装后 调用startInstall()进行安装</p> 
<pre class="has"><code>private void bindUi() {
    mAlert.setIcon(mAppSnippet.icon);
    mAlert.setTitle(mAppSnippet.label);
    mAlert.setView(R.layout.install_content_view);
    mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),
            (ignored, ignored2) -&gt; {
                if (mOk.isEnabled()) {
                    if (mSessionId !&#61; -1) {
                        mInstaller.setPermissionsResult(mSessionId, true);
                        finish();
                    } else {
                        startInstall();  //进行APK安装
                    }
                }
            }, null);
    mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),
            (ignored, ignored2) -&gt; {
                // Cancel and finish
                setResult(RESULT_CANCELED);
                if (mSessionId !&#61; -1) {
                    //如果mSessionId存在&#xff0c;执行setPermissionsResult()完成取消安装
                    mInstaller.setPermissionsResult(mSessionId, false);
                }
                finish();
            }, null);
    setupAlert();

    mOk &#61; mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
    mOk.setEnabled(false);
}</code></pre> 
<p>   startInstall方法组装了一个Intent&#xff0c;并跳转到 InstallInstalling 这个Activity&#xff0c;并关闭掉当前的PackageInstallerActivity。InstallInstalling主要用于向包管理器发送包的信息并处理包管理的回调。</p> 
<pre class="has"><code>private void startInstall() {
    // Start subactivity to actually install the application
    Intent newIntent &#61; new Intent();
    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
            mPkgInfo.applicationInfo);
    newIntent.setData(mPackageURI);
    newIntent.setClass(this, InstallInstalling.class);  //设置Intent中的class为 InstallInstalling&#xff0c;用来进行Activity跳转
    String installerPackageName &#61; getIntent().getStringExtra(
            Intent.EXTRA_INSTALLER_PACKAGE_NAME);
    if (mOriginatingURI !&#61; null) {
        newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);
    }
    if (mReferrerURI !&#61; null) {
        newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);
    }
    if (mOriginatingUid !&#61; PackageInstaller.SessionParams.UID_UNKNOWN) {
        newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);
    }
    if (installerPackageName !&#61; null) {
        newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,
                installerPackageName);
    }
    if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) {
        newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true);
    }
    newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    if(localLOGV) Log.i(TAG, &#34;downloaded app uri&#61;&#34;&#43;mPackageURI);
    startActivity(newIntent);
    finish();
}</code></pre> 
<p>InstallInstalling 的Activity启动后&#xff0c;进入onCreate</p> 
<p>主要分为6步&#xff1a;</p> 
<ul><li> <p>1.如果savedInstanceState不为null&#xff0c;获取此前保存的mSessionId和mInstallId&#xff0c;其中mSessionId是安装包的会话id&#xff0c;mInstallId是等待的安装事件id</p> </li><li> <p>2.根据mInstallId向InstallEventReceiver注册一个观察者&#xff0c;launchFinishBasedOnResult会接收到安装事件的回调&#xff0c;无论安装成功或者失败都会关闭当前的Activity(InstallInstalling)。如果savedInstanceState为null&#xff0c;代码的逻辑也是类似的</p> </li><li> <p>3.创建SessionParams&#xff0c;它用来代表安装会话的参数,组装params</p> </li><li> <p>4.根据mPackageUri对包&#xff08;APK&#xff09;进行轻量级的解析&#xff0c;并将解析的参数赋值给SessionParams</p> </li><li> <p>5.向InstallEventReceiver注册一个观察者返回一个新的mInstallId&#xff0c;其中InstallEventReceiver继承自BroadcastReceiver&#xff0c;用于接收安装事件并回调给EventResultPersister。</p> </li><li> <p>6.PackageInstaller的createSession方法内部会通过IPackageInstaller与PackageInstallerService进行进程间通信&#xff0c;最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId</p> </li></ul>
<pre class="has"><code>protected void onCreate(&#64;Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    ApplicationInfo appInfo &#61; getIntent()
            .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);
    mPackageURI &#61; getIntent().getData();

    if (&#34;package&#34;.equals(mPackageURI.getScheme())) {
        try {
            getPackageManager().installExistingPackage(appInfo.packageName);
            launchSuccess();
        } catch (PackageManager.NameNotFoundException e) {
            launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);
        }
    } else {
        //根据mPackageURI创建一个对应的File
        final File sourceFile &#61; new File(mPackageURI.getPath());
        PackageUtil.AppSnippet as &#61; PackageUtil.getAppSnippet(this, appInfo, sourceFile);

        mAlert.setIcon(as.icon);
        mAlert.setTitle(as.label);
        mAlert.setView(R.layout.install_content_view);
        mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),
                (ignored, ignored2) -&gt; {
                    if (mInstallingTask !&#61; null) {
                        mInstallingTask.cancel(true);
                    }

                    if (mSessionId &gt; 0) {
                        getPackageManager().getPackageInstaller().abandonSession(mSessionId);
                        mSessionId &#61; 0;
                    }

                    setResult(RESULT_CANCELED);
                    finish();
                }, null);
        setupAlert();
        requireViewById(R.id.installing).setVisibility(View.VISIBLE);

        //1.如果savedInstanceState不为null&#xff0c;获取此前保存的mSessionId和mInstallId&#xff0c;其中mSessionId是安装包的会话id&#xff0c;mInstallId是等待的安装事件id
        if (savedInstanceState !&#61; null) {
            mSessionId &#61; savedInstanceState.getInt(SESSION_ID);
            mInstallId &#61; savedInstanceState.getInt(INSTALL_ID);

            // Reregister for result; might instantly call back if result was delivered while
            // activity was destroyed
            try {
                //2.根据mInstallId向InstallEventReceiver注册一个观察者&#xff0c;launchFinishBasedOnResult会接收到安装事件的回调&#xff0c;
                //无论安装成功或者失败都会关闭当前的Activity(InstallInstalling)。如果savedInstanceState为null&#xff0c;代码的逻辑也是类似的
                InstallEventReceiver.addObserver(this, mInstallId,
                        this::launchFinishBasedOnResult);
            } catch (EventResultPersister.OutOfIdsException e) {
                // Does not happen
            }
        } else {
            //3.创建SessionParams&#xff0c;它用来代表安装会话的参数,组装params
            PackageInstaller.SessionParams params &#61; new PackageInstaller.SessionParams(
                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);
            params.setInstallAsInstantApp(false);
            params.setReferrerUri(getIntent().getParcelableExtra(Intent.EXTRA_REFERRER));
            params.setOriginatingUri(getIntent()
                    .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI));
            params.setOriginatingUid(getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID,
                    UID_UNKNOWN));
            params.setInstallerPackageName(getIntent().getStringExtra(
                    Intent.EXTRA_INSTALLER_PACKAGE_NAME));
            params.setInstallReason(PackageManager.INSTALL_REASON_USER);

            //4.根据mPackageUri对包&#xff08;APK&#xff09;进行轻量级的解析&#xff0c;并将解析的参数赋值给SessionParams
            File file &#61; new File(mPackageURI.getPath());
            try {
                PackageParser.PackageLite pkg &#61; PackageParser.parsePackageLite(file, 0);
                params.setAppPackageName(pkg.packageName);
                params.setInstallLocation(pkg.installLocation);
                params.setSize(
                        PackageHelper.calculateInstalledSize(pkg, false, params.abiOverride));
            } catch (PackageParser.PackageParserException e) {
                Log.e(LOG_TAG, &#34;Cannot parse package &#34; &#43; file &#43; &#34;. Assuming defaults.&#34;);
                Log.e(LOG_TAG,
                        &#34;Cannot calculate installed size &#34; &#43; file &#43; &#34;. Try only apk size.&#34;);
                params.setSize(file.length());
            } catch (IOException e) {
                Log.e(LOG_TAG,
                        &#34;Cannot calculate installed size &#34; &#43; file &#43; &#34;. Try only apk size.&#34;);
                params.setSize(file.length());
            }

            try {
                //5.向InstallEventReceiver注册一个观察者返回一个新的mInstallId&#xff0c;
                //其中InstallEventReceiver继承自BroadcastReceiver&#xff0c;用于接收安装事件并回调给EventResultPersister。
                mInstallId &#61; InstallEventReceiver
                        .addObserver(this, EventResultPersister.GENERATE_NEW_ID,
                                this::launchFinishBasedOnResult);
            } catch (EventResultPersister.OutOfIdsException e) {
                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);
            }

            try {
                //6.PackageInstaller的createSession方法内部会通过IPackageInstaller与PackageInstallerService进行进程间通信&#xff0c;
                //最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId
                mSessionId &#61; getPackageManager().getPackageInstaller().createSession(params);
            } catch (IOException e) {
                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);
            }
        }

        mCancelButton &#61; mAlert.getButton(DialogInterface.BUTTON_NEGATIVE);

        mSessionCallback &#61; new InstallSessionCallback();
    }
}</code></pre> 
<p>  这里 PackageInstaller 的 createSession()内部会通过IPackageInstaller与PackageInstallerService进行进程间通信&#xff0c;最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId。</p> 
<p>    接着在InstallInstalling 的onResume方法中&#xff0c;调用onPostExecute()方法&#xff0c;将APK的信息通过IO流的形式写入到PackageInstaller.Session中</p> 
<pre class="has"><code>protected void onResume() {
    super.onResume();
    // This is the first onResume in a single life of the activity
    if (mInstallingTask &#61;&#61; null) {
        PackageInstaller installer &#61; getPackageManager().getPackageInstaller();
        //获取sessionInfo
        PackageInstaller.SessionInfo sessionInfo &#61; installer.getSessionInfo(mSessionId);

        if (sessionInfo !&#61; null &amp;&amp; !sessionInfo.isActive()) {
            //创建内部类InstallingAsyncTask的对象&#xff0c;调用execute()&#xff0c;最终进入onPostExecute()
            mInstallingTask &#61; new InstallingAsyncTask();
            mInstallingTask.execute();
        } else {
            // we will receive a broadcast when the install is finished
            mCancelButton.setEnabled(false);
            setFinishOnTouchOutside(false);
        }
    }
}</code></pre> 
<p>  InstallingAsyncTask 的doInBackground()会根据包(APK)的Uri&#xff0c;将APK的信息通过IO流的形式写入到PackageInstaller.Session中</p> 
<p>最后在onPostExecute()中 调用PackageInstaller.Session的commit方法&#xff0c;进行安装</p> 
<pre class="has"><code>
private final class InstallingAsyncTask extends AsyncTask&lt;Void, Void,
        PackageInstaller.Session&gt; {
    volatile boolean isDone;

    &#64;Override
    protected PackageInstaller.Session doInBackground(Void... params) {
        PackageInstaller.Session session;
        try {
            session &#61; getPackageManager().getPackageInstaller().openSession(mSessionId);
        } catch (IOException e) {
            return null;
        }

        session.setStagingProgress(0);

        try {
            File file &#61; new File(mPackageURI.getPath());

            try (InputStream in &#61; new FileInputStream(file)) {
                long sizeBytes &#61; file.length();
                try (OutputStream out &#61; session
                        .openWrite(&#34;PackageInstaller&#34;, 0, sizeBytes)) {
                    byte[] buffer &#61; new byte[1024 * 1024];
                    while (true) {
                        int numRead &#61; in.read(buffer);

                        if (numRead &#61;&#61; -1) {
                            session.fsync(out);
                            break;
                        }

                        if (isCancelled()) {
                            session.close();
                            break;
                        }
                        //将APK的信息通过IO流的形式写入到PackageInstaller.Session中
                        out.write(buffer, 0, numRead);
                        if (sizeBytes &gt; 0) {
                            float fraction &#61; ((float) numRead / (float) sizeBytes);
                            session.addProgress(fraction);
                        }
                    }
                }
            }

            return session;
        } catch (IOException | SecurityException e) {
            Log.e(LOG_TAG, &#34;Could not write package&#34;, e);

            session.close();

            return null;
        } finally {
            synchronized (this) {
                isDone &#61; true;
                notifyAll();
            }
        }
    }

    &#64;Override
    protected void onPostExecute(PackageInstaller.Session session) {
        if (session !&#61; null) {
            Intent broadcastIntent &#61; new Intent(BROADCAST_ACTION);
            broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
            broadcastIntent.setPackage(getPackageName());
            broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);

            PendingIntent pendingIntent &#61; PendingIntent.getBroadcast(
                    InstallInstalling.this,
                    mInstallId,
                    broadcastIntent,
                    PendingIntent.FLAG_UPDATE_CURRENT);

            调用PackageInstaller.Session的commit方法&#xff0c;进行安装
            session.commit(pendingIntent.getIntentSender());
            mCancelButton.setEnabled(false);
            setFinishOnTouchOutside(false);
        } else {
            getPackageManager().getPackageInstaller().abandonSession(mSessionId);

            if (!isCancelled()) {
                launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null);
            }
        }
    }
}
</code></pre> 
<p>接下来看一看PackageInstaller的commit()</p> 
<pre class="has"><code>[PackageInstaller.java] commit
public void commit(&#64;NonNull IntentSender statusReceiver) {
    try {
        //调用PackageInstallerSession的commit方法,进入到java框架层
        mSession.commit(statusReceiver, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}</code></pre> 
<p>   commit()中  mSession的类型为IPackageInstallerSession&#xff0c;这说明要通过IPackageInstallerSession来进行进程间的通信&#xff0c;最终会调用PackageInstallerSession的commit方法&#xff0c;这样代码逻辑就到了Java框架层的。</p> 
<pre class="has"><code>[PackageInstallerSession.java] commit()
public void commit(&#64;NonNull IntentSender statusReceiver, boolean forTransfer) {
    if (mIsPerfLockAcquired &amp;&amp; mPerfBoostInstall !&#61; null) {
        mPerfBoostInstall.perfLockRelease();
        mIsPerfLockAcquired &#61; false;
    }
    ...
    //调用markAsCommitted()
    if (!markAsCommitted(statusReceiver, forTransfer)) {
        return;
    }
    ...
    mHandler.obtainMessage(MSG_COMMIT).sendToTarget();
}</code></pre> 
<p>   markAsCommitted方法中会将包的信息封装为 PackageInstallObserverAdapter &#xff0c;它在PKMS中被定义,然后返回到commit()中&#xff0c;向Handler发送一个类型为MSG_COMMIT的消息</p> 
<pre class="has"><code>public boolean markAsCommitted(
        &#64;NonNull IntentSender statusReceiver, boolean forTransfer) {
    Preconditions.checkNotNull(statusReceiver);

    List&lt;PackageInstallerSession&gt; childSessions &#61; getChildSessions();

    final boolean wasSealed;
    synchronized (mLock) {
        assertCallerIsOwnerOrRootLocked();
        assertPreparedAndNotDestroyedLocked(&#34;commit&#34;);

        final PackageInstallObserverAdapter adapter &#61; new PackageInstallObserverAdapter(
                mContext, statusReceiver, sessionId,
                isInstallerDeviceOwnerOrAffiliatedProfileOwnerLocked(), userId);
        mRemoteObserver &#61; adapter.getBinder();
    ...
    return true;
}</code></pre> 
<p>MSG_COMMIT在handler中进行处理&#xff0c;进入handleCommit()</p> 
<pre class="has"><code>public boolean handleMessage(Message msg) {
    switch (msg.what) {
        case MSG_COMMIT:
            handleCommit();
            break;
    }
}

private void handleCommit() {
    ...
    List&lt;PackageInstallerSession&gt; childSessions &#61; getChildSessions();

    try {
        synchronized (mLock) {
            //最终调用installStage()&#xff0c;进入PKMS
            commitNonStagedLocked(childSessions);
        }
    } catch (PackageManagerException e) {
        final String completeMsg &#61; ExceptionUtils.getCompleteMessage(e);
        Slog.e(TAG, &#34;Commit of session &#34; &#43; sessionId &#43; &#34; failed: &#34; &#43; completeMsg);
        destroyInternal();
        dispatchSessionFinished(e.error, completeMsg, null);
    }
}</code></pre> 
<p>  commitNonStagedLocked()中首先 调用了PackageInstallObserver的 onPackageInstalled方法&#xff0c;将 Complete 方法出现的PackageManagerException的异常信息回调给</p> 
<p>PackageInstallObserverAdapter。</p> 
<p>最终调用installStage()&#xff0c;进入PKMS</p> 
<pre class="has"><code>private void commitNonStagedLocked(List&lt;PackageInstallerSession&gt; childSessions)
        throws PackageManagerException {
    if (isMultiPackage()) {
        ...
        if (!success) {
            try {
                mRemoteObserver.onPackageInstalled(
                        null, failure.error, failure.getLocalizedMessage(), null);
            } catch (RemoteException ignored) {
            }
            return;
        }
        mPm.installStage(activeChildSessions);
    } else {
        mPm.installStage(committingSession);
    }
}</code></pre> 
<p>进入PKMS的installStage()</p> 
<pre class="has"><code>
void installStage(ActiveInstallSession activeInstallSession) {
    if (DEBUG_INSTANT) {
        if ((activeInstallSession.getSessionParams().installFlags
                &amp; PackageManager.INSTALL_INSTANT_APP) !&#61; 0) {
            Slog.d(TAG, &#34;Ephemeral install of &#34; &#43; activeInstallSession.getPackageName());
        }
    }
    //1.创建了类型为INIT_COPY的消息
    final Message msg &#61; mHandler.obtainMessage(INIT_COPY);

    //2.创建InstallParams&#xff0c;它对应于包的安装数据
    final InstallParams params &#61; new InstallParams(activeInstallSession);
    params.setTraceMethod(&#34;installStage&#34;).setTraceCookie(System.identityHashCode(params));
    msg.obj &#61; params;

    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;installStage&#34;,
            System.identityHashCode(msg.obj));
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;queueInstall&#34;,
            System.identityHashCode(msg.obj));

    //3.将InstallParams通过消息发送出去。
    mHandler.sendMessage(msg);
}

对INIT_COPY的消息的处理
[PackageManagerService.java]
void doHandleMessage(Message msg) {
    switch (msg.what) {
        case INIT_COPY: {
            HandlerParams params &#61; (HandlerParams) msg.obj;
            if (params !&#61; null) {
                if (DEBUG_INSTALL) Slog.i(TAG, &#34;init_copy: &#34; &#43; params);
                Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, &#34;queueInstall&#34;,
                        System.identityHashCode(params));
                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;startCopy&#34;);
                //执行APK拷贝动作
                params.startCopy();
                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
            }
            break;
        }
    }
}</code></pre> 
<p>handleStartCopy()需要执行下面几步&#xff1a;</p> 
<ul><li> <p>1.首先检查文件和cid是否已生成&#xff0c;如生成则设置installFlags。</p> </li><li> <p>2.检查空间大小&#xff0c;如果空间不够则释放无用空间。</p> </li><li> <p>3.覆盖原有安装位置的文件&#xff0c;并根据返回结果来确定函数的返回值&#xff0c;并设置installFlags</p> </li><li> <p>4.确定是否有任何已安装的包验证器&#xff0c;如有&#xff0c;则延迟检测。主要分三步&#xff1a;首先新建一个验证Intent&#xff0c;然后设置相关的信息&#xff0c;之后获取验证器列表&#xff0c;最后向每个验证器发送验证Intent。</p> </li></ul>
<pre class="has"><code>
[PackageManagerService.java]
public void handleStartCopy() {
    //1.首先检查文件和cid是否已生成&#xff0c;如生成则设置installFlags。
    if (origin.staged) {
        if (origin.file !&#61; null) {
            installFlags |&#61; PackageManager.INSTALL_INTERNAL;
        } else {
            throw new IllegalStateException(&#34;Invalid stage location&#34;);
        }
    }
    ...
    //2.检查空间大小&#xff0c;如果空间不够则释放无用空间。
    if (!origin.staged &amp;&amp; pkgLite.recommendedInstallLocation
            &#61;&#61; PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
        // TODO: focus freeing disk space on the target device
        final StorageManager storage &#61; StorageManager.from(mContext);
        final long lowThreshold &#61; storage.getStorageLowBytes(
                Environment.getDataDirectory());

        final long sizeBytes &#61; PackageManagerServiceUtils.calculateInstalledSize(
                origin.resolvedPath, packageAbiOverride);
        if (sizeBytes &gt;&#61; 0) {
            try {
                mInstaller.freeCache(null, sizeBytes &#43; lowThreshold, 0, 0);
                pkgLite &#61; PackageManagerServiceUtils.getMinimalPackageInfo(mContext,
                        origin.resolvedPath, installFlags, packageAbiOverride);
            } catch (InstallerException e) {
                Slog.w(TAG, &#34;Failed to free cache&#34;, e);
            }
        }
        if (pkgLite.recommendedInstallLocation
                &#61;&#61; PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
            pkgLite.recommendedInstallLocation
                    &#61; PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
        }
    }

    ...
    //3.覆盖原有安装位置的文件&#xff0c;并根据返回结果来确定函数的返回值&#xff0c;并设置installFlags。
    {
        // Override with defaults if needed.
        loc &#61; installLocationPolicy(pkgLite);
        if (loc &#61;&#61; PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) {
            ret &#61; PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
        } else if (loc &#61;&#61; PackageHelper.RECOMMEND_FAILED_WRONG_INSTALLED_VERSION) {
            ret &#61; PackageManager.INSTALL_FAILED_WRONG_INSTALLED_VERSION;
        } else if (!onInt) {
            // Override install location with flags
            if (loc &#61;&#61; PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
                // Set the flag to install on external media.
                installFlags &amp;&#61; ~PackageManager.INSTALL_INTERNAL;
            } else if (loc &#61;&#61; PackageHelper.RECOMMEND_INSTALL_EPHEMERAL) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, &#34;...setting INSTALL_EPHEMERAL install flag&#34;);
                }
                installFlags |&#61; PackageManager.INSTALL_INSTANT_APP;
                installFlags &amp;&#61; ~PackageManager.INSTALL_INTERNAL;
            } else {
                // Make sure the flag for installing on external
                // media is unset
                installFlags |&#61; PackageManager.INSTALL_INTERNAL;
            }
        }
    }
    ...
    //4.确定是否有任何已安装的包验证器&#xff0c;如有&#xff0c;则延迟检测。主要分三步&#xff1a;首先新建一个验证Intent&#xff0c;然后设置相关的信息&#xff0c;之后获取验证器列表&#xff0c;最后向每个验证器发送验证Intent。
    //4.1构造验证Intent
    final Intent verification &#61; new Intent(
            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),
            PACKAGE_MIME_TYPE);
    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

    final PackageVerificationState verificationState &#61; new PackageVerificationState(
            requiredUid, this);

    mPendingVerification.append(verificationId, verificationState);
     //4.2获取验证器列表
    final List&lt;ComponentName&gt; sufficientVerifiers &#61; matchVerifiers(pkgLite,
            receivers, verificationState);

    DeviceIdleController.LocalService idleController &#61; getDeviceIdleController();
    final long idleDuration &#61; getVerificationTimeout();

    if (sufficientVerifiers !&#61; null) {
        final int N &#61; sufficientVerifiers.size();
        if (N &#61;&#61; 0) {
            Slog.i(TAG, &#34;Additional verifiers required, but none installed.&#34;);
            ret &#61; PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
        } else {
            for (int i &#61; 0; i &lt; N; i&#43;&#43;) {
                final ComponentName verifierComponent &#61; sufficientVerifiers.get(i);
                idleController.addPowerSaveTempWhitelistApp(Process.myUid(),
                        verifierComponent.getPackageName(), idleDuration,
                        verifierUser.getIdentifier(), false, &#34;package verifier&#34;);
                //4.3向每个验证器发送验证Intent
                final Intent sufficientIntent &#61; new Intent(verification);
                sufficientIntent.setComponent(verifierComponent);
                mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
            }
        }
    }
    ...
}</code></pre> 
<p>   向验证器客户端发送intent&#xff0c;只有当验证成功之后才会开启copy工作。如果没有任何验证器则直接拷贝。</p> 
<p>在handleReturnCode()中调用 copyApk()进行APK的拷贝动作</p> 
<pre class="has"><code>void handleReturnCode() {
    if (mVerificationCompleted &amp;&amp; mEnableRollbackCompleted) {
        if ((installFlags &amp; PackageManager.INSTALL_DRY_RUN) !&#61; 0) {
            String packageName &#61; &#34;&#34;;
            try {
                PackageLite packageInfo &#61;
                        new PackageParser().parsePackageLite(origin.file, 0);
                packageName &#61; packageInfo.packageName;
            } catch (PackageParserException e) {
                Slog.e(TAG, &#34;Can&#39;t parse package at &#34; &#43; origin.file.getAbsolutePath(), e);
            }
            try {
                observer.onPackageInstalled(packageName, mRet, &#34;Dry run&#34;, new Bundle());
            } catch (RemoteException e) {
                Slog.i(TAG, &#34;Observer no longer exists.&#34;);
            }
            return;
        }
        if (mRet &#61;&#61; PackageManager.INSTALL_SUCCEEDED) {
            mRet &#61; mArgs.copyApk();
        }
        processPendingInstall(mArgs, mRet);
    }
}</code></pre> 
<p>APK 拷贝调用栈如下&#xff1a;</p> 
<p><img alt="" class="has" height="160" src="https://img-blog.csdnimg.cn/20200122223942315.png" width="246" /></p> 
<p>通过文件流的操作&#xff0c;把APK拷贝到/data/app等目录</p> 
<pre class="has"><code>private static void copyFile(String sourcePath, File targetDir, String targetName)
        throws ErrnoException, IOException {
    if (!FileUtils.isValidExtFilename(targetName)) {
        throw new IllegalArgumentException(&#34;Invalid filename: &#34; &#43; targetName);
    }
    Slog.d(TAG, &#34;Copying &#34; &#43; sourcePath &#43; &#34; to &#34; &#43; targetName);

    final File targetFile &#61; new File(targetDir, targetName);
    final FileDescriptor targetFd &#61; Os.open(targetFile.getAbsolutePath(),
            O_RDWR | O_CREAT, 0644);
    Os.chmod(targetFile.getAbsolutePath(), 0644);
    FileInputStream source &#61; null;
    try {
        source &#61; new FileInputStream(sourcePath);
        FileUtils.copy(source.getFD(), targetFd);
    } finally {
        IoUtils.closeQuietly(source);
    }
}</code></pre> 
<p><strong>APK拷贝完成后&#xff0c;进入真正的安装&#xff0c;流程如下&#xff1a;</strong></p> 
<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/2020012222402640.png?x-oss-process&#61,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpcmFuZmVuZw&#61;&#61;,size_16,color_FFFFFF,t_70" /></p> 
<pre class="has"><code>private void processPendingInstall(final InstallArgs args, final int currentStatus) {
    if (args.mMultiPackageInstallParams !&#61; null) {
        args.mMultiPackageInstallParams.tryProcessInstallRequest(args, currentStatus);
    } else {
        //1.设置安装参数
        PackageInstalledInfo res &#61; createPackageInstalledInfo(currentStatus);
        //2.创建一个新线程&#xff0c;处理安装参数&#xff0c;进行安装
        processInstallRequestsAsync(
                res.returnCode &#61;&#61; PackageManager.INSTALL_SUCCEEDED,
                Collections.singletonList(new InstallRequest(args, res)));
    }
}

private void processInstallRequestsAsync(boolean success,
        List&lt;InstallRequest&gt; installRequests) {
    mHandler.post(() -&gt; {
        if (success) {
            for (InstallRequest request : installRequests) {
                //1.如果之前安装失败&#xff0c;清除无用信息
                request.args.doPreInstall(request.installResult.returnCode);
            }
            synchronized (mInstallLock) {
                //2. installPackagesTracedLI 是安装过程的核心方法&#xff0c;然后调用 installPackagesLI 进行安装。
                installPackagesTracedLI(installRequests);
            }
            for (InstallRequest request : installRequests) {
                //3.如果之前安装失败&#xff0c;清除无用信息
                request.args.doPostInstall(
                        request.installResult.returnCode, request.installResult.uid);
            }
        }
        for (InstallRequest request : installRequests) {
            restoreAndPostInstall(request.args.user.getIdentifier(), request.installResult,
                    new PostInstallData(request.args, request.installResult, null));
        }
    });
}
</code></pre> 
<p><strong>以原子方式安装一个或多个包。</strong><strong>此操作分为五个阶段&#xff1a;</strong></p> 
<ul><li> <p>1)Prepare 准备&#xff1a;分析任何当前安装状态&#xff0c;分析包并对其进行初始验证。</p> </li><li> <p>2)Scan  扫描&#xff1a;考虑到prepare中收集的上下文&#xff0c;询问已分析的包。</p> </li><li> <p>3)Reconcile 调和&#xff1a;在彼此的上下文和当前系统状态中验证扫描的包&#xff0c;以确保安装成功。</p> </li><li> <p>4)Commit 提交&#xff1a;提交所有扫描的包并更新系统状态。这是安装流中唯一可以修改系统状态的地方&#xff0c;必须在此阶段之前确定所有可预测的错误。</p> </li><li> <p>5)完成APK的安装</p> </li></ul>
<pre class="has"><code>
private void installPackagesLI(List&lt;InstallRequest&gt; requests) {
    ...
    //1.Prepare 准备&#xff1a;分析任何当前安装状态&#xff0c;分析包并对其进行初始验证。
    prepareResult &#61; preparePackageLI(request.args, request.installResult);
    ...
    //2.Scan  扫描&#xff1a;考虑到prepare中收集的上下文&#xff0c;询问已分析的包。
    final List&lt;ScanResult&gt; scanResults &#61; scanPackageTracedLI(
                            prepareResult.packageToScan, prepareResult.parseFlags,
                            prepareResult.scanFlags, System.currentTimeMillis(),
                            request.args.user);
    ...
    //3.Reconcile 调和&#xff1a;在彼此的上下文和当前系统状态中验证扫描的包&#xff0c;以确保安装成功。
    ReconcileRequest reconcileRequest &#61; new ReconcileRequest(preparedScans, installArgs,
            installResults,
            prepareResults,
            mSharedLibraries,
            Collections.unmodifiableMap(mPackages), versionInfos,
            lastStaticSharedLibSettings);
    ...
    //4.Commit 提交&#xff1a;提交所有扫描的包并更新系统状态。这是安装流中唯一可以修改系统状态的地方&#xff0c;必须在此阶段之前确定所有可预测的错误。
    commitPackagesLocked(commitRequest);
    ...
    //5.完成APK的安装
    executePostCommitSteps(commitRequest);
}</code></pre> 
<p><strong>安装过程细分为以下15步&#xff1a;</strong></p> 
<p><strong>1)首先检查安装包的完整性并解析安装包。</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()
// 完整性校验
if (instantApp &amp;&amp; onExternal) {
    Slog.i(TAG, &#34;Incompatible ephemeral install; external&#61;&#34; &#43; onExternal);
    throw new PrepareFailure(PackageManager.INSTALL_FAILED_INSTANT_APP_INVALID);
}

// 检索包设置&#xff0c;并解析应用
&#64;ParseFlags final int parseFlags &#61; mDefParseFlags | PackageParser.PARSE_CHATTY
        | PackageParser.PARSE_ENFORCE_CODE
        | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);

PackageParser pp &#61; new PackageParser();
pp.setSeparateProcesses(mSeparateProcesses);
pp.setDisplayMetrics(mMetrics);
pp.setCallback(mPackageParserCallback);

Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;parsePackage&#34;);
final PackageParser.Package pkg;
try {
    //解析安装包
    pkg &#61; pp.parsePackage(tmpPackageFile, parseFlags);
    DexMetadataHelper.validatePackageDexMetadata(pkg);
} catch (PackageParserException e) {
    throw new PrepareFailure(&#34;Failed parse during installPackageLI&#34;, e);
} finally {
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
}</code></pre> 
<p><strong>2) 检查SDK版本和沙箱版本&#xff0c;同时检查是否有静态共享库&#xff0c;如有则需要放在内部存储中。</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()

//检查SDK版本和沙箱版本
if (instantApp) {
    if (pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.O) {
        Slog.w(TAG,
                &#34;Instant app package &#34; &#43; pkg.packageName &#43; &#34; does not target at least O&#34;);
        throw new PrepareFailure(INSTALL_FAILED_INSTANT_APP_INVALID,
                &#34;Instant app package must target at least O&#34;);
    }
    if (pkg.mSharedUserId !&#61; null) {
        Slog.w(TAG, &#34;Instant app package &#34; &#43; pkg.packageName
                &#43; &#34; may not declare sharedUserId.&#34;);
        throw new PrepareFailure(INSTALL_FAILED_INSTANT_APP_INVALID,
                &#34;Instant app package may not declare a sharedUserId&#34;);
    }
}

//检查是否有静态共享库
if (pkg.applicationInfo.isStaticSharedLibrary()) {
    // Static shared libraries have synthetic package names
    renameStaticSharedLibraryPackage(pkg);

    // No static shared libs on external storage
    if (onExternal) {
        Slog.i(TAG, &#34;Static shared libs can only be installed on internal storage.&#34;);
        throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,
                &#34;Packages declaring static-shared libs cannot be updated&#34;);
    }
}</code></pre> 
<p><strong>3)检查是否有子安装包&#xff0c;如有则子安装包也需要检测。</strong></p> 
<pre class="has"><code>
[PackageManagerService.java] preparePackageLI()

if (pkg.childPackages !&#61; null) {
    synchronized (mPackages) {
        final int childCount &#61; pkg.childPackages.size();
        for (int i &#61; 0; i &lt; childCount; i&#43;&#43;) {
            PackageParser.Package childPkg &#61; pkg.childPackages.get(i);
            PackageInstalledInfo childRes &#61; new PackageInstalledInfo();
            childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
            childRes.pkg &#61; childPkg;
            childRes.name &#61; childPkg.packageName;
            PackageSetting childPs &#61; mSettings.getPackageLPr(childPkg.packageName);
            if (childPs !&#61; null) {
                childRes.origUsers &#61; childPs.queryInstalledUsers(
                        sUserManager.getUserIds(), true);
            }
            if ((mPackages.containsKey(childPkg.packageName))) {
                childRes.removedInfo &#61; new PackageRemovedInfo(this);
                childRes.removedInfo.removedPackage &#61; childPkg.packageName;
                childRes.removedInfo.installerPackageName &#61; childPs.installerPackageName;
            }
            if (res.addedChildPackages &#61;&#61; null) {
                res.addedChildPackages &#61; new ArrayMap&lt;&gt;();
            }
            res.addedChildPackages.put(childPkg.packageName, childRes);
        }
    }
}</code></pre> 
<p><strong>4)校验安装包签名</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()

PackageSetting signatureCheckPs &#61; ps;
if (pkg.applicationInfo.isStaticSharedLibrary()) {
    SharedLibraryInfo libraryInfo &#61; getLatestSharedLibraVersionLPr(pkg);
    if (libraryInfo !&#61; null) {
        signatureCheckPs &#61; mSettings.getPackageLPr(libraryInfo.getPackageName());
    }
}
final KeySetManagerService ksms &#61; mSettings.mKeySetManagerService;
if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
    if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
        throw new PrepareFailure(INSTALL_FAILED_UPDATE_INCOMPATIBLE, &#34;Package &#34;
                &#43; pkg.packageName &#43; &#34; upgrade keys do not match the &#34;
                &#43; &#34;previously installed version&#34;);
    }
}</code></pre> 
<p><strong>5)设置相关的权限&#xff0c;包括生成权限、移植权限等</strong></p> 
<p><strong>6)如果这是一个系统应用&#xff0c;则检查是否在外部存储上或是是否被其他应用替换等</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()

if (systemApp) {
    if (onExternal) {
        // Abort update; system app can&#39;t be replaced with app on sdcard
        throw new PrepareFailure(INSTALL_FAILED_INVALID_INSTALL_LOCATION,
                &#34;Cannot install updates to system apps on sdcard&#34;);
    } else if (instantApp) {
        // Abort update; system app can&#39;t be replaced with an instant app
        throw new PrepareFailure(INSTALL_FAILED_INSTANT_APP_INVALID,
                &#34;Cannot update a system app with an instant app&#34;);
    }
}</code></pre> 
<p><strong>7)生成安装包Abi(Application binary interface&#xff0c;应用二进制接口&#xff0c;描述应用程序和操作系统之间或其他应用程序的低级接口)</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()

try {
    String abiOverride &#61; (TextUtils.isEmpty(pkg.cpuAbiOverride) ?
            args.abiOverride : pkg.cpuAbiOverride);
    final boolean extractNativeLibs &#61; !pkg.isLibrary();
    derivePackageAbi(pkg, abiOverride, extractNativeLibs);
} catch (PackageManagerException pme) {
    Slog.e(TAG, &#34;Error deriving application ABI&#34;, pme);
    throw new PrepareFailure(INSTALL_FAILED_INTERNAL_ERROR,
            &#34;Error deriving application ABI&#34;);
}</code></pre> 
<p><strong>8)如有必要&#xff0c;优化dex文件</strong></p> 
<pre class="has"><code>[PackageManagerService.java] executePostCommitSteps()

final boolean performDexopt &#61;
        (!instantApp || Global.getInt(mContext.getContentResolver(),
        Global.INSTANT_APP_DEXOPT_ENABLED, 0) !&#61; 0)
        &amp;&amp; ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) &#61;&#61; 0);

if (performDexopt) {
    // Compile the layout resources.
    if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;compileLayouts&#34;);
        mViewCompiler.compileLayouts(pkg);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }

    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &#34;dexopt&#34;);
    // Do not run PackageDexOptimizer through the local performDexOpt
    // method because &#96;pkg&#96; may not be in &#96;mPackages&#96; yet.
    //
    // Also, don&#39;t fail application installs if the dexopt step fails.
    DexoptOptions dexoptOptions &#61; new DexoptOptions(packageName,
            REASON_INSTALL,
            DexoptOptions.DEXOPT_BOOT_COMPLETE
                    | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE);
    mPackageDexOptimizer.performDexOpt(pkg,
            null /* instructionSets */,
            getOrCreateCompilerPackageStats(pkg),
            mDexManager.getPackageUseInfoOrDefault(packageName),
            dexoptOptions);
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
}</code></pre> 
<p><strong>9)冻结APK&#xff0c;并决定是替换安装&#xff0c;还是新安装&#xff0c;组装参数</strong></p> 
<pre class="has"><code>[PackageManagerService.java] preparePackageLI()
final PackageFreezer freezer &#61;
                freezePackageForInstall(pkgName, installFlags, &#34;installPackageLI&#34;);

if (replace) {
    //替换安装

} else {// new package install
    //安装新的APK
    //1)已安装具有相同名称的包&#xff0c;但已将其重命名为旧名称
    //2)不要允许在同一名称的现有包上安装。
    renamedPackage &#61; mSettings.getRenamedPackageLPr(pkgName1);
}</code></pre> 
<p><strong>10)扫描APK&#xff0c;将APK的信息存储在PackageParser.Package类型的newPackage中&#xff0c;一个Package的信息包含了1个base APK以及0个或者多个split APK。</strong></p> 
<p>参考上一节的APK扫描&#xff1a;</p> 
<p><a href="https://blog.csdn.net/yiranfeng/article/details/103961304">Android 10.0 PackageManagerService&#xff08;三&#xff09;APK扫描-[Android取经之路]</a></p> 
<p>进入 [PackageManagerService.java]  scanPackageTracedLI</p> 
<p><strong>调用栈&#xff1a;</strong></p> 
<p>scanPackageTracedLI()<br />         |<br /> scanPackageLI()<br />         |<br /> parsePackage()</p> 
<p><strong>11) 更新共享库</strong></p> 
<pre class="has"><code>[PackageManagerService.java] commitPackageSettings()

synchronized (mPackages) {
    if (!ArrayUtils.isEmpty(reconciledPkg.allowedSharedLibraryInfos)) {
        for (SharedLibraryInfo info : reconciledPkg.allowedSharedLibraryInfos) {
            commitSharedLibraryInfoLocked(info);
        }
        final Map&lt;String, PackageParser.Package&gt; combinedPackages &#61;
                reconciledPkg.getCombinedPackages();
        try {
            // Shared libraries for the package need to be updated.
            updateSharedLibrariesLocked(pkg, null, combinedPackages);
        } catch (PackageManagerException e) {
            Slog.e(TAG, &#34;updateSharedLibrariesLPr failed: &#34;, e);
        }
        // Update all applications that use this library. Skip when booting
        // since this will be done after all packages are scaned.
        if ((scanFlags &amp; SCAN_BOOTING) &#61;&#61; 0) {
            clientLibPkgs &#61; updateAllSharedLibrariesLocked(pkg, combinedPackages);
        }
    }
}</code></pre> 
<p><strong>12)更新该APK对应的Settings信息&#xff0c;Settings用于保存所有包的动态设置。</strong></p> 
<pre class="has"><code>[PackageManagerService.java] commitPackageSettings()
synchronized (mPackages) {
    // Add the new setting to mSettings
    mSettings.insertPackageSettingLPw(pkgSetting, pkg);
    // Add the new setting to mPackages
    mPackages.put(pkg.applicationInfo.packageName, pkg);
}</code></pre> 
<p><strong>13) 安装APK,并为新的代码路径准备应用程序配置文件,并再次检查是否需要dex优化</strong></p> 
<p>    如果是直接安装新包&#xff0c;会为新的代码路径准备应用程序配置文件</p> 
<p>    如果是替换安装&#xff1a;其主要过程为更新设置&#xff0c;清除原有的某些APP数据&#xff0c;重新生成相关的app数据目录等步骤&#xff0c;同时要区分系统应用替换和非系统应用替换。而安装新包&#xff1a;则直接更新设置&#xff0c;生成APP数据即可。</p> 
<pre class="has"><code>[PackageManagerService.java] executePostCommitSteps()
private void executePostCommitSteps(CommitRequest commitRequest) {
    for (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) {
        ...
        //1)进行安装
        prepareAppDataAfterInstallLIF(pkg);
        //2)如果需要替换安装&#xff0c;则需要清楚原有的APP数据
        if (reconciledPkg.prepareResult.clearCodeCache) {
            clearAppDataLIF(pkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE
                    | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
        }


        //3)为新的代码路径准备应用程序配置文件。这需要在调用dexopt之前完成&#xff0c;以便任何安装时配置文件都可以用于优化。
        mArtManagerService.prepareAppProfiles(
                pkg,
                resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()),
                /* updateReferenceProfileContent&#61; */ true);


        final boolean performDexopt &#61;
                (!instantApp || Global.getInt(mContext.getContentResolver(),
                Global.INSTANT_APP_DEXOPT_ENABLED, 0) !&#61; 0)
                &amp;&amp; ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) &#61;&#61; 0);

        if (performDexopt) {
            ...
            //4)执行dex优化
            mPackageDexOptimizer.performDexOpt(pkg,
                    null /* instructionSets */,
                    getOrCreateCompilerPackageStats(pkg),
                    mDexManager.getPackageUseInfoOrDefault(packageName),
                    dexoptOptions);
        }

        BackgroundDexOptService.notifyPackageChanged(packageName);
    }
}</code></pre> 
<p><strong>14)APK的安装</strong></p> 
<p>[PackageManagerService.java] prepareAppDataAfterInstallLIF()</p> 
<p>    通过一系列的调用&#xff0c;最终会调用到[Installer.java] createAppData()进行安装&#xff0c;交给installed进程进行APK的安装</p> 
<p>调用栈如下&#xff1a;</p> 
<p>prepareAppDataAfterInstallLIF()<br />     |<br /> prepareAppDataLIF()<br />     |<br /> prepareAppDataLeafLIF()<br />     |<br /> [Installer.java]<br /> createAppData()<br />  </p> 
<pre class="has"><code>private void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {
    ...
    for (UserInfo user : um.getUsers()) {
        ...
        if (ps.getInstalled(user.id)) {
            // TODO: when user data is locked, mark that we&#39;re still dirty
            prepareAppDataLIF(pkg, user.id, flags);
        }
    }
}

private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
    if (pkg &#61;&#61; null) {
        Slog.wtf(TAG, &#34;Package was null!&#34;, new Throwable());
        return;
    }
    prepareAppDataLeafLIF(pkg, userId, flags);
    final int childCount &#61; (pkg.childPackages !&#61; null) ? pkg.childPackages.size() : 0;
    for (int i &#61; 0; i &lt; childCount; i&#43;&#43;) {
        prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);
    }
}

private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
    ...
    try {
        // 调用Installd守护进程的入口
        ceDataInode &#61; mInstaller.createAppData(volumeUuid, packageName, userId, flags,
                appId, seInfo, app.targetSdkVersion);
    } catch (InstallerException e) {
        if (app.isSystemApp()) {
            destroyAppDataLeafLIF(pkg, userId, flags);
            try {
                ceDataInode &#61; mInstaller.createAppData(volumeUuid, packageName, userId, flags,
                        appId, seInfo, app.targetSdkVersion);
            } catch (InstallerException e2) {
                ...
            }
        }
    }
}</code></pre> 
<pre class="has"><code>[Installer.java]
public long createAppData(String uuid, String packageName, int userId, int flags, int appId,
        String seInfo, int targetSdkVersion) throws InstallerException {
    if (!checkBeforeRemote()) return -1;
    try {
        //mInstalld 为IInstalld的对象&#xff0c;即通过Binder调用到 进程installd&#xff0c;最终调用installd的createAppData()
        //installd的安装过程后面有机会再进行讲解
        return mInstalld.createAppData(uuid, packageName, userId, flags, appId, seInfo,
                targetSdkVersion);
    } catch (Exception e) {
        throw InstallerException.from(e);
    }
}</code></pre> 
<p><strong>15)安装完成后&#xff0c;更新设置&#xff0c;更新安装锁等。</strong></p> 
<p> </p> 
<h1>7 总结</h1> 
<p>APK的安装主要分为以下4步&#xff1a;</p> 
<ul><li> <p>1)将APK的信息通过IO流的形式写入到PackageInstaller.Session中。</p> </li><li> <p>2)调用PackageInstaller.Session的commit方法&#xff0c;将APK的信息交由PKMS处理。</p> </li><li> <p>3)拷贝APK</p> </li><li> <p>4)最后进行安装</p> </li></ul>
<p>最终是交给installed守护进行完成真正的APK安装</p> 