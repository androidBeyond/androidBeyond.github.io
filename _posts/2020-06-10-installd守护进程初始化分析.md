---
layout:     post
title:      Android10 installd守护进程初始化分析
subtitle:   本篇文章我们来学习一下PackageManagerService的守护进程installd的初始化过程
date:       2020-06-10
author:     duguma
header-img: img/article-bg.jpg
top: false
catalog: true
tags:
    - Android10
    - Android
    - framework
---
 
<h1>核心源码</h1>
<p><code>frameworks\base\services\core\java\com\android\server\SystemServer.java</code></p> 
<p><code>frameworks\base\services\core\java\com\android\server\SystemServiceManager.java</code></p> 
<p><code>frameworks\base\services\core\java\com\android\server\pm\Installer.java</code></p> 
<p><code>frameworks\base\services\core\java\com\android\server\pm\PackageManagerService.java</code></p> 
<p><code>frameworks\native\cmds\installd\</code></p> 
<p>众所周知Android系统框架提供了众多的系统服务&#xff0c;比如管理四大组件的AMS&#xff08;ActivityManagerService&#xff09;&#xff0c;管理窗口的WMS&#xff08;WindowManagerService&#xff09;&#xff0c;管理应用安装, 卸载和更新的PMS&#xff08;PackageManagerService&#xff09;&#xff0c;管理输入事件和输入设备的IMS&#xff08;InputManagerService&#xff09;等等&#xff0c;本系列将基于Android 11.0.0_r1代码&#xff0c;从上到下&#xff08;java-&gt;jni-&gt;native&#xff09;对这几大服务进行逐一解读&#xff0c;旨在加深对Android体系结构的理解&#xff0c;了解框架层各组件的运行原理&#xff0c;为以后深入性能分析/系统优化/架构设计等打下坚实的基础。</p> 
<p>上一系列我们介绍了<code>InputManagerService</code>&#xff0c;这一系列我们将开启对<code>PackageManagerService</code>的解读。</p> 
<h5><a id="11_PackageManagerService_16"></a>1.1 PackageManagerService的创建</h5> 
<p>同其他系统服务一样&#xff0c;<code>PackageManagerService</code>也是在开机时由<code>SystemServer</code>创建并以&#34;package&#34;为名添加到<code>ServiceManager</code>中</p> 
<p>[-&gt; SystemServer.java]</p> 
<pre><code>private PackageManagerService mPackageManagerService;

private void startBootstrapServices(&#64;NonNull TimingsTraceAndSlog t) {
    // 创建并初始化Installer[见1.2小节]
    Installer installer &#61; mSystemServiceManager.startService(Installer.class);

    try {
        // 创建PackageManagerService[见1.7小节]
        mPackageManagerService &#61; PackageManagerService.main(mSystemContext, installer,
                mFactoryTestMode !&#61; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
    } finally {
        Watchdog.getInstance().resumeWatchingCurrentThread(&#34;packagemanagermain&#34;);
    }
}

private void startOtherServices(&#64;NonNull TimingsTraceAndSlog t) {
    if (!mOnlyCore) {
        try {
            Watchdog.getInstance().pauseWatchingCurrentThread(&#34;dexopt&#34;);
            // 第一次启动时不会执行&#xff0c;我们暂时不用关注
            mPackageManagerService.updatePackagesIfNeeded();
        } catch (Throwable e) {
            reportWtf(&#34;update packages&#34;, e);
        } finally {
            Watchdog.getInstance().resumeWatchingCurrentThread(&#34;dexopt&#34;);
        }
    }
    
    try {
        // 每3天执行一次fstrim
        mPackageManagerService.performFstrimIfNeeded();
    } catch (Throwable e) {
        reportWtf(&#34;performing fstrim&#34;, e);
    }
    // PackageManagerService已准备就绪
    mPackageManagerService.systemReady();
}
</code></pre> 
<p><code>PackageManagerService</code>需要用到<code>Installer</code>&#xff0c;所以要先通过<code>SystemServiceManager.startService</code>来创建和初始化<code>Installer</code>&#xff1b;</p> 
<h5><a id="12_Installer_62"></a>1.2 Installer的初始化</h5> 
<p>[-&gt; SystemServiceManager.java]</p> 
<pre><code>    public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {
        try {
            final T service;
            try {
                // 通过反射实例化Installer对象[见1.2.1小节]
                Constructor&lt;T&gt; constructor &#61; serviceClass.getConstructor(Context.class);
                service &#61; constructor.newInstance(mContext);
            }
            // Installer继承于SystemService
            startService(service);
            return service;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
    }

    public void startService(&#64;NonNull final SystemService service) {
        // Register it.
        // 保存系统所有的SystemService
        mServices.add(service);
        // Start it.
        long time &#61; SystemClock.elapsedRealtime();
        try {
            // 执行Installer.onStart方法[见1.2.2小节]
            service.onStart();
        } catch (RuntimeException ex) {
            throw new RuntimeException(&#34;Failed to start service &#34; &#43; service.getClass().getName()
                    &#43; &#34;: onStart threw an exception&#34;, ex);
        }
    }
</code></pre> 
<p><code>Installer</code>继承于抽象类<code>SystemService</code>&#xff0c;但它并不是一个真正的<code>Service</code>&#xff0c;主要用来响应<code>system_server</code>中的各个生命周期事件&#xff0c;所有的<code>SystemService</code>都会保存到<code>SystemServiceManager</code>中&#xff0c;<code>system_server</code>在运行过程中会通过它来切换各个<code>SystemService</code>的生命周期&#xff1b;</p> 
<h6><a id="121_Installer_99"></a>1.2.1 Installer的构造函数</h6> 
<p>[-&gt; Installer.java]</p> 
<pre><code>public Installer(Context context) {
    this(context, false);
}

/**
 * &#64;param isolated indicates if this object should &lt;em&gt;not&lt;/em&gt; connect to
 *            the real {&#64;code installd}. All remote calls will be ignored
 *            unless you extend this class and intercept them.
 */
public Installer(Context context, boolean isolated) {
    super(context);
    // isolate&#xff1a;是否不应该与installd进程连接&#xff0c;默认为false表示需要与installd进行连接
    mIsolated &#61; isolated;
}
</code></pre> 
<h6><a id="122_InstalleronStart_118"></a>1.2.2 Installer.onStart</h6> 
<p>[-&gt; Installer.java]</p> 
<pre><code>public void onStart() {
    if (mIsolated) {
        mInstalld &#61; null;
    } else {
        // mIsolated为false&#xff0c;所以调用connect进行连接[见1.2.3小节]
        connect();
    }
}
</code></pre> 
<h6><a id="123_Installerconnect_133"></a>1.2.3 Installer.connect</h6> 
<p>[-&gt; Installer.java]</p> 
<pre><code>private void connect() {
    // 获取installd的binder接口
    IBinder binder &#61; ServiceManager.getService(&#34;installd&#34;);
    if (binder !&#61; null) {
        try {
            // 注册binder的死亡回调
            binder.linkToDeath(new DeathRecipient() {
                &#64;Override
                public void binderDied() {
                    Slog.w(TAG, &#34;installd died; reconnecting&#34;);
                    // 重新与installd进行连接
                    connect();
                }
            }, 0);
        } catch (RemoteException e) {
            binder &#61; null;
        }
    }

    if (binder !&#61; null) {
        // 获取installd的binder对象
        mInstalld &#61; IInstalld.Stub.asInterface(binder);
        try {
            invalidateMounts();
        } catch (InstallerException ignored) {
        }
    } else {
        // 如果installd还没有ready&#xff0c;则不停的等待1s直到binder不为空
        BackgroundThread.getHandler().postDelayed(() -&gt; {
            connect();
        }, DateUtils.SECOND_IN_MILLIS);
    }
}

public void invalidateMounts() throws InstallerException {
    try {
        // 跨进程调用installd的invalidateMounts&#xff1a;主要是通过installd读取/proc/mounts节点内容
        mInstalld.invalidateMounts();
    } catch (Exception e) {
        throw InstallerException.from(e);
    }
}
</code></pre> 
<p><code>Installer</code>初始化主要完成了系统服务<code>installd</code>的获取&#xff0c;以及对<code>installd</code>的<code>invalidateMounts</code>方法调用&#xff0c;从<code>Installer</code>的代码中我们可以看出&#xff0c;它仅仅是完成了对<code>installd</code>的封装&#xff0c;其实所有的功能最终都是通过<code>installd</code>实现的&#xff0c;那这里的<code>installd</code>是指谁呢&#xff0c;为什么它可以像其他系统服务一样通过AIDL的Stub.asInterface获取呢&#xff1f;</p> 
<h5><a id="13_installd_184"></a>1.3 installd</h5> 
<p>[-&gt; installd.rc]</p> 
<pre><code>// installd的定义[见1.3.1小节]
service installd /system/bin/installd
    class main

on early-boot
    mkdir /config/sdcardfs/extensions/1055
    mkdir /config/sdcardfs/extensions/1056
    mkdir /config/sdcardfs/extensions/1057
    mkdir /config/sdcardfs/extensions/1056/3gpp
    mkdir /config/sdcardfs/extensions/1056/3gp
    mkdir /config/sdcardfs/extensions/1056/3gpp2
    mkdir /config/sdcardfs/extensions/1056/3g2
    ......
</code></pre> 
<p>我们知道Android中第一个被启动的进程是<code>init</code>&#xff0c;它通过解析<code>init.rc</code>脚本来构建出系统的初始运行形态&#xff0c;其他Android系统服务大多是在rc脚本中描述并被相继启动的&#xff1a;<code>installd</code>也不例外&#xff0c;它会被<code>init.rc</code>解析并创建一个名为<code>installd</code>的可执行文件&#xff0c;其存储路径位于<code>/system/bin/installd</code>&#xff0c;它的class名为main&#xff0c;同一个class的所有service必须同时启动或者停止&#xff0c;除了<code>installd</code>以外&#xff0c;<code>/system/bin/inputflinger</code>和<code>/system/bin/mediaserver</code>等其他服务的class名都是main&#xff1b;随后会在early-boot阶段创建若干个目录&#xff1b;</p> 
<h6><a id="131_installd_206"></a>1.3.1 installd</h6> 
<p>[-&gt; Android.bp]</p> 
<pre><code>//
// Executable
//

cc_binary {
    name: &#34;installd&#34;,
    defaults: [&#34;installd_defaults&#34;],
    // 源文件入口为installd.cpp[见1.3.2小节]
    srcs: [&#34;installd.cpp&#34;],

    static_libs: [&#34;libdiskusage&#34;],
    // rc脚本
    init_rc: [&#34;installd.rc&#34;],
}
</code></pre> 
<p><code>installd</code>的入口函数在<code>installd.cpp</code>&#xff1b;</p> 
<h6><a id="132_installdcpp_229"></a>1.3.2 installd.cpp</h6> 
<p>[-&gt; installd.cpp]</p> 
<pre><code>// 函数入口
int main(const int argc, char *argv[]) {
    return android::installd::installd_main(argc, argv);
}

static int installd_main(const int argc ATTRIBUTE_UNUSED, char *argv[]) {
    int ret;
    // 判断selinux是否使能
    int selinux_enabled &#61; (is_selinux_enabled() &gt; 0);
    
    union selinux_callback cb;
    cb.func_log &#61; log_callback;
    // 设置selinux的日志回调
    selinux_set_callback(SELINUX_CB_LOG, cb);
    
    // 初始化全局变量[见1.4小节]
    if (!initialize_globals()) {
        SLOGE(&#34;Could not initialize globals; exiting.\n&#34;);
        exit(1);
    }
    // 初始化所有目录[见1.5小节]
    if (initialize_directories() &lt; 0) {
        SLOGE(&#34;Could not create directories; exiting.\n&#34;);
        exit(1);
    }
    // 如果selinux已使能&#xff0c;则打开selinux的状态
    if (selinux_enabled &amp;&amp; selinux_status_open(true) &lt; 0) {
        SLOGE(&#34;Could not open selinux status; exiting.\n&#34;);
        exit(1);
    }
    // 启动服务InstalldNativeService[见1.6小节]
    if ((ret &#61; InstalldNativeService::start()) !&#61; android::OK) {
        SLOGE(&#34;Unable to start InstalldNativeService: %d&#34;, ret);
        exit(1);
    }
    // 将installd自身加入线程池
    IPCThreadState::self()-&gt;joinThreadPool();
    
    LOG(INFO) &lt;&lt; &#34;installd shutting down&#34;;
    
    return 0;

}
</code></pre> 
<p><code>installd</code>的入口函数指向了<code>installd_main</code>&#xff0c;它主要完成一些初始化工作&#xff0c;最终要的是启动了一个服务<code>InstalldNativeService</code>&#xff0c;这看起来与我们在1.2.3的疑问开始关联起来&#xff0c;我们接着往下看&#xff1b;</p> 
<h5><a id="14_initialize_globals_281"></a>1.4 initialize_globals</h5> 
<p>[-&gt; installd.cpp]</p> 
<pre><code>static bool initialize_globals() {
    return init_globals_from_data_and_root();
}
</code></pre> 
<p>[-&gt; global.cpp]</p> 
<pre><code>bool init_globals_from_data_and_root() {
    // 获取&#34;ANDROID_DATA&#34;的环境变量&#xff0c;data目录默认为/data
    const char* data_path &#61; getenv(&#34;ANDROID_DATA&#34;);
    if (data_path &#61;&#61; nullptr) {
        LOG(ERROR) &lt;&lt; &#34;Could not find ANDROID_DATA&#34;;
        return false;
    }
    // 获取&#34;ANDROID_ROOT&#34;的环境变量&#xff0c;根目录默认为/system
    const char* root_path &#61; getenv(&#34;ANDROID_ROOT&#34;);
    if (root_path &#61;&#61; nullptr) {
        LOG(ERROR) &lt;&lt; &#34;Could not find ANDROID_ROOT&#34;;
        return false;
    }
    return init_globals_from_data_and_root(data_path, root_path);
}

// 如果字符串path最后以&#39;/&#39;为结尾&#xff0c;则直接返回path&#xff0c;否则在字符串末尾添加&#39;/&#39;
static std::string ensure_trailing_slash(const std::string&amp; path) {
    if (path.rfind(&#39;/&#39;) !&#61; path.size() - 1) {
        return path &#43; &#39;/&#39;;
    } else {
        return path;
    }
}

bool init_globals_from_data_and_root(const char* data, const char* root) {
    // Get the android data directory.
    // 确保path最后以&#39;/&#39;结尾
    android_data_dir &#61; ensure_trailing_slash(data);

    // Get the android root directory.
    // 确保path最后以&#39;/&#39;结尾
    android_root_dir &#61; ensure_trailing_slash(root);
    
    // Get the android app directory.
    // android_app_dir&#xff1a;/data/app/
    android_app_dir &#61; android_data_dir &#43; APP_SUBDIR;
    
    // Get the android protected app directory.
    // android_app_private_dir&#xff1a;/data/app-private/
    android_app_private_dir &#61; android_data_dir &#43; PRIVATE_APP_SUBDIR;
    
    // Get the android ephemeral app directory.
    // android_app_ephemeral_dir&#xff1a;/data/app-ephemeral/
    android_app_ephemeral_dir &#61; android_data_dir &#43; EPHEMERAL_APP_SUBDIR;
    
    // Get the android app native library directory.
    // android_app_lib_dir&#xff1a;/data/app-lib/
    android_app_lib_dir &#61; android_data_dir &#43; APP_LIB_SUBDIR;
    
    // Get the sd-card ASEC mount point.
    android_asec_dir &#61; ensure_trailing_slash(getenv(ASEC_MOUNTPOINT_ENV_NAME));
    
    // Get the android media directory.
    // android_media_dir&#xff1a;/data/media/
    android_media_dir &#61; android_data_dir &#43; MEDIA_SUBDIR;
    
    // Get the android external app directory.
    android_mnt_expand_dir &#61; &#34;/mnt/expand/&#34;;
    
    // Get the android profiles directory.
    // android_profiles_dir&#xff1a;/data/misc/profiles/
    android_profiles_dir &#61; android_data_dir &#43; PROFILES_SUBDIR;
    
    // Get the android session staging directory.
    // android_staging_dir&#xff1a;/data/app-staging/
    android_staging_dir &#61; android_data_dir &#43; STAGING_SUBDIR;
    
    // Take note of the system and vendor directories.
    // 清空系统目录
    android_system_dirs.clear();
    // 添加/system/app
    android_system_dirs.push_back(android_root_dir &#43; APP_SUBDIR);
    // 添加/system/priv-app
    android_system_dirs.push_back(android_root_dir &#43; PRIV_APP_SUBDIR);
    // 添加/system/vendor/app
    android_system_dirs.push_back(&#34;/vendor/app/&#34;);
    // 添加/system/oem/app
    android_system_dirs.push_back(&#34;/oem/app/&#34;);
    
    return true;

}
</code></pre> 
<p>这里主要初始化并保存了data和system分区的一些目录&#xff0c;它们分别存放不同的内容&#xff0c;比如存放用户安装应用的<code>/data/app/</code>&#xff0c;存放系统应用的<code>/system/app/</code>&#xff0c;存放系统特权应用的<code>/system/priv-app</code>&#xff0c;存放第三方厂商预置应用的<code>/system/vendor/app</code>或者<code>/system/oem/app</code>&#xff0c;存放多媒体数据的<code>/data/media/</code>等&#xff1b;</p> 
<h5><a id="15_initialize_directories_381"></a>1.5 initialize_directories</h5> 
<p>[-&gt; installd.cpp]</p> 
<pre><code>static int initialize_directories() {
    int res &#61; -1;

    // Read current filesystem layout version to handle upgrade paths
    char version_path[PATH_MAX];
    // 读取记录文件系统版本号的路径&#xff1a;/data/misc/installd/layout_version
    snprintf(version_path, PATH_MAX, &#34;%smisc/installd/layout_version&#34;, android_data_dir.c_str());
    
    int oldVersion;
    // 读取历史版本号
    if (fs_read_atomic_int(version_path, &amp;oldVersion) &#61;&#61; -1) {
        oldVersion &#61; 0;
    }
    int version &#61; oldVersion;
    
    if (version &lt; 2) {
        SLOGD(&#34;Assuming that device has multi-user storage layout; upgrade no longer supported&#34;);
        version &#61; 2;
    }
    // 配置主用户路径[见1.5.1]
    if (ensure_config_user_dirs(0) &#61;&#61; -1) {
        SLOGE(&#34;Failed to setup misc for user 0&#34;);
        goto fail;
    }
    
    if (version &#61;&#61; 2) {
        SLOGD(&#34;Upgrading to /data/misc/user directories&#34;);
    
        char misc_dir[PATH_MAX];
        // misc_dir&#xff1a;/data/misc/
        snprintf(misc_dir, PATH_MAX, &#34;%smisc&#34;, android_data_dir.c_str());
    
        DIR *dir;
        struct dirent *dirent;
        // 打开/data/user目录
        dir &#61; opendir(&#34;/data/user&#34;);
        if (dir !&#61; nullptr) {
            // 如果/data/user/目录不为空&#xff0c;则循环读取其下的每一个文件夹
            while ((dirent &#61; readdir(dir))) {
                const char *name &#61; dirent-&gt;d_name;
    
                // skip &#34;.&#34; and &#34;..&#34;
                // 过滤非法目录名
                if (name[0] &#61;&#61; &#39;.&#39;) {
                    if (name[1] &#61;&#61; 0) continue;
                    if ((name[1] &#61;&#61; &#39;.&#39;) &amp;&amp; (name[2] &#61;&#61; 0)) continue;
                }
                // 将char转换为int
                uint32_t user_id &#61; std::stoi(name);
    
                // /data/misc/user/&lt;user_id&gt;
                // 同1.5.1小节&#xff1a;创建user_id对应的目录/data/misc/user/user_id
                if (ensure_config_user_dirs(user_id) &#61;&#61; -1) {
                    goto fail;
                }
            }
            closedir(dir);
        }
    
        version &#61; 3;
    }
    
    // Persist layout version if changed
    if (version !&#61; oldVersion) {
        // 更新版本号
        if (fs_write_atomic_int(version_path, version) &#61;&#61; -1) {
            SLOGE(&#34;Failed to save version to %s: %s&#34;, version_path, strerror(errno));
            goto fail;
        }
    }
    
    // Success!
    res &#61; 0;

fail:
    return res;
}
</code></pre> 
<h6><a id="151_ensure_config_user_dirs_465"></a>1.5.1 ensure_config_user_dirs</h6> 
<p>[-&gt; utils.cpp]</p> 
<pre><code>int ensure_config_user_dirs(userid_t userid) {
    // writable by system, readable by any app within the same user
    // 获取主用户的uid和gid
    const int uid &#61; multiuser_get_uid(userid, AID_SYSTEM);
    const int gid &#61; multiuser_get_uid(userid, AID_EVERYBODY);

    // Ensure /data/misc/user/&lt;userid&gt; exists
    // 创建用户id对应的目录&#xff1a;/data/misc/user/0[见1.5.2小节]
    auto path &#61; create_data_misc_legacy_path(userid);
    return fs_prepare_dir(path.c_str(), 0750, uid, gid);

}
</code></pre> 
<h6><a id="152_create_data_misc_legacy_path_484"></a>1.5.2 create_data_misc_legacy_path</h6> 
<p>[-&gt; utils.cpp]</p> 
<pre><code>std::string create_data_misc_legacy_path(userid_t userid) {
    // 打印通过create_data_path创建的目录&#xff1a;/data/misc/user/0
    return StringPrintf(&#34;%s/misc/user/%u&#34;, create_data_path(nullptr).c_str(), userid);
}
</code></pre> 
<pre><code>std::string create_data_path(const char* volume_uuid) {
    // 传入的volume_uuid为空&#xff0c;所以直接返回/data
    if (volume_uuid &#61;&#61; nullptr) {
        return &#34;/data&#34;;
    } else if (!strcmp(volume_uuid, &#34;TEST&#34;)) {
        CHECK(property_get_bool(&#34;ro.debuggable&#34;, false));
        return &#34;/data/local/tmp&#34;;
    } else {
        CHECK(is_valid_filename(volume_uuid));
        return StringPrintf(&#34;/mnt/expand/%s&#34;, volume_uuid);
    }
}
</code></pre> 
<p><code>initialize_directories</code>首先会创建系统主用户<code>/data/misc/user/0/</code>文件夹&#xff0c;除主用户外&#xff08;<code>/data/user/0/</code>&#xff09;其他每个用户都会在/data/user/目录下面创建一个属于自己的文件夹&#xff08;比如第一个子用户<code>/data/user/10/</code>&#xff0c;以此类推&#xff09;来存放当前用户的用户数据&#xff0c;这里会据此来创建其他用户的<code>/data/misc/user/user_id</code>目录&#xff1b;</p> 
<h5><a id="16_InstalldNativeService_512"></a>1.6 InstalldNativeService</h5> 
<p>[-&gt; InstalldNativeService.h]</p> 
<pre><code>// InstalldNativeService继承于BinderService和BnInstalld&#xff08;binder服务端&#xff09;
class InstalldNativeService : public BinderService&lt;InstalldNativeService&gt;, public os::BnInstalld {
public:
    static status_t start();
    // InstalldNativeService服务名为installd
    static char const* getServiceName() { return &#34;installd&#34;; }
}
</code></pre> 
<p>[-&gt; InstalldNativeService.cpp]</p> 
<pre><code>status_t InstalldNativeService::start() {
    IPCThreadState::self()-&gt;disableBackgroundScheduling(true);
    // InstalldNativeService继承于BinderService&#xff0c;所以会直接调用BinderService的publish方法[见1.6.1小节]
    status_t ret &#61; BinderService&lt;InstalldNativeService&gt;::publish();
    if (ret !&#61; android::OK) {
        return ret;
    }
    // 获取installd进程
    sp&lt;ProcessState&gt; ps(ProcessState::self());
    // 启动installd的线程池
    ps-&gt;startThreadPool();
    ps-&gt;giveThreadPoolName();
    sAppDataIsolationEnabled &#61; android::base::GetBoolProperty(
            kAppDataIsolationEnabledProperty, true);
    return android::OK;
}
</code></pre> 
<h6><a id="161_BinderServicepublish_547"></a>1.6.1 BinderService.publish</h6> 
<p>[-&gt; BinderService.h]</p> 
<pre><code>static status_t publish(bool allowIsolated &#61; false,
                        int dumpFlags &#61; IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT) {
    // 获取binder大管家service_manager
    sp&lt;IServiceManager&gt; sm(defaultServiceManager());
    // InstalldNativeService作为binder服务端被service_manager以&#34;installd&#34;为名添加到系统
    return sm-&gt;addService(String16(SERVICE::getServiceName()), new SERVICE(), allowIsolated,
                          dumpFlags);
}
</code></pre> 
<p>到这里1.2.3的疑问就可以解答&#xff1a;<code>installd</code>会启动<code>InstalldNativeService</code>作为binder的服务端&#xff0c;其他进程就可以通过<code>ServiceManager</code>获取到名为<code>installd</code>的服务&#xff0c;以此来实现跨进程调用&#xff1b;</p> 
<h5><a id="17_PackageManagerServicemain_562"></a>1.7 PackageManagerService.main</h5> 
<p>[-&gt; PackageManagerService.java]</p> 
<pre><code>    public static PackageManagerService main(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore) {
        // Self-check for initial settings.
        // 创建对象锁lock
        final Object lock &#61; new Object();
        // 创建对象锁installLock 
        final Object installLock &#61; new Object();
        // 创建Injector并将其作为参数传递给PackageManagerService的构造函数[见1.7.1小节]
        Injector injector &#61; new Injector(
                context, lock, installer, installLock, new PackageAbiHelperImpl(),
                (i, pm) -&gt;
                        new ComponentResolver(i.getUserManagerService(), pm.mPmInternal, lock),
                (i, pm) -&gt;
                        PermissionManagerService.create(context, lock),
                (i, pm) -&gt;
                        new UserManagerService(context, pm,
                                new UserDataPreparer(installer, installLock, context, onlyCore),
                                lock),
                (i, pm) -&gt;
                        new Settings(Environment.getDataDirectory(),
                                i.getPermissionManagerServiceInternal().getPermissionSettings(),
                                lock),
                new Injector.LocalServicesProducer&lt;&gt;(ActivityTaskManagerInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(ActivityManagerInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(DeviceIdleInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(StorageManagerInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(NetworkPolicyManagerInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(PermissionPolicyInternal.class),
                new Injector.LocalServicesProducer&lt;&gt;(DeviceStorageMonitorInternal.class),
                new Injector.SystemServiceProducer&lt;&gt;(DisplayManager.class),
                new Injector.SystemServiceProducer&lt;&gt;(StorageManager.class),
                new Injector.SystemServiceProducer&lt;&gt;(AppOpsManager.class),
                (i, pm) -&gt; AppsFilter.create(pm.mPmInternal, i),
                (i, pm) -&gt; (PlatformCompat) ServiceManager.getService(&#34;platform_compat&#34;));
        // 创建PackageManagerService
        PackageManagerService m &#61; new PackageManagerService(injector, onlyCore, factoryTest);
        // 安装白名单系统应用
        m.installWhitelistedSystemPackages();
        // 将PackageManagerService添加到ServiceManager
        ServiceManager.addService(&#34;package&#34;, m);
        final PackageManagerNative pmn &#61; m.new PackageManagerNative();
        ServiceManager.addService(&#34;package_native&#34;, pmn);
        return m;
    }

</code></pre> 
<h6><a id="171_Injector_614"></a>1.7.1 Injector</h6> 
<p>[-&gt; Injector.java]</p> 
<pre><code>public static class Injector {
    // Producer主要通过produce方法用来生成对应模板的实例
    interface Producer&lt;T&gt; {
        /** Produce an instance of type {&#64;link T} */
        T produce(Injector injector, PackageManagerService packageManager);
    }
    // 通过LocalServices获取要produce的各系统服务的LocalService
    // 比如ActivityTaskManagerServie对应的ActivityTaskManagerServie.LocalService
    static class LocalServicesProducer&lt;T&gt; implements Producer&lt;T&gt; {
        private final Class&lt;T&gt; mProducingClass;
        LocalServicesProducer(Class&lt;T&gt; clazz) {
            this.mProducingClass &#61; clazz;
        }
        public T produce(Injector injector, PackageManagerService packageManager) {
            return LocalServices.getService(mProducingClass);
        }
    }
    // 创建单例对象&#xff1a;只有要实例化的对象不存在时才会执行其Producer的produce方法
    static class Singleton&lt;T&gt; {
        private final Producer&lt;T&gt; mProducer;
        private volatile T mInstance &#61; null;
        Singleton(Producer&lt;T&gt; producer) {
            this.mProducer &#61; producer;
        }
        T get(Injector injector, PackageManagerService packageManagerService) {
            if (mInstance &#61;&#61; null) {
                mInstance &#61; mProducer.produce(injector, packageManagerService);
            }
            return mInstance;
        }
    }

    // Injector作为PackageManagerService的内部类&#xff0c;主要通过Producer来初始化各种单例对象
    // 具体作用我们会在后面的业务逻辑中进行分析
    Injector(Context context, Object lock, Installer installer,
            Object installLock, PackageAbiHelper abiHelper,
            Producer&lt;ComponentResolver&gt; componentResolverProducer,
            Producer&lt;PermissionManagerServiceInternal&gt; permissionManagerProducer,
            Producer&lt;UserManagerService&gt; userManagerProducer,
            Producer&lt;Settings&gt; settingsProducer,
            Producer&lt;ActivityTaskManagerInternal&gt; activityTaskManagerProducer,
            Producer&lt;ActivityManagerInternal&gt; activityManagerInternalProducer,
            Producer&lt;DeviceIdleInternal&gt; deviceIdleControllerProducer,
            Producer&lt;StorageManagerInternal&gt; storageManagerInternalProducer,
            Producer&lt;NetworkPolicyManagerInternal&gt; networkPolicyManagerProducer,
            Producer&lt;PermissionPolicyInternal&gt; permissionPolicyProvider,
            Producer&lt;DeviceStorageMonitorInternal&gt; deviceStorageMonitorProducer,
            Producer&lt;DisplayManager&gt; displayManagerProducer,
            Producer&lt;StorageManager&gt; storageManagerProducer,
            Producer&lt;AppOpsManager&gt; appOpsManagerProducer,
            Producer&lt;AppsFilter&gt; appsFilterProducer,
            Producer&lt;PlatformCompat&gt; platformCompatProducer) {
        mContext &#61; context;
        mLock &#61; lock;
        mInstaller &#61; installer;
        mAbiHelper &#61; abiHelper;
        mInstallLock &#61; installLock;
        // 单例-start
        mComponentResolverProducer &#61; new Singleton&lt;&gt;(componentResolverProducer);
        mPermissionManagerProducer &#61; new Singleton&lt;&gt;(permissionManagerProducer);
        mUserManagerProducer &#61; new Singleton&lt;&gt;(userManagerProducer);
        mSettingsProducer &#61; new Singleton&lt;&gt;(settingsProducer);
        mActivityTaskManagerProducer &#61; new Singleton&lt;&gt;(activityTaskManagerProducer);
        mActivityManagerInternalProducer &#61; new Singleton&lt;&gt;(activityManagerInternalProducer);
        mLocalDeviceIdleController &#61; new Singleton&lt;&gt;(deviceIdleControllerProducer);
        mStorageManagerInternalProducer &#61; new Singleton&lt;&gt;(storageManagerInternalProducer);
        mNetworkPolicyManagerProducer &#61; new Singleton&lt;&gt;(networkPolicyManagerProducer);
        mPermissionPolicyProducer &#61; new Singleton&lt;&gt;(permissionPolicyProvider);
        mDeviceStorageMonitorProducer &#61; new Singleton&lt;&gt;(deviceStorageMonitorProducer);
        mDisplayManagerProducer &#61; new Singleton&lt;&gt;(displayManagerProducer);
        mStorageManagerProducer &#61; new Singleton&lt;&gt;(storageManagerProducer);
        mAppOpsManagerProducer &#61; new Singleton&lt;&gt;(appOpsManagerProducer);
        mAppsFilterProducer &#61; new Singleton&lt;&gt;(appsFilterProducer);
        mPlatformCompatProducer &#61; new Singleton&lt;&gt;(platformCompatProducer);
        // 单例-end
    }
}
</code></pre> 