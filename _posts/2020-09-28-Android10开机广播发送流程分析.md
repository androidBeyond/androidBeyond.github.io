---
layout:     post
title:      Android10 开机广播发送流程分析
subtitle:   开机广播在很多应用中都会用到，用来启动应用程序，本文将介绍开机广播的发送过程
date:       2020-09-28
author:     duguma
header-img: img/article-bg.jpg
top: true
catalog: true
tags:
    - Android10
    - Android
    - 组件学习
---

<h2><a id="_4"></a>一、概述</h2> 
<p>开机广播在很多应用中都会用到&#xff0c;用来启动应用程序&#xff0c;下面将介绍开机广播的广播过程。这个过程比较复杂&#xff0c;需要和AcitvityManagerService、WindowManagerService、PackageManagerService等交互&#xff0c;其具体的时序图如下。<br /> <img src="https://img-blog.csdnimg.cn/20200105194254981.jpg?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhbzg2MTU0NDMyNQ&#61;&#61;,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p> 
<h2><a id="_8"></a>二、开机广播启动过程</h2> 
<p>在AMS启动<a href="https://skytoby.github.io/2019/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">那篇文章</a>中已经讲到桌面如何的启动&#xff0c;在桌面启动完成后即桌面Activity onResume之后&#xff0c;就会发送开机广播。桌面Activity onResume阶段&#xff0c;执行了handleResumeActivity方法&#xff0c;见<a href="https://skytoby.github.io/2019/startActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">Activity启动过程</a>。handleResumeActivity中加载完window之后将自己实现的IdleHandler添加到自己的消息队列中。</p> 
<h3><a id="11__AThandleResumeActivity_12"></a>1.1 AT.handleResumeActivity</h3> 
<p>[-&gt;ActivityThread.java]</p> 
<pre><code> &#64;Override
    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,
            String reason) {
        ...
        //执行onResume方法
        final ActivityClientRecord r &#61; performResumeActivity(token, finalStateRequest, reason);
        ...
        r.nextIdle &#61; mNewActivities;
        mNewActivities &#61; r;
        if (localLOGV) Slog.v(TAG, &#34;Scheduling idle handler for &#34; &#43; r);
        //见1.2节
        Looper.myQueue().addIdleHandler(new Idler());
    }
</code></pre> 
<h3><a id="12_MQaddIdleHandler_32"></a>1.2 MQ.addIdleHandler</h3> 
<p>[-&gt;MessageQueue.java]</p> 
<pre><code>  public void addIdleHandler(&#64;NonNull IdleHandler handler) {
        if (handler &#61;&#61; null) {
            throw new NullPointerException(&#34;Can&#39;t add a null IdleHandler&#34;);
        }
        synchronized (this) {
            //见1.3节
            mIdleHandlers.add(handler);
        }
    }
</code></pre> 
<p>将IdleHandler加入到消息队列&#xff0c;当消息队列空闲的时候执行idler.queueIdle()的回调。</p> 
<h3><a id="13_IdlerqueueIdle_50"></a>1.3 Idler.queueIdle</h3> 
<p>[-&gt;ActivityThread.java]</p> 
<pre><code> private class Idler implements MessageQueue.IdleHandler {
        &#64;Override
        public final boolean queueIdle() {
            ActivityClientRecord a &#61; mNewActivities;
            boolean stopProfiling &#61; false;
            if (mBoundApplication !&#61; null &amp;&amp; mProfiler.profileFd !&#61; null
                    &amp;&amp; mProfiler.autoStopProfiler) {
                stopProfiling &#61; true;
            }
            if (a !&#61; null) {
                mNewActivities &#61; null;
                //获取AMS的代理
                IActivityManager am &#61; ActivityManager.getService();
                ActivityClientRecord prev;
                do {
                    if (localLOGV) Slog.v(
                        TAG, &#34;Reporting idle of &#34; &#43; a &#43;
                        &#34; finished&#61;&#34; &#43;
                        (a.activity !&#61; null &amp;&amp; a.activity.mFinished));
                    if (a.activity !&#61; null &amp;&amp; !a.activity.mFinished) {
                        try {
                            //见1.4节
                            am.activityIdle(a.token, a.createdConfig, stopProfiling);
                            a.createdConfig &#61; null;
                        } catch (RemoteException ex) {
                            throw ex.rethrowFromSystemServer();
                        }
                    }
                    prev &#61; a;
                    a &#61; a.nextIdle;
                    prev.nextIdle &#61; null;
                } while (a !&#61; null);
            }
            if (stopProfiling) {
                mProfiler.stopProfiling();
            }
            return false;
        }
    }
</code></pre> 
<h3><a id="14_AMSactivityIdle_96"></a>1.4 AMS.activityIdle</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code> &#64;Override
    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
        final long origId &#61; Binder.clearCallingIdentity();
        synchronized (this) {
            ActivityStack stack &#61; ActivityRecord.getStackLocked(token);
            if (stack !&#61; null) {
                //见1.5节
                ActivityRecord r &#61;
                        mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */,
                                false /* processPausingActivities */, config);
                if (stopProfiling) {
                    if ((mProfileProc &#61;&#61; r.app) &amp;&amp; mProfilerInfo !&#61; null) {
                        clearProfilerLocked();
                    }
                }
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
</code></pre> 
<h3><a id="15_ASSactivityIdleInternalLocked_122"></a>1.5 ASS.activityIdleInternalLocked</h3> 
<p>[-&gt;ActivityStackSupervisor.java]</p> 
<pre><code> // Checked.
    &#64;GuardedBy(&#34;mService&#34;)
    final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,
            boolean processPausingActivities, Configuration config) {
        if (DEBUG_ALL) Slog.v(TAG, &#34;Activity idle: &#34; &#43; token);

        ArrayList&lt;ActivityRecord&gt; finishes &#61; null;
        ArrayList&lt;UserState&gt; startingUsers &#61; null;
        int NS &#61; 0;
        int NF &#61; 0;
        boolean booting &#61; false;
        boolean activityRemoved &#61; false;

        ActivityRecord r &#61; ActivityRecord.forTokenLocked(token);
        if (r !&#61; null) {
            if (DEBUG_IDLE) Slog.d(TAG_IDLE, &#34;activityIdleInternalLocked: Callers&#61;&#34;
                    &#43; Debug.getCallers(4));
            mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);
            //启动结束
            r.finishLaunchTickingLocked();
            if (fromTimeout) {
                reportActivityLaunchedLocked(fromTimeout, r, INVALID_DELAY);
            }

            // This is a hack to semi-deal with a race condition
            // in the client where it can be constructed with a
            // newer configuration from when we asked it to launch.
            // We&#39;ll update with whatever configuration it now says
            // it used to launch.
            if (config !&#61; null) {
                r.setLastReportedGlobalConfiguration(config);
            }

            // We are now idle.  If someone is waiting for a thumbnail from
            // us, we can now deliver.
            r.idle &#61; true;

            //Slog.i(TAG, &#34;IDLE: mBooted&#61;&#34; &#43; mBooted &#43; &#34;, fromTimeout&#61;&#34; &#43; fromTimeout);
            if (isFocusedStack(r.getStack()) || fromTimeout) {
                //检查系统是否开机完成&#xff0c;见1.5节
                booting &#61; checkFinishBootingLocked();
            }
        }
        //移除超时
        if (allResumedActivitiesIdle()) {
            if (r !&#61; null) {
                mService.scheduleAppGcsLocked();
            }

            if (mLaunchingActivity.isHeld()) {
                mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
                if (VALIDATE_WAKE_LOCK_CALLER &amp;&amp;
                        Binder.getCallingUid() !&#61; Process.myUid()) {
                    throw new IllegalStateException(&#34;Calling must be system uid&#34;);
                }
                mLaunchingActivity.release();
            }
            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
        }

        // Atomically retrieve all of the other things to do.
        final ArrayList&lt;ActivityRecord&gt; stops &#61; processStoppingActivitiesLocked(r,
                true /* remove */, processPausingActivities);
        NS &#61; stops !&#61; null ? stops.size() : 0;
        if ((NF &#61; mFinishingActivities.size()) &gt; 0) {
            finishes &#61; new ArrayList&lt;&gt;(mFinishingActivities);
            mFinishingActivities.clear();
        }

        if (mStartingUsers.size() &gt; 0) {
            startingUsers &#61; new ArrayList&lt;&gt;(mStartingUsers);
            mStartingUsers.clear();
        }
        //停止其他Activity
        // Stop any activities that are scheduled to do so but have been
        // waiting for the next one to start.
        for (int i &#61; 0; i &lt; NS; i&#43;&#43;) {
            r &#61; stops.get(i);
            final ActivityStack stack &#61; r.getStack();
            if (stack !&#61; null) {
                if (r.finishing) {
                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,
                            &#34;activityIdleInternalLocked&#34;);
                } else {
                    stack.stopActivityLocked(r);
                }
            }
        }

        // Finish any activities that are scheduled to do so but have been
        // waiting for the next one to start.
        for (int i &#61; 0; i &lt; NF; i&#43;&#43;) {
            r &#61; finishes.get(i);
            final ActivityStack stack &#61; r.getStack();
            if (stack !&#61; null) {
                activityRemoved |&#61; stack.destroyActivityLocked(r, true, &#34;finish-idle&#34;);
            }
        }
        //没有开机完成&#xff0c;切换user
        if (!booting) {
            // Complete user switch
            if (startingUsers !&#61; null) {
                for (int i &#61; 0; i &lt; startingUsers.size(); i&#43;&#43;) {
                    mService.mUserController.finishUserSwitch(startingUsers.get(i));
                }
            }
        }

        mService.trimApplications();
        //dump();
        //mWindowManager.dump();

        if (activityRemoved) {
            resumeFocusedStackTopActivityLocked();
        }

        return r;
    }

</code></pre> 
<p>这个和开机广播相关的是检查是否还在开机阶段。如果桌面启动完成&#xff0c;开机动画就结束了。</p> 
<h3><a id="16_ASScheckFinishBootingLocked_250"></a>1.6 ASS.checkFinishBootingLocked</h3> 
<p>[-&gt;ActivityStackSupervisor.java]</p> 
<pre><code>  /**
     * Called when the frontmost task is idle.
     * &#64;return the state of mService.mBooting before this was called.
     */
    &#64;GuardedBy(&#34;mService&#34;)
    private boolean checkFinishBootingLocked() {
        final boolean booting &#61; mService.mBooting;
        boolean enableScreen &#61; false;
        mService.mBooting &#61; false;
        if (!mService.mBooted) {
            mService.mBooted &#61; true;
            enableScreen &#61; true;
        }
        if (booting || enableScreen) {
            //booting &#61; true,enableScreen &#61; true
            mService.postFinishBooting(booting, enableScreen);
        }
        return booting;
    }
</code></pre> 
<p>mService.mBooting是在ASM.systemReady中设置为true的&#xff0c;这里会修改 mService.mBooting为false;这里由于booting为true&#xff0c;所以会执行postFinishBooting方法。</p> 
<h3><a id="17_AMSpostFinishBooting_278"></a>1.7 AMS.postFinishBooting</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code> void postFinishBooting(boolean finishBooting, boolean enableScreen) {
        //传入的是true,true
        mHandler.sendMessage(mHandler.obtainMessage(FINISH_BOOTING_MSG,
                finishBooting ? 1 : 0, enableScreen ? 1 : 0));
    }
</code></pre> 
<pre><code>      public void handleMessage(Message msg) {
            switch (msg.what) {
               //msg.arg1 &#61; 1;msg.arg2&#61;1
               case FINISH_BOOTING_MSG: {
                if (msg.arg1 !&#61; 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &#34;FinishBooting&#34;);
                    //见1.8节
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 !&#61; 0) {
                    //见1.9节
                    enableScreenAfterBoot();
                }
                break;
            }
            }
       }
</code></pre> 
<p>这里Message要做两件事情finishBooting和enableScreenAfterBoot</p> 
<h3><a id="18_AMSfinishBooting_313"></a>1.8 AMS.finishBooting</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code>final void finishBooting() {
        synchronized (this) {
            //第一次进入为false,所以这里直接返回了
            if (!mBootAnimationComplete) {
                mCallFinishBooting &#61; true;
                return;
            }
            mCallFinishBooting &#61; false;
        }
        ....
    }
</code></pre> 
<p>第一次进来时mBootAnimationComplete是为false的&#xff0c;只有动画完成了才会回调方法bootAnimationComplete设置为true&#xff0c;所以这里直接返回了&#xff0c;这里再看下第二件事情enableScreenAfterBoot。</p> 
<h3><a id="19_AMSenableScreenAfterBoot_333"></a>1.9 AMS.enableScreenAfterBoot</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code>   void enableScreenAfterBoot() {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN,
                SystemClock.uptimeMillis());
        mWindowManager.enableScreenAfterBoot();

        synchronized (this) {
            updateEventDispatchingLocked();
        }
    }   
</code></pre> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code> public void enableScreenAfterBoot() {
        synchronized(mWindowMap) {
            if (DEBUG_BOOT) {
                RuntimeException here &#61; new RuntimeException(&#34;here&#34;);
                here.fillInStackTrace();
                Slog.i(TAG_WM, &#34;enableScreenAfterBoot: mDisplayEnabled&#61;&#34; &#43; mDisplayEnabled
                        &#43; &#34; mForceDisplayEnabled&#61;&#34; &#43; mForceDisplayEnabled
                        &#43; &#34; mShowingBootMessages&#61;&#34; &#43; mShowingBootMessages
                        &#43; &#34; mSystemBooted&#61;&#34; &#43; mSystemBooted, here);
            }
            if (mSystemBooted) {
                return;
            }
            mSystemBooted &#61; true;
            /见下文
            hideBootMessagesLocked();
            // If the screen still doesn&#39;t come up after 30 seconds, give
            // up and turn it on.
            mH.sendEmptyMessageDelayed(H.BOOT_TIMEOUT, 30 * 1000);
        }

        mPolicy.systemBooted();
        //见1.10节
        performEnableScreen();
    }
</code></pre> 
<p>mSystemBooted初始值为false&#xff0c;这里会设置成true。mShowingBootMessages为true时改成false&#xff0c;然后设置一个30s的延迟消息&#xff0c;随后调用systemBooted方法&#xff0c;通知keyguard开机完成&#xff0c;最后执行performEnableScreen方法。</p> 
<h4><a id="191_WMShideBootMessagesLocked_381"></a>1.9.1 WMS.hideBootMessagesLocked</h4> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code> public void hideBootMessagesLocked() {
        if (DEBUG_BOOT) {
            RuntimeException here &#61; new RuntimeException(&#34;here&#34;);
            here.fillInStackTrace();
            Slog.i(TAG_WM, &#34;hideBootMessagesLocked: mDisplayEnabled&#61;&#34; &#43; mDisplayEnabled
                    &#43; &#34; mForceDisplayEnabled&#61;&#34; &#43; mForceDisplayEnabled
                    &#43; &#34; mShowingBootMessages&#61;&#34; &#43; mShowingBootMessages
                    &#43; &#34; mSystemBooted&#61;&#34; &#43; mSystemBooted, here);
        }
        if (mShowingBootMessages) {
            mShowingBootMessages &#61; false;
            mPolicy.hideBootMessages();
        }
    }
</code></pre> 
<h4><a id="192__PWMhideBootMessages_402"></a>1.9.2 PWM.hideBootMessages</h4> 
<p>[-&gt;PhoneWindowManager.java]</p> 
<pre><code> /** {&#64;inheritDoc} */
    &#64;Override
    public void hideBootMessages() {
        mHandler.sendEmptyMessage(MSG_HIDE_BOOT_MESSAGE);
    }
     public void handleMessage(Message msg) {
          case MSG_HIDE_BOOT_MESSAGE:
             handleHideBootMessage();
            break;
      }
</code></pre> 
<p>这个过程主要是隐藏开机过程中显示的Android系统正在启动或者Android系统正在升级的dialog提示。</p> 
<p>该dialog的启动是在SystemServer中启动PKMS初始化开始的&#xff0c;可以参考文章PKMS的启动过程。</p> 
<p>在启动过程中会执行mPackageManagerService.updatePackagesIfNeeded方法&#xff0c;其中有performDexOptUpgrade方法。</p> 
<p>这个方法主要是对package进行dexoat升级。</p> 
<pre><code> private int[] performDexOptUpgrade(List&lt;PackageParser.Package&gt; pkgs, boolean showDialog,
            final int compilationReason, boolean bootComplete) {
            ...
            if (showDialog) {
                try {
                    //启动开机过程中出现的dialog
                    ActivityManager.getService().showBootMessage(
                            mContext.getResources().getString(R.string.android_upgrading_apk,
                                    numberOfPackagesVisited, numberOfPackagesToDexopt), true);
                } catch (RemoteException e) {
                }
                synchronized (mPackages) {
                    mDexOptDialogShown &#61; true;
                }
            }

            ...
        return new int[] { numberOfPackagesOptimized, numberOfPackagesSkipped,
                numberOfPackagesFailed };
    }
    
     &#64;Override
    public void showBootMessage(final CharSequence msg, final boolean always) {
        if (Binder.getCallingUid() !&#61; myUid()) {
            throw new SecurityException();
        }
        mWindowManager.showBootMessage(msg, always);
    }
    
    

</code></pre> 
<p>调用显示正在开机的dialog。</p> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code> public void showBootMessage(final CharSequence msg, final boolean always) {
        boolean first &#61; false;
        synchronized(mWindowMap) {
            if (DEBUG_BOOT) {
                RuntimeException here &#61; new RuntimeException(&#34;here&#34;);
                here.fillInStackTrace();
                Slog.i(TAG_WM, &#34;showBootMessage: msg&#61;&#34; &#43; msg &#43; &#34; always&#61;&#34; &#43; always
                        &#43; &#34; mAllowBootMessages&#61;&#34; &#43; mAllowBootMessages
                        &#43; &#34; mShowingBootMessages&#61;&#34; &#43; mShowingBootMessages
                        &#43; &#34; mSystemBooted&#61;&#34; &#43; mSystemBooted, here);
            }
            if (!mAllowBootMessages) {
                return;
            }
            if (!mShowingBootMessages) {
                if (!always) {
                    return;
                }
                first &#61; true;
            }
            if (mSystemBooted) {
                return;
            }
            mShowingBootMessages &#61; true;
            mPolicy.showBootMessage(msg, always);
        }
        if (first) {
            performEnableScreen();
        }
    }
</code></pre> 
<p>下面正式显示dialog&#xff0c;mShowingBootMessages这里设置成true。</p> 
<p>[-&gt;PhoneWindowManager.java]</p> 
<pre><code> /** {&#64;inheritDoc} */
    &#64;Override
    public void showBootMessage(final CharSequence msg, final boolean always) {
        mHandler.post(new Runnable() {
            &#64;Override public void run() {
                if (mBootMsgDialog &#61;&#61; null) {
                    int theme;
                    if (mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK)) {
                        theme &#61; com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                    } else {
                        theme &#61; 0;
                    }

                    mBootMsgDialog &#61; new ProgressDialog(mContext, theme) {
                        // This dialog will consume all events coming in to
                        // it, to avoid it trying to do things too early in boot.
                        &#64;Override public boolean dispatchKeyEvent(KeyEvent event) {
                            return true;
                        }
                        &#64;Override public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                            return true;
                        }
                        &#64;Override public boolean dispatchTouchEvent(MotionEvent ev) {
                            return true;
                        }
                        &#64;Override public boolean dispatchTrackballEvent(MotionEvent ev) {
                            return true;
                        }
                        &#64;Override public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                            return true;
                        }
                        &#64;Override public boolean dispatchPopulateAccessibilityEvent(
                                AccessibilityEvent event) {
                            return true;
                        }
                    };
                    if (mContext.getPackageManager().isUpgrade()) {
                        mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                    } else {
                        mBootMsgDialog.setTitle(R.string.android_start_title);
                    }
                    mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                    mBootMsgDialog.setIndeterminate(true);
                    mBootMsgDialog.getWindow().setType(
                            WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                    mBootMsgDialog.getWindow().addFlags(
                            WindowManager.LayoutParams.FLAG_DIM_BEHIND
                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                    mBootMsgDialog.getWindow().setDimAmount(1);
                    WindowManager.LayoutParams lp &#61; mBootMsgDialog.getWindow().getAttributes();
                    lp.screenOrientation &#61; ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                    mBootMsgDialog.getWindow().setAttributes(lp);
                    mBootMsgDialog.setCancelable(false);
                    mBootMsgDialog.show();
                }
                mBootMsgDialog.setMessage(msg);
            }
        });
    }
</code></pre> 
<p>最后看下handleHideBootMessage&#xff0c;这里会取消dialog显示</p> 
<pre><code> private void handleHideBootMessage() {
        synchronized (mLock) {
            if (!mKeyguardDrawnOnce) {
                mBootMessageNeedsHiding &#61; true;
                return; // keyguard hasn&#39;t drawn the first time yet, not done booting
            }
        }

        if (mBootMsgDialog !&#61; null) {
            if (DEBUG_WAKEUP) Slog.d(TAG, &#34;handleHideBootMessage: dismissing&#34;);
            mBootMsgDialog.dismiss();
            mBootMsgDialog &#61; null;
        }
    }
</code></pre> 
<h4><a id="193_PWMsystemBooted_583"></a>1.9.3 PWM.systemBooted</h4> 
<p>[-&gt;PhoneWindowManager.java]</p> 
<pre><code>    /** {&#64;inheritDoc} */
    &#64;Override
    public void systemBooted() {
        bindKeyguard();
        synchronized (mLock) {
            mSystemBooted &#61; true;
            //在systemserver启动中&#xff0c;设置成了true
            if (mSystemReady) {
                //通知keyguard&#xff0c;开机完成
                mKeyguardDelegate.onBootCompleted();
            }
        }
        startedWakingUp();
        screenTurningOn(null);
        screenTurnedOn();
    }

</code></pre> 
<h4><a id="194_mHsendEmptyMessageDelayed_607"></a>1.9.4 mH.sendEmptyMessageDelayed</h4> 
<p>[-&gt;WindowManagerService.java]</p> 
<p>发送消息&#xff0c;最后执行performBootTimeout方法&#xff0c;可以看到performBootTimeout最后执行的是performEnableScreen方法。</p> 
<pre><code>&#64;Override
public void handleMessage(Message msg) {case BOOT_TIMEOUT: {
        performBootTimeout();
        break;
 }
</code></pre> 
<pre><code> public void performBootTimeout() {
        synchronized(mWindowMap) {
            //这个参数在动画结束时才为true,见1.10节
            if (mDisplayEnabled) {
                return;
            }
            Slog.w(TAG_WM, &#34;***** BOOT TIMEOUT: forcing display enabled&#34;);
            mForceDisplayEnabled &#61; true;
        }
        //如果30s内动画还没完完成则&#xff0c;再执行performEnableScreen
        performEnableScreen();
    }
</code></pre> 
<h3><a id="110_WMSperformEnableScreen_636"></a>1.10 WMS.performEnableScreen</h3> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code>private void performEnableScreen() {
        synchronized(mWindowMap) {
            if (DEBUG_BOOT) Slog.i(TAG_WM, &#34;performEnableScreen: mDisplayEnabled&#61;&#34; &#43; mDisplayEnabled
                    &#43; &#34; mForceDisplayEnabled&#61;&#34; &#43; mForceDisplayEnabled
                    &#43; &#34; mShowingBootMessages&#61;&#34; &#43; mShowingBootMessages
                    &#43; &#34; mSystemBooted&#61;&#34; &#43; mSystemBooted
                    &#43; &#34; mOnlyCore&#61;&#34; &#43; mOnlyCore,
                    new RuntimeException(&#34;here&#34;).fillInStackTrace());
           
            if (mDisplayEnabled) {
                return;
            }
            //mSystemBooted为true,在1.9节中设置
            if (!mSystemBooted &amp;&amp; !mShowingBootMessages) {
                return;
            }
            //1.9.1节mShowingBootMessages设置成了false&#xff0c;关键判断canDismissBootAnimation
            if (!mShowingBootMessages &amp;&amp; !mPolicy.canDismissBootAnimation()) {
                return;
            }

            // Don&#39;t enable the screen until all existing windows have been drawn.
            //等所有的窗口都绘制完成&#xff0c;才能使能屏幕&#xff0c;见1.10.2节
            if (!mForceDisplayEnabled
                    // TODO(multidisplay): Expand to all displays?
                    &amp;&amp; getDefaultDisplayContentLocked().checkWaitingForWindows()) {
                return;
            }
            //没有停止动画
            if (!mBootAnimationStopped) {
                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, &#34;Stop bootanim&#34;, 0);
                // stop boot animation
                // formerly we would just kill the process, but we now ask it to exit so it
                // can choose where to stop the animation.
                SystemProperties.set(&#34;service.bootanim.exit&#34;, &#34;1&#34;);
                mBootAnimationStopped &#61; true;
            }
            //检查开机动画是否完成&#xff0c;见1.10.3节
            if (!mForceDisplayEnabled &amp;&amp; !checkBootAnimationCompleteLocked()) {
                if (DEBUG_BOOT) Slog.i(TAG_WM, &#34;performEnableScreen: Waiting for anim complete&#34;);
                return;
            }

            try {
                //通知surfaceFlinger完成
                IBinder surfaceFlinger &#61; ServiceManager.getService(&#34;SurfaceFlinger&#34;);
                if (surfaceFlinger !&#61; null) {
                    Slog.i(TAG_WM, &#34;******* TELLING SURFACE FLINGER WE ARE BOOTED!&#34;);
                    Parcel data &#61; Parcel.obtain();
                    data.writeInterfaceToken(&#34;android.ui.ISurfaceComposer&#34;);
                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                            data, null, 0);
                    data.recycle();
                }
            } catch (RemoteException ex) {
                Slog.e(TAG_WM, &#34;Boot completed: SurfaceFlinger is dead!&#34;);
            }

            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());
            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, &#34;Stop bootanim&#34;, 0);
            //这里开机动画已经结束
            mDisplayEnabled &#61; true;
            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, &#34;******************** ENABLING SCREEN!&#34;);

            // Enable input dispatch.
            mInputMonitor.setEventDispatchingLw(mEventDispatchingEnabled);
        }

        try {
            mActivityManager.bootAnimationComplete();
        } catch (RemoteException e) {
        }
       
        mPolicy.enableScreenAfterBoot();

        // Make sure the last requested orientation has been applied.
        updateRotationUnchecked(false, false);
    }
</code></pre> 
<ul><li> <p>这里主要的工作是停止开机动画&#xff0c;通知SurfaceFlinger开机结束等。在停止开机动画前会有很多的判断&#xff0c;如果现有的window&#xff08;桌面&#xff0c;状态栏&#xff0c;keyguard&#xff0c;壁纸等&#xff09;都已经绘制完成包括&#xff0c;才会停止动画。</p> </li><li> <p>停止动画是执行了SystemProperties.set(“service.bootanim.exit”, “1”)&#xff1b;在system/bin/bootanimation一般会在显示的时候循环查询这个prop的值&#xff0c;如果变成了1则推出。</p> </li></ul> 
<h4><a id="1101_PWMcanDismissBootAnimation_725"></a>1.10.1 PWM.canDismissBootAnimation</h4> 
<p>[-&gt;PhoneWindowManager.java]</p> 
<pre><code>  &#64;Override
    public boolean canDismissBootAnimation() {
        synchronized (mLock) {
            return mKeyguardDrawComplete;
        }
    }
</code></pre> 
<p>mKeyguardDrawComplete是Keyguard是否绘制完成&#xff0c;绘制完成才会进入下面的方法。</p> 
<h4><a id="1102__checkWaitingForWindows_740"></a>1.10.2 checkWaitingForWindows</h4> 
<p>[-&gt;DisplayContent.java]</p> 
<pre><code> boolean checkWaitingForWindows() {

        mHaveBootMsg &#61; false;
        mHaveApp &#61; false;
        mHaveWallpaper &#61; false;
        mHaveKeyguard &#61; true;

        final WindowState visibleWindow &#61; getWindow(w -&gt; {
            if (w.isVisibleLw() &amp;&amp; !w.mObscured &amp;&amp; !w.isDrawnLw()) {
                return true;
            }
            if (w.isDrawnLw()) {
                if (w.mAttrs.type &#61;&#61; TYPE_BOOT_PROGRESS) {
                    mHaveBootMsg &#61; true;
                } else if (w.mAttrs.type &#61;&#61; TYPE_APPLICATION
                        || w.mAttrs.type &#61;&#61; TYPE_DRAWN_APPLICATION) {
                    mHaveApp &#61; true;
                } else if (w.mAttrs.type &#61;&#61; TYPE_WALLPAPER) {
                    mHaveWallpaper &#61; true;
                } else if (w.mAttrs.type &#61;&#61; TYPE_STATUS_BAR) {
                    mHaveKeyguard &#61; mService.mPolicy.isKeyguardDrawnLw();
                }
            }
            return false;
        });

        if (visibleWindow !&#61; null) {
            // We have a visible window.
            return true;
        }

        // if the wallpaper service is disabled on the device, we&#39;re never going to have
        // wallpaper, don&#39;t bother waiting for it
        boolean wallpaperEnabled &#61; mService.mContext.getResources().getBoolean(
                com.android.internal.R.bool.config_enableWallpaperService)
                &amp;&amp; mService.mContext.getResources().getBoolean(
                        com.android.internal.R.bool.config_checkWallpaperAtBoot)
                &amp;&amp; !mService.mOnlyCore;

        if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM,
                &#34;******** booted&#61;&#34; &#43; mService.mSystemBooted
                &#43; &#34; msg&#61;&#34; &#43; mService.mShowingBootMessages
                &#43; &#34; haveBoot&#61;&#34; &#43; mHaveBootMsg &#43; &#34; haveApp&#61;&#34; &#43; mHaveApp
                &#43; &#34; haveWall&#61;&#34; &#43; mHaveWallpaper &#43; &#34; wallEnabled&#61;&#34; &#43; wallpaperEnabled
                &#43; &#34; haveKeyguard&#61;&#34; &#43; mHaveKeyguard);

        // If we are turning on the screen to show the boot message, don&#39;t do it until the boot
        // message is actually displayed.
        if (!mService.mSystemBooted &amp;&amp; !mHaveBootMsg) {
            return true;
        }

        // If we are turning on the screen after the boot is completed normally, don&#39;t do so until
        // we have the application and wallpaper.
        if (mService.mSystemBooted
                &amp;&amp; ((!mHaveApp &amp;&amp; !mHaveKeyguard) || (wallpaperEnabled &amp;&amp; !mHaveWallpaper))) {
            return true;
        }

        return false;
    }
</code></pre> 
<h4><a id="1103__WMScheckWaitingForWindows_808"></a>1.10.3 WMS.checkWaitingForWindows</h4> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code> private boolean checkBootAnimationCompleteLocked() {
        if (SystemService.isRunning(BOOT_ANIMATION_SERVICE)) {
            mH.removeMessages(H.CHECK_IF_BOOT_ANIMATION_FINISHED);
            mH.sendEmptyMessageDelayed(H.CHECK_IF_BOOT_ANIMATION_FINISHED,
                    BOOT_ANIMATION_POLL_INTERVAL);
            if (DEBUG_BOOT) Slog.i(TAG_WM, &#34;checkBootAnimationComplete: Waiting for anim complete&#34;);
            return false;
        }
        if (DEBUG_BOOT) Slog.i(TAG_WM, &#34;checkBootAnimationComplete: Animation complete!&#34;);
        return true;
    }

</code></pre> 
<p>这里判断开机动画是否停止通过判断BOOT_ANIMATION_SERVICE服务是否在运行。</p> 
<h4><a id="1104_WMSenableScreenIfNeeded_829"></a>1.10.4 WMS.enableScreenIfNeeded</h4> 
<p>performEnableScreen里面并不能一次就能停止动画&#xff0c;查看日志&#xff1a;</p> 
<pre><code>01-01 22:00:26.180  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:26.180  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:26.182  2496  3120 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:26.182  2496  3120 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:26.521  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:26.521  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.166  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.166  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.193  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.193  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.198  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.198  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.200  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.200  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.201  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.201  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.207  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.207  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:27.873  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:27.873  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.807  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:37.807  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.809  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:37.809  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.819  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:37.819  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.825  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete
01-01 22:00:37.830  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:37.830  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.830  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete
01-01 22:00:37.839  2496  3127 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
01-01 22:00:37.839  2496  3127 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:6073)
01-01 22:00:37.840  2496  3127 I WindowManager: performEnableScreen: Waiting for anim complete
</code></pre> 
<p>除了从Launch发起的流程调用这里之外&#xff0c;还有其他的调用点&#xff0c;在WMS里面经过enableScreenIfNeeded方法发送ENABLE_SCREEN 消息给Handler进行处理。</p> 
<p>[-&gt;WindowManagerService.java]</p> 
<pre><code> &#64;Override
    public void enableScreenIfNeeded() {
        synchronized (mWindowMap) {
            enableScreenIfNeededLocked();
        }
    }

    void enableScreenIfNeededLocked() {
        if (DEBUG_BOOT) {
            RuntimeException here &#61; new RuntimeException(&#34;here&#34;);
            here.fillInStackTrace();
            Slog.i(TAG_WM, &#34;enableScreenIfNeededLocked: mDisplayEnabled&#61;&#34; &#43; mDisplayEnabled
                    &#43; &#34; mForceDisplayEnabled&#61;&#34; &#43; mForceDisplayEnabled
                    &#43; &#34; mShowingBootMessages&#61;&#34; &#43; mShowingBootMessages
                    &#43; &#34; mSystemBooted&#61;&#34; &#43; mSystemBooted, here);
        }
        if (mDisplayEnabled) {
            return;
        }
        if (!mSystemBooted &amp;&amp; !mShowingBootMessages) {
            return;
        }
        mH.sendEmptyMessage(H.ENABLE_SCREEN);
    }
    public void handleMessage(Message msg) {
        ...
        case ENABLE_SCREEN: {
                performEnableScreen();
                break;
        }
        ...
    }
</code></pre> 
<p>enableScreenIfNeededLocked这个方法也调用的十分的频繁&#xff0c;调用点也有多个位置&#xff0c;大部分的调用栈如下&#xff0c;在WMS每次进行performSurfacePlacement等主要是完成绘制布局之后检查调用。在发送ENABLE_SCREEN消息之前会判断mDisplayEnabled是否为true&#xff0c;如果通过performEnableScreen设置为true&#xff0c;则不再执行&#xff0c;避免了重复操作。</p> 
<pre><code>10-08 08:43:06.756  1592  2422 I WindowManager: enableScreenIfNeededLocked: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true
10-08 08:43:06.756  1592  2422 I WindowManager: java.lang.RuntimeException: here
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowManagerService.enableScreenIfNeededLocked(WindowManagerService.java:3417)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.RootWindowContainer.performSurfacePlacement(RootWindowContainer.java:818)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacementLoop(WindowSurfacePlacer.java:207)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacement(WindowSurfacePlacer.java:155)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.WindowManagerService.relayoutWindow(WindowManagerService.java:2031)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.Session.relayout(Session.java:244)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at android.view.IWindowSession$Stub.onTransact(IWindowSession.java:309)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at com.android.server.wm.Session.onTransact(Session.java:164)
10-08 08:43:06.756  1592  2422 I WindowManager: 	at android.os.Binder.execTransact(Binder.java:731)
10-08 08:43:06.763  1592  1811 I WindowManager: skytoby performEnableScreen: mDisplayEnabled&#61;false mForceDisplayEnabled&#61;false mShowingBootMessages&#61;false mSystemBooted&#61;true mOnlyCore&#61;false
10-08 08:43:06.763  1592  1811 I WindowManager: java.lang.RuntimeException: here
10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:3457)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService.access$1100(WindowManagerService.java:274)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.wm.WindowManagerService$H.handleMessage(WindowManagerService.java:4845)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.Handler.dispatchMessage(Handler.java:106)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.Looper.loop(Looper.java:193)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at android.os.HandlerThread.run(HandlerThread.java:65)
10-08 08:43:06.763  1592  1811 I WindowManager: 	at com.android.server.ServiceThread.run(ServiceThread.java:44
</code></pre> 
<h3><a id="111__AMSbootAnimationComplete_933"></a>1.11 AMS.bootAnimationComplete</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code> &#64;Override
    public void bootAnimationComplete() {
        final boolean callFinishBooting;
        synchronized (this) {
            callFinishBooting &#61; mCallFinishBooting;
            mBootAnimationComplete &#61; true;
        }
        if (callFinishBooting) {
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &#34;FinishBooting&#34;);
            finishBooting();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }
</code></pre> 
<p>在1.8节中mCallFinishBooting设置成true了&#xff0c;所以这里会执行finishBooting方法。通过bootAnimationComplete这个回调方法&#xff0c;再一次进入到了finishBooting方法。</p> 
<h3><a id="112__AMSfinishBooting_955"></a>1.12 AMS.finishBooting</h3> 
<p>[-&gt;ActivityManagerService.java]</p> 
<pre><code> final void finishBooting() {
        synchronized (this) {
            //在1.8节中进入到这里&#xff0c;这次会跳过
            if (!mBootAnimationComplete) {
                mCallFinishBooting &#61; true;
                return;
            }
            mCallFinishBooting &#61; false;
        }
        //abi设置开机完成flag
        ArraySet&lt;String&gt; completedIsas &#61; new ArraySet&lt;String&gt;();
        for (String abi : Build.SUPPORTED_ABIS) {
            ZYGOTE_PROCESS.establishZygoteConnectionForAbi(abi);
            final String instructionSet &#61; VMRuntime.getInstructionSet(abi);
            if (!completedIsas.contains(instructionSet)) {
                try {
                    mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
                } catch (InstallerException e) {
                    if (!VMRuntime.didPruneDalvikCache()) {
                        // This is technically not the right filter, as different zygotes may
                        // have made different pruning decisions. But the log is best effort,
                        // anyways.
                        Slog.w(TAG, &#34;Unable to mark boot complete for abi: &#34; &#43; abi &#43; &#34; (&#34; &#43;
                                e.getMessage() &#43;&#34;)&#34;);
                    }
                }
                completedIsas.add(instructionSet);
            }
        }
        //注册应用重启广播
        IntentFilter pkgFilter &#61; new IntentFilter();
        pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
        pkgFilter.addDataScheme(&#34;package&#34;);
        mContext.registerReceiver(new BroadcastReceiver() {
            &#64;Override
            public void onReceive(Context context, Intent intent) {
                String[] pkgs &#61; intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
                if (pkgs !&#61; null) {
                    for (String pkg : pkgs) {
                        synchronized (ActivityManagerService.this) {
                            if (forceStopPackageLocked(pkg, -1, false, false, false, false, false,
                                    0, &#34;query restart&#34;)) {
                                setResultCode(Activity.RESULT_OK);
                                return;
                            }
                        }
                    }
                }
            }
        }, pkgFilter);
        //注册ACTION_DELETE_DUMPHEAP广播
        IntentFilter dumpheapFilter &#61; new IntentFilter();
        dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
        mContext.registerReceiver(new BroadcastReceiver() {
            &#64;Override
            public void onReceive(Context context, Intent intent) {
                if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                    mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5*60*1000);
                } else {
                    mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
                }
            }
        }, dumpheapFilter);
        
        //通知系统服务开机完成
        // Let system services know.
        mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);

        synchronized (this) {
            //之前onhold的进程&#xff0c;开始启动
            // Ensure that any processes we had put on hold are now started
            // up.
            final int NP &#61; mProcessesOnHold.size();
            if (NP &gt; 0) {
                ArrayList&lt;ProcessRecord&gt; procs &#61;
                    new ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold);
                for (int ip&#61;0; ip&lt;NP; ip&#43;&#43;) {
                    if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &#34;Starting process on hold: &#34;
                            &#43; procs.get(ip));
                    startProcessLocked(procs.get(ip), &#34;on-hold&#34;, null);
                }
            }
            if (mFactoryTest &#61;&#61; FactoryTest.FACTORY_TEST_LOW_LEVEL) {
                return;
            }
            // Start looking for apps that are abusing wake locks.
            Message nmsg &#61; mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
            mHandler.sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
            // Tell anyone interested that we are done booting!
            SystemProperties.set(&#34;sys.boot_completed&#34;, &#34;1&#34;);

            // And trigger dev.bootcomplete if we are not showing encryption progress
            if (!&#34;trigger_restart_min_framework&#34;.equals(VoldProperties.decrypt().orElse(&#34;&#34;))
                    || &#34;&#34;.equals(VoldProperties.encrypt_progress().orElse(&#34;&#34;))) {
                SystemProperties.set(&#34;dev.bootcomplete&#34;, &#34;1&#34;);
            }
            //发送开机完成广播
            mUserController.sendBootCompleted(
                    new IIntentReceiver.Stub() {
                        &#64;Override
                        public void performReceive(Intent intent, int resultCode,
                                String data, Bundle extras, boolean ordered,
                                boolean sticky, int sendingUser) {
                            synchronized (ActivityManagerService.this) {
                                //搜集各个进程的信息
                                requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                            }
                        }
                    });
            mUserController.scheduleStartProfiles();
        }
    }
</code></pre> 
<p>这里主要的工作是设置abi开机完成的flag&#xff0c;注册ACTION_QUERY_PACKAGE_RESTART和ACTION_DELETE_DUMPHEAP广播&#xff0c;通知系统服务开机启动完成&#xff0c;开启onhold进程&#xff0c;而后发送开机广播。</p> 
<h3><a id="113_UCsendBootCompleted_1076"></a>1.13 UC.sendBootCompleted</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code> void sendBootCompleted(IIntentReceiver resultTo) {
        // Get a copy of mStartedUsers to use outside of lock
        SparseArray&lt;UserState&gt; startedUsers;
        synchronized (mLock) {
            startedUsers &#61; mStartedUsers.clone();
        }
        //通知多个用户
        for (int i &#61; 0; i &lt; startedUsers.size(); i&#43;&#43;) {
            UserState uss &#61; startedUsers.valueAt(i);
            finishUserBoot(uss, resultTo);
        }
    }
</code></pre> 
<h3><a id="114_UCfinishUserBoot_1095"></a>1.14 UC.finishUserBoot</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code> private void finishUserBoot(UserState uss, IIntentReceiver resultTo) {
        final int userId &#61; uss.mHandle.getIdentifier();
        //用户不匹配则返回
        Slog.d(TAG, &#34;Finishing user boot &#34; &#43; userId);
        synchronized (mLock) {
            // Bail if we ended up with a stale user
            if (mStartedUsers.get(userId) !&#61; uss) {
                return;
            }
        }
        
        // We always walk through all the user lifecycle states to send
        // consistent developer events. We step into RUNNING_LOCKED here,
        // but we might immediately step into RUNNING below if the user
        // storage is already unlocked.
        //如果用户在锁定状态
        if (uss.setState(STATE_BOOTING, STATE_RUNNING_LOCKED)) {
            mInjector.getUserManagerInternal().setUserState(userId, uss.state);
            // Do not report secondary users, runtime restarts or first boot/upgrade
            if (userId &#61;&#61; UserHandle.USER_SYSTEM
                    &amp;&amp; !mInjector.isRuntimeRestarted() &amp;&amp; !mInjector.isFirstBootOrUpgrade()) {
                int uptimeSeconds &#61; (int)(SystemClock.elapsedRealtime() / 1000);
                MetricsLogger.histogram(mInjector.getContext(),
                        &#34;framework_locked_boot_completed&#34;, uptimeSeconds);
                final int MAX_UPTIME_SECONDS &#61; 120;
                if (uptimeSeconds &gt; MAX_UPTIME_SECONDS) {
                    Slog.wtf(&#34;SystemServerTiming&#34;,
                            &#34;finishUserBoot took too long. uptimeSeconds&#61;&#34; &#43; uptimeSeconds);
                }
            }
           
            mHandler.sendMessage(mHandler.obtainMessage(REPORT_LOCKED_BOOT_COMPLETE_MSG,
                    userId, 0));
            //发送锁屏开机广播 &#xff0c;为串行广播       
            Intent intent &#61; new Intent(Intent.ACTION_LOCKED_BOOT_COMPLETED, null);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);
            intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT
                    | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
            mInjector.broadcastIntent(intent, null, resultTo, 0, null, null,
                    new String[]{android.Manifest.permission.RECEIVE_BOOT_COMPLETED},
                    AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);
        }
        //解锁用户的credential-encrypted storage
        // We need to delay unlocking managed profiles until the parent user
        // is also unlocked.
        if (mInjector.getUserManager().isManagedProfile(userId)) {
            final UserInfo parent &#61; mInjector.getUserManager().getProfileParent(userId);
            if (parent !&#61; null
                    &amp;&amp; isUserRunning(parent.id, ActivityManager.FLAG_AND_UNLOCKED)) {
                Slog.d(TAG, &#34;User &#34; &#43; userId &#43; &#34; (parent &#34; &#43; parent.id
                        &#43; &#34;): attempting unlock because parent is unlocked&#34;);
                maybeUnlockUser(userId);
            } else {
                String parentId &#61; (parent &#61;&#61; null) ? &#34;&lt;null&gt;&#34; : String.valueOf(parent.id);
                Slog.d(TAG, &#34;User &#34; &#43; userId &#43; &#34; (parent &#34; &#43; parentId
                        &#43; &#34;): delaying unlock because parent is locked&#34;);
            }
        } else {
            maybeUnlockUser(userId);
        }
    }
</code></pre> 
<h3><a id="115_UCmaybeUnlockUser_1163"></a>1.15 UC.maybeUnlockUser</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code> /**
     * Attempt to unlock user without a credential token. This typically
     * succeeds when the device doesn&#39;t have credential-encrypted storage, or
     * when the the credential-encrypted storage isn&#39;t tied to a user-provided
     * PIN or pattern.
     */
    private boolean maybeUnlockUser(final int userId) {
        // Try unlocking storage using empty token
        return unlockUserCleared(userId, null, null, null);
    }
</code></pre> 
<h3><a id="116_UCmaybeUnlockUser_1180"></a>1.16 UC.maybeUnlockUser</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code>  private boolean unlockUserCleared(final int userId, byte[] token, byte[] secret,
            IProgressListener listener) {
        UserState uss;
        //解锁user storage
        if (!StorageManager.isUserKeyUnlocked(userId)) {
            final UserInfo userInfo &#61; getUserInfo(userId);
            final IStorageManager storageManager &#61; getStorageManager();
            try {
                // We always want to unlock user storage, even user is not started yet
                storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);
            } catch (RemoteException | RuntimeException e) {
                Slog.w(TAG, &#34;Failed to unlock: &#34; &#43; e.getMessage());
            }
        }
        synchronized (mLock) {
            // Register the given listener to watch for unlock progress
            uss &#61; mStartedUsers.get(userId);
            if (uss !&#61; null) {
                uss.mUnlockProgress.addListener(listener);
                uss.tokenProvided &#61; (token !&#61; null);
            }
        }
        // Bail if user isn&#39;t actually running
        if (uss &#61;&#61; null) {
            notifyFinished(userId, listener);
            return false;
        }
        
        //完成解锁
        if (!finishUserUnlocking(uss)) {
            notifyFinished(userId, listener);
            return false;
        }

        //解锁其他的用户 
        // We just unlocked a user, so let&#39;s now attempt to unlock any
        // managed profiles under that user.

        // First, get list of userIds. Requires mLock, so we cannot make external calls, e.g. to UMS
        int[] userIds;
        synchronized (mLock) {
            userIds &#61; new int[mStartedUsers.size()];
            for (int i &#61; 0; i &lt; userIds.length; i&#43;&#43;) {
                userIds[i] &#61; mStartedUsers.keyAt(i);
            }
        }
        for (int testUserId : userIds) {
            final UserInfo parent &#61; mInjector.getUserManager().getProfileParent(testUserId);
            if (parent !&#61; null &amp;&amp; parent.id &#61;&#61; userId &amp;&amp; testUserId !&#61; userId) {
                Slog.d(TAG, &#34;User &#34; &#43; testUserId &#43; &#34; (parent &#34; &#43; parent.id
                        &#43; &#34;): attempting unlock because parent was just unlocked&#34;);
                maybeUnlockUser(testUserId);
            }
        }

        return true;
    }
</code></pre> 
<h3><a id="117_UCfinishUserUnlocking_1244"></a>1.17 UC.finishUserUnlocking</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code> /**
     * Step from {&#64;link UserState#STATE_RUNNING_LOCKED} to
     * {&#64;link UserState#STATE_RUNNING_UNLOCKING}.
     */
    private boolean finishUserUnlocking(final UserState uss) {
        final int userId &#61; uss.mHandle.getIdentifier();
        // Only keep marching forward if user is actually unlocked
        if (!StorageManager.isUserKeyUnlocked(userId)) return false;
        synchronized (mLock) {
            // Do not proceed if unexpected state or a stale user
            if (mStartedUsers.get(userId) !&#61; uss || uss.state !&#61; STATE_RUNNING_LOCKED) {
                return false;
            }
        }
        uss.mUnlockProgress.start();
        // 设置进度
        // Prepare app storage before we go any further
        uss.mUnlockProgress.setProgress(5,
                    mInjector.getContext().getString(R.string.android_start_title));

        // Call onBeforeUnlockUser on a worker thread that allows disk I/O
        FgThread.getHandler().post(() -&gt; {
            if (!StorageManager.isUserKeyUnlocked(userId)) {
                Slog.w(TAG, &#34;User key got locked unexpectedly, leaving user locked.&#34;);
                return;
            }
            mInjector.getUserManager().onBeforeUnlockUser(userId);
            synchronized (mLock) {
                // Do not proceed if unexpected state
                if (!uss.setState(STATE_RUNNING_LOCKED, STATE_RUNNING_UNLOCKING)) {
                    return;
                }
            }
            mInjector.getUserManagerInternal().setUserState(userId, uss.state);

            uss.mUnlockProgress.setProgress(20);
            //通知系统服务解锁完成
            // Dispatch unlocked to system services; when fully dispatched,
            // that calls through to the next &#34;unlocked&#34; phase
            mHandler.obtainMessage(SYSTEM_USER_UNLOCK_MSG, userId, 0, uss)
                    .sendToTarget();
        });
        return true;
    }
</code></pre> 
<p>通过mHandler发送到AMS的主Handler处理&#xff0c;由于UserController继承了Handler.Callback&#xff0c;其handleMessage就在UserController类中。</p> 
<h3><a id="118_UChandleMessage_1297"></a>1.18 UC.handleMessage</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code>public boolean handleMessage(Message msg) {
      ...
      case SYSTEM_USER_UNLOCK_MSG:
                final int userId &#61; msg.arg1;
                mInjector.getSystemServiceManager().unlockUser(userId);
                // Loads recents on a worker thread that allows disk I/O
                FgThread.getHandler().post(() -&gt; {
                    mInjector.loadUserRecents(userId);
                });
                finishUserUnlocked((UserState) msg.obj);
                break;
        ...        
 }
</code></pre> 
<p>首先unlockUser&#xff0c;加载RecentTask</p> 
<h3><a id="119_UCfinishUserUnlocked_1319"></a>1.19 UC.finishUserUnlocked</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code>  /**
     * Step from {&#64;link UserState#STATE_RUNNING_UNLOCKING} to
     * {&#64;link UserState#STATE_RUNNING_UNLOCKED}.
     */
    void finishUserUnlocked(final UserState uss) {
        final int userId &#61; uss.mHandle.getIdentifier();
        // Only keep marching forward if user is actually unlocked
        //没有解锁返回
        if (!StorageManager.isUserKeyUnlocked(userId)) return;
        synchronized (mLock) {
            // Bail if we ended up with a stale user
            if (mStartedUsers.get(uss.mHandle.getIdentifier()) !&#61; uss) return;

            // Do not proceed if unexpected state
            if (!uss.setState(STATE_RUNNING_UNLOCKING, STATE_RUNNING_UNLOCKED)) {
                return;
            }
        }
        //解锁完成
        mInjector.getUserManagerInternal().setUserState(userId, uss.state);
        uss.mUnlockProgress.finish();

        // Get unaware persistent apps running and start any unaware providers
        // in already-running apps that are partially aware
        if (userId &#61;&#61; UserHandle.USER_SYSTEM) {
            mInjector.startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
        }
        //加载credential-encrypted Providers
        mInjector.installEncryptionUnawareProviders(userId);

        // Dispatch unlocked to external apps
        //发送ACTION_USER_UNLOCKED广播&#xff0c;并行广播
        final Intent unlockedIntent &#61; new Intent(Intent.ACTION_USER_UNLOCKED);
        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);
        unlockedIntent.addFlags(
                Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        mInjector.broadcastIntent(unlockedIntent, null, null, 0, null,
                null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, SYSTEM_UID,
                userId);

        if (getUserInfo(userId).isManagedProfile()) {
            UserInfo parent &#61; mInjector.getUserManager().getProfileParent(userId);
            if (parent !&#61; null) {
                //发送ACTION_MANAGED_PROFILE_UNLOCKED广播&#xff0c;并行广播
                final Intent profileUnlockedIntent &#61; new Intent(
                        Intent.ACTION_MANAGED_PROFILE_UNLOCKED);
                profileUnlockedIntent.putExtra(Intent.EXTRA_USER, UserHandle.of(userId));
                profileUnlockedIntent.addFlags(
                        Intent.FLAG_RECEIVER_REGISTERED_ONLY
                                | Intent.FLAG_RECEIVER_FOREGROUND);
                mInjector.broadcastIntent(profileUnlockedIntent,
                        null, null, 0, null, null, null, AppOpsManager.OP_NONE,
                        null, false, false, MY_PID, SYSTEM_UID,
                        parent.id);
            }
        }

        // Send PRE_BOOT broadcasts if user fingerprint changed; we
        // purposefully block sending BOOT_COMPLETED until after all
        // PRE_BOOT receivers are finished to avoid ANR&#39;ing apps
        //用户fingerprint改变&#xff0c;则发送广播
        final UserInfo info &#61; getUserInfo(userId);
        if (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)) {
            // Suppress double notifications for managed profiles that
            // were unlocked automatically as part of their parent user
            // being unlocked.
            final boolean quiet;
            if (info.isManagedProfile()) {
                quiet &#61; !uss.tokenProvided
                        || !mLockPatternUtils.isSeparateProfileChallengeEnabled(userId);
            } else {
                quiet &#61; false;
            }
            mInjector.sendPreBootBroadcast(userId, quiet,
                    () -&gt; finishUserUnlockedCompleted(uss));
        } else {
            finishUserUnlockedCompleted(uss);
        }
    }
</code></pre> 
<h3><a id="120_UCfinishUserUnlockedCompleted_1405"></a>1.20 UC.finishUserUnlockedCompleted</h3> 
<p>[-&gt;UserController.java]</p> 
<pre><code> private void finishUserUnlockedCompleted(UserState uss) {
        final int userId &#61; uss.mHandle.getIdentifier();
        synchronized (mLock) {
            // Bail if we ended up with a stale user
            if (mStartedUsers.get(uss.mHandle.getIdentifier()) !&#61; uss) return;
        }
        UserInfo userInfo &#61; getUserInfo(userId);
        if (userInfo &#61;&#61; null) {
            return;
        }
        // Only keep marching forward if user is actually unlocked
        if (!StorageManager.isUserKeyUnlocked(userId)) return;

        // Remember that we logged in
        mInjector.getUserManager().onUserLoggedIn(userId);

        if (!userInfo.isInitialized()) {
            if (userId !&#61; UserHandle.USER_SYSTEM) {
                Slog.d(TAG, &#34;Initializing user #&#34; &#43; userId);
                //发送ACTION_USER_INITIALIZE广播去给user初始化&#xff0c;&#xff0c;串行广播
                Intent intent &#61; new Intent(Intent.ACTION_USER_INITIALIZE);
                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND
                        | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
                mInjector.broadcastIntent(intent, null,
                        new IIntentReceiver.Stub() {
                            &#64;Override
                            public void performReceive(Intent intent, int resultCode,
                                    String data, Bundle extras, boolean ordered,
                                    boolean sticky, int sendingUser) {
                                // Note: performReceive is called with mService lock held
                                mInjector.getUserManager().makeInitialized(userInfo.id);
                            }
                        }, 0, null, null, null, AppOpsManager.OP_NONE,
                        null, true, false, MY_PID, SYSTEM_UID, userId);
            }
        }

        // Spin up app widgets prior to boot-complete, so they can be ready promptly
        mInjector.startUserWidgets(userId);

        Slog.i(TAG, &#34;Sending BOOT_COMPLETE user #&#34; &#43; userId);
        // Do not report secondary users, runtime restarts or first boot/upgrade
        if (userId &#61;&#61; UserHandle.USER_SYSTEM
                &amp;&amp; !mInjector.isRuntimeRestarted() &amp;&amp; !mInjector.isFirstBootOrUpgrade()) {
            int uptimeSeconds &#61; (int) (SystemClock.elapsedRealtime() / 1000);
            MetricsLogger.histogram(mInjector.getContext(), &#34;framework_boot_completed&#34;,
                    uptimeSeconds);
        }
        //发送ACTION_BOOT_COMPLETED广播&#xff0c;串行广播
        final Intent bootIntent &#61; new Intent(Intent.ACTION_BOOT_COMPLETED, null);
        bootIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);
        bootIntent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT
                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mInjector.broadcastIntent(bootIntent, null, new IIntentReceiver.Stub() {
                    &#64;Override
                    public void performReceive(Intent intent, int resultCode, String data,
                            Bundle extras, boolean ordered, boolean sticky, int sendingUser)
                            throws RemoteException {
                        Slog.i(UserController.TAG, &#34;Finished processing BOOT_COMPLETED for u&#34; &#43; userId);
                    }
                }, 0, null, null,
                new String[]{android.Manifest.permission.RECEIVE_BOOT_COMPLETED},
                AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);
    }
</code></pre> 
<p>到这里已经发送了ACTION_BOOT_COMPLETED广播。</p> 
<h2><a id="_1478"></a>三、总结</h2> 
<p>从开机完成启动到发送开机广播&#xff0c;其中的流程有很多&#xff0c;之前的文章有讲过systemserver启动&#xff0c;AMS、PMS的启动&#xff0c;同时还有Activity和广播的启动&#xff0c;综合着一些再来看这个过程就相对轻松些&#xff0c;同时通过编译版本调试打印出日志&#xff0c;更加证明了分析流程的正确性。</p> 
<p>1.在Launch界面resume阶段&#xff0c;会向主线程消息队列放入new Idler()&#xff0c;在消息队列空闲的时候&#xff0c;就会调用。</p> 
<p>2.通过Binder机制执行AMS的activityIdle&#xff0c;这个方法里面会检查是否完成开机。</p> 
<p>3.调用finishBooting方法&#xff0c;来完成开机。在这个过程中第一次进入由于开机动画还没有停止从而会直接返回。</p> 
<p>4.调用performEnableScreen方法&#xff0c;确定所有的窗口都已经绘制完成&#xff0c;包括Launch&#xff0c;状态栏&#xff0c;壁纸&#xff0c;同时要求开机动画停止&#xff0c;在等待开机动画停止的过程中&#xff0c;有一个30s的超时&#xff0c;同时还有其他的入口来调用WMS的performEnableScreen方法&#xff0c;当动画包停止后通过回调再次执行finishBooting方法。</p> 
<p>5.在对credential-encrypted storage解锁后就正式的发送开机广播BOOT_COMPLETED。</p> 
<h2><a id="_1492"></a>附录</h2> 
<p>源码路径</p> 
<pre><code>frameworks/base/core/java/android/app/ActivityThread.java
frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java
frameworks/base/core/java/android/os/MessageQueue.java
frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java
frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java
frameworks/base/services/core/java/com/android/server/am/UserController.java

</code></pre>